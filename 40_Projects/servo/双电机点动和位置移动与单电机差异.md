# 双电机和单电机移动差异

这一章节集中理解双电机和单电机在：

- 位置移动
- 点动

两个场景下，如何处理移动的。方便我们排查错误。

## DI逻辑

因为要经常与P100S的 P3-30 和 P3-31寄存器打交道，所以这里理解下其逻辑。

### P3-30

此参数决定了 P100S 电机的 DI 分配给了哪些接口。

在`servo`系统中，`P3-30`的值为2，这表示伺服可以通过模拟的数字 DI1~8 来控制。并且DI 1~8的功能是由寄存器：

- P3-38~P3-45这 8 个寄存器决定的

```C++
    m_p100scfgs.append(qMakePair(MotorRegs::P3_38, 28));
    m_p100scfgs.append(qMakePair(MotorRegs::P3_39, 16));
    m_p100scfgs.append(qMakePair(MotorRegs::P3_40, 22));
    m_p100scfgs.append(qMakePair(MotorRegs::P3_41, 23));
    m_p100scfgs.append(qMakePair(MotorRegs::P3_42, 27));
```

对应的功能为：

P3-38到P3-45对应的分别是DI1和DI8的功能。

- P3-38 = 28。DI1 设置`CTRG`，内部位置命令触发。是触发位置运动的功能。

  > 在内部位置寄存器模式时，选择内部位置寄存器控制命令（POS0-2）后，此信号触发，电机根据内部位置寄存器命令运转。当数字输出零速度信号（ZSPD=1）后，才接受下一次触发内部位置命令

- P3-39 = 16.DI2 设置`CMODE`，复合模式控制模式设定。这里PA4为3，所以仅看（1）即可。

  > 当 PA-4 设置为 3，4，5 时，处于混合控制模式，可通过此输入端子可切换控制模式：
  > (1)PA-4 为 3 时,CMODE OFF，为位置模式；CMODE ON，则为速度模式；（之前就设置的值为3）
  > (2)PA-4 为 4 时,CMODE OFF，为位置模式；CMODE ON，则为转矩模式；
  > (3)PA-4 为 5 时,CMODE OFF，为速度模式；CMODE ON，则为转矩模式

- P3-40 = 22.DI3 设置`JOGP`，正向点动。

  > 速度模式下，PA22=5 时，此信号接通，电机正方向寸动，点动速度受 PA21 设置。
  > 注意：此信号跟反向寸动同时接通，寸动功能无效。

- P3-41 = 23.DI4设置`JOGN`，反向点动。

  > 速度模式下，PA22=5 时，此信号接通，电机反方向寸动，点动速度受 PA21 设置。
  > 注意：此信号跟反向寸动同时接通，寸动功能无效。

- P3-42 = 27. DI5 设置`HOLD`，内部位置控制命令停止。是位置移动的紧急停止信号。

  > 在内部位置寄存器模式时，此信号接通，电机将停止运转

## 位置移动

主要逻辑集中在`actionDir()`中。

### 启动逻辑

#### 统一配置

- 设置目标位置：通过统一的`cfgTarget()`配置位置移动参数
- 预启动：`run2TargetPer()`配置电机使能`PA53 = 1`以及`P3_31 = 0`。

 `P3_31 = 0`的含义，就代表了 DI 输入为空，默认不做任何处理。

不过这里双电机仅会配置X1和X2的参数，不会使用广播设置其他电机的参数。

#### 广播问题1

在`motorsMove()`中，如果检测到超过一个电机在运转，则会将`motorID = -1`：

```C++
    if(needcnt>1){
        motorID = M_ALL;
    }
```

此时后续的逻辑均为广播。（此时需要提高警戒了！）

替换完毕广播ID后，立刻调用`run2Target()`，其核心就是：

```C++
m_motorRegs->writeReg16(motorID, MotorRegs::P3_31, 1)
```

`P3-31 = 1`的话，二进制即为`0b0000 0001`，也就是 DI1 设置为 1。而之前的DI1逻辑为

> DI1 设置`CTRG`，内部位置命令触发。是触发位置运动的功能。
>

所以此时电机会按照之前配置好的脉冲数进行移动。

- 当双电机运动的时候，会广播给所有电机的 DI 为位置移动。此时如果其他电机使能（`PA53 = 1`）的话，那么此时此电机可能会位置移动。
- 当单电机运动的时候，仅仅是此单电机位置移动

假如此时双电机位置移动，则`m_needCheck`会记录X1、X2均位置移动需要检查

### 停止逻辑

在执行完毕启动逻辑后，就要检查位置移动是否完成并且进行停止等后续工作。此项工作由`checkMove()`来处理。

在检测到对应电机位置移动完成后，会发送`em_workDone(i)`的信号。

```C++
ret = m_motorRegs->readReg16(i, MotorRegs::S16, tmp);
```

```c++
connect(this, &MotorCtrl::em_workDone, this, &MotorCtrl::on_workDone);

void MotorCtrl::on_workDone(int motorID)
{
    QLOG_INFO()<<QString("行车(电机%1)已到位").arg(DbCtrl::s_motorNameList.at(motorID));
    m_motorRegs->writeReg16(motorID, MotorRegs::PA53, 0);
}
```

但是流程中无法判断是否能让两个电机都使能停止。（这里是否可能将`on_workDone()`改为广播所有电机停止呢？）

## 点动逻辑

这是我们的老朋友了。再来一遍理解其逻辑吧。

### 预启动电机

`applyJogConfig()`逻辑：

- 配置单电机的 DI 输入为点动（前进或者后退）
- 将单电机加入`m_needCheck[]`中以备检查

此时预配置完就相当于，单电机的点动按钮已经被按下，但是还没通电。（此时如果其他电机通电，则会导致点动运行）

### 电机使能

此时如果是双电机，则会发广播让所有电机使能。（此时如果其他电机配置了DI点动或者位置触发），则会导致其他电机运转。

### 运行结束

运行结束，双电机会广播所有电机停止。

单电机会停止自己的电机。
