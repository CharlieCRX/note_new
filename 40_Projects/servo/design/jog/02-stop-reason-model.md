# StopReason 模型：从流程判断到返回事件



## 认知转折点：我意识到“停止不是流程的一部分”

在完成 X1X2 组合限位逻辑后，我逐渐意识到一个问题：

> 在 `checkJog` 中，“停止点动”并不是某个 `if` 的副作用
>
> **而是一个独立的、具有业务含义的事件**

在当前实现里，停止行为总是以如下形式出现：

```C++
if (condition) {
    m_allDone = true;
    actionJogStop();
    SMessageBox::sQdialogBoxOk(...);
    break;
}
```

初看这是一段完整的流程，

但是当停止条件`condition`不断增加时，问题开始显现：

- 同一个“停止动作”，被重复写在多个地方
- 不同停止条件，它们只是 `condition` 不同
- 代码结构无法表达**“这些停止在业务上是同一类行为”**

这让我意识到：

> 停止并不是“通过一个个判断走到这里”的结果，
>
> 而是“系统状态发生变化的事实。

------

## 从“怎么停”到“为什么停”

进一步分析停止条件，可以发现它们在业务上并不相同：

- 有的停止是安全策略触发（组合限位、物理限位）
- 有的停止是系统状态异常（双电机位置超差）
- 有的停止是配置或者环境问题（读取转速失败、双电机未同步使能）

虽然业务上各不相同，但在代码中的表现形式几乎一致。

于是我开始反问自己一个问题：

> 如果点动已经停止，我能不能**不看代码就知道原因**？

在现有结构下，答案是否定的。

这意味着“停止原因”并没有被当作一等业务概念对待。

------

## 显式建模“停止原因”

基于上述认知，我尝试将“停止点动”拆解为两个独立问题：

1. **是否需要停止？**
2. **如果停止，是因为什么？**

这促使我将原本隐式存在于流程中的判断，

提炼为一个明确的领域模型（庞大系统拆分为以业务为核心的模块）：

```C++
enum class JogStopReason {
    None,

    // 同步与使能问题
    DualMotorNotSync,
    DualMotorEnableTimeout,

    // 通用安全限位
    ReachSoftLimit,
    ReachPhysicalLimit,

    // 组合限位相关
    ReachCombinedLimit,
    OtherAxisInDangerZone,

    // 系统异常
    SpeedReadFailed,
};
```

这一步的关键不在于“用了枚举”，
 而在于：

> **我开始用“原因”来描述系统行为，而不是用“流程位置”。**

------

## StopReason 带来的结构变化

一旦“停止原因”被显式建模，代码结构开始自然发生变化。

### 判断逻辑不再直接触发副作用

```C++
JogStopReason reason = checkJogCondition(motorID);
if (reason != JogStopReason::None) {
    handleJogStop(reason, motorID);
    break;
}
```

判断函数只负责回答一个问题：

> **“是否应该停？如果是，为什么？”**

它不再关心：

- 是否弹窗
- 是否写日志
- 是否设置状态变量

### 停止行为集中处理

```cpp
void MotorCtrl::handleJogStop(JogStopReason reason, int motorID)
{
    m_allDone = true;
    actionJogStop();

    showJogStopMessage(reason, motorID);
    logJogStopReason(reason, motorID);
}
```

这样做的直接结果是：

- 所有停止行为都有**统一出口**
- UI、日志、状态更新不再分散
- 可以保证所有停止路径的一致性（之前每一个停止行为，都有自己的解决出口，导致复制代码极其严重）

------

## 对组合限位问题的直接改善

`StopReason` 模型直接解决了之前在组合限位扩展上的结构性痛点：

- X1X2 组合限位与 Z 轴组合限位
   👉 只是**不同的 StopReason 来源**
- 不需要再复制 stop + 弹窗逻辑
- 不需要引入更多全局状态变量
- 新增规则只需：
  - 在判断函数中增加一个分支
  - 定义对应的 StopReason

这使得：

> 即使未来再引入新的跨轴安全规则，
>
> checkJog 的主流程结构也不再发生膨胀。

------

## 本阶段的核心收获

这次重构带来的最大变化不是代码行数的减少，而是**思维方式的转变**：

- 从“流程驱动实现”（What to do）
   → “领域事件驱动设计”（What happened）
- 从“if 越写越多”
   → “规则被显式建模”
- 从“怕改代码”
   → “敢于扩展规则”

也正是在这一刻，我明确意识到：

> **重构的本质，不是让代码更好看，**
>
> **而是让业务逻辑拥有稳定的表达形式。**

而下一步的任务也较为简单：

> **让 `checkJog` 里“为什么停”和“怎么停”分开**

只要做到这一点，后面的 Z 轴组合限位就不再恐怖。
