# 核心问题

近期在完成 X1X2 点动组合限位支持后，`checkJog()` 虽然能够正确工作，但在实现过程中逐渐暴露出一系列**结构性问题**。这些问题并非单点 Bug，而是对当前实现方式的整体不适配。

------

## 1. 停止条件分散在 for / if / break 中

点动停止并不是一个集中表达的概念，而是隐式地散落在多层循环和条件判断中。

例如：

```C++
if (isX1X2NotSync(&val1, &val2) || isX1X2NotEnableOnTime()) {
    m_allDone = true;
    actionJogStop();
    SMessageBox::sQdialogBoxOk(...);
    break;
}
```

```C++
if (((m_jog_dir < 0) && curr <= minLimit + 20) ||
    ((m_jog_dir > 0) && curr >= maxLimit - 20)) {
    m_allDone = true;
    actionJogStop();
    SMessageBox::sQdialogBoxOk(...);
    break;
}
```

```C++
if (currentSpeed < 1) {
    m_allDone = true;
    actionJogStop();
    SMessageBox::sQdialogBoxOk(...);
    break;
}
```

从代码结构上看：

- “停止点动”并没有一个明确的入口
- 每个停止条件都通过 `break` 结束当前循环
- 是否已经完全结束点动，需要通过多处状态变量推断

这使得阅读代码时，必须在脑中不断回答：

> 这个 `break` 到底结束的是哪一层循环？
>
>  是否还有其他地方会再次触发停止？

## 2. 每新增一种停止条件，都要复制 stop + 弹窗逻辑

在当前实现中，**停止动作、日志、弹窗提示是强绑定的**。

典型模式为：

```C++
m_allDone = true;
actionJogStop();
QLOG_WARN() << "...";
SMessageBox::sQdialogBoxOk(...);
break;
```

随着功能扩展，这段逻辑被反复复制：

- 双电机不同步
- 到达软限位
- 触发组合限位
- 转速异常（物理限位）
- 转速读取失败

这种方式在**第一次实现时并不痛苦**，
 但每一次复制都会引入新的风险：

- 弹窗文案是否一致？
- 是否遗漏日志？
- 是否遗漏 `actionJogStop()`？
- 是否在所有分支都正确设置了 `m_allDone`？

停止逻辑并没有被视为一个“整体行为”，而只是**流程中的一段代码片段**。

## 3. 无法快速回答「为什么这次点动停止了？」

当点动被停止时，系统内部并不存在一个统一的“停止原因”。

只能通过：

- 查看日志
- 回溯触发的 if 分支
- 推断当前运行路径

来判断本次停止是由于：

- 双电机不同步？
- 软限位？
- 组合限位？
- 物理限位？

也就是说：

> “停止原因”并没有成为一个**显式的业务概念**，
>  而只是隐藏在执行路径中的一个结果。

这在后续维护、问题复盘或功能扩展时，都会带来额外的认知负担。

## 4. UI 行为嵌入控制逻辑，难以复用

在 `checkJog` 中，安全判断与 UI 行为直接耦合：

```C++
SMessageBox::sQdialogBoxOk(this, QMessageBox::Critical, "..."); 
```

这意味着：

- 该逻辑只能运行在有 UI 的环境下
- 若未来需要无界面运行、远程控制或自动化测试，需要整体重构
- 安全规则本身无法独立验证或复用

安全判断的核心职责本应是**“给出结论”**，而不是决定“如何展示给用户”。

## 5. X1X2 组合限位引入的结构性痛点（关键）

在为 X1X2 点动加入组合限位支持时，代码复杂度出现了明显跃迁。

#### 实现过程中遇到的实际困难：

1. **双电机模式依赖 UI 状态**

   - 是否为 `FrontBack` 模式

   - 是否为 `BothMotors`

      点动逻辑需要直接读取 UI 组件状态才能判断当前业务场景。

2. **组合限位是否启用的判断方式较为原始**

   - 通过 `specialLimit` / `specialStop` 两个字段是否为 0 直接判断
   - 缺乏明确的“组合限位是否启用”语义抽象

3. **Z 轴状态成为 X1X2 安全判断的前置条件**

   - 在进入主循环前，需要额外判断 Z 轴是否已处于危险高度
   - 并通过全局变量 `is_z1_out_saftey_area` 影响后续逻辑分支

4. **在主循环中持续监控 X1X2 是否进入组合限位**

   - 判断逻辑嵌套在已有的限位与同步判断中
   - 停止条件触发时，需要同时处理：
     - 停止动作
     - 日志
     - 弹窗
     - 多个状态变量的更新

这一阶段的开发**并不痛苦**，因为目标明确：

> “只要 X1X2 在 Z 轴危险高度时不越界即可。”

## 6. 面对 Z 轴组合限位扩展时的预期问题（重构触发点）

当开始规划 **Z 轴点动时的组合限位规则** 时，问题变得明显：

#### Z 轴运动时：

- 需要判断 X1X2 是否位于组合限位范围内
  - 若 X1X2 在安全区内：
    - 需持续监控 Z 是否即将超限
  - 若 X1X2 不在安全区内：
    - Z 点动不受该组合规则约束

按照当前 `checkJog` 的实现方式，这意味着：

- 需要复制一套与 X1X2 类似的判断结构
- 需要再次引入新的全局状态变量
- 需要在循环中嵌套更多 if / break 分支
- 需要复制 stop + 弹窗 + 日志 的组合逻辑

这不仅增加了**粘贴错误的风险**，
 也会使 `checkJog()` 的结构膨胀到 **200 行以上**，
 届时：

> 再新增一种安全规则，将变得难以控制和验证。

### 小结：真正卡住的不是“怎么写代码”

真正的问题在于：

> 当前实现方式已经无法自然表达
>  “点动停止是由哪一类安全规则触发的”。

这并不是一次“优化代码风格”的问题，
 而是一次**需要重新建模点动安全规则的信号**。