# PA1：最简单的计算机

> 本章目标：建立对 **“程序如何被表示、加载、执行与调试”** 的整体认知，为后续 Monitor 与表达式求值打下基础。

------

## 1. 本章要解决的核心问题

- 计算机为什么以“指令”为执行单位？
- NEMU 中的“客户计算机”和“客户程序”分别是什么？
- Monitor 为什么需要理解寄存器、内存与表达式？
- 为什么表达式求值是一个**分阶段问题**？

**一句话总结：**

> PA1 并不是在“写模拟器”，而是在学习 **如何站在调试器视角理解一台正在运行的计算机**。

------

## 2. 计算机的执行模型：指令序列

程序在被编译为可执行文件后，本质上被转换为一条条**机器指令**。
CPU 的执行模型可以抽象为：

```c
while (1) {
  从 PC 指向的内存位置取出指令;
  执行指令;
  更新 PC;
}
```

### 为什么 CPU 不直接执行 C 语言？

这是一个关于 **抽象层次（Abstraction）** 的问题：

- **CPU** 追求：简单、稳定、可控、通用
- **高级语言** 追求：表达能力、开发效率、可移植性
- **编译器** 是二者之间的桥梁

如果 CPU 直接支持 C 语言：

- 电路复杂度极高
- 语言演进会反向限制硬件设计
- 指令集无法保持稳定

👉 **指令集是“硬件与软件之间最小、最稳定的契约”**

------

## 3. NEMU 中的“最简单计算机”

NEMU 用 C 代码模拟了一台最基本的计算机（TRM）：

### 结构上包含：

- 程序计数器（PC）
- 通用寄存器
- 内存
- 基本运算单元（如加法）

### 工作方式：

- 取指 → 执行 → 更新 PC

在 NEMU 中需要区分两个概念：

- **客户计算机**：NEMU 中被模拟的计算机
- **客户程序**：运行在该计算机上的程序

这一视角贯穿整个 PA。

------

## 4. 启动参数与 Monitor 初始化

执行：

```bash
make run
```

最终运行的是：

```bash
riscv32-nemu-interpreter --log=.../nemu-log.txt
```

这些参数由 `native.mk` 中的 Makefile 规则拼接生成，并在启动时由：

```c
parse_args(argc, argv)
```

解析。

👉 **结论性认知**：

- NEMU 的“运行行为”并非写死
- Monitor 的行为由 **命令行参数驱动**
- 后续扩展 Monitor 命令时，这一机制非常重要

------

## 5. 模拟内存模型：pmem 与地址映射

### 5.1 模拟物理内存

NEMU 使用一个大数组 `pmem` 模拟物理内存：

- 起始地址：`0x80000000`
- 大小：`128MB`
- 对齐：4KB

这块内存代表 **客户机的物理内存空间**。

------

### 5.2 guest_to_host：地址视角转换

```c
uint8_t* guest_to_host(paddr_t paddr) {
  return pmem + paddr - CONFIG_MBASE;
}
```

该函数完成的不是“计算”，而是 **视角转换**：

- guest 视角：物理地址 `[0x80000000, ...)`
- host 视角：进程虚拟地址 `pmem + offset`

**核心认知**：

> NEMU 并没有“真的”物理内存，
> 它只是把客户机地址映射到了宿主进程的一段数组中。

------

### 5.3 客户程序的加载位置

- 客户程序从 `RESET_VECTOR = 0x80000000` 开始加载
- 对应宿主机地址为 `pmem[0]`

通过 gdb 验证可确认：

- `memcpy()` 正确完成了指令加载
- 客户程序的第一条指令位于 `pmem` 起始位置

👉 **这是后续取指、调试、表达式访问内存的基础前提**

------

## 6. CPU 状态与寄存器显示

### 6.1 CPU 状态结构

在 riscv32 下：

```c
typedef struct {
  word_t gpr[32];
  vaddr_t pc;
} riscv32_CPU_state;
```

全局变量：

```c
CPU_state cpu;
```

👉 **Monitor 所能看到的一切“寄存器状态”，都来自这里**

------

### 6.2 isa_reg_display 的职责

- 打印 32 个通用寄存器
- 打印 PC
- 格式尽量接近 gdb

这里的关键不在于 printf，而在于：

> **Monitor 并不“知道 CPU 在干什么”，它只能“读状态”**

------

## 7. Monitor 与内存访问的边界

Monitor 中访问内存时：

- 使用 `vaddr_read()`
- 不直接使用 `paddr`
- 不自行做地址合法性判断

### 设计原则：

- Monitor：解释用户命令（用户态视角）
- vaddr / paddr 层：负责地址合法性与异常

Monitor 使用`vaddr_read()`进行内存读写的原因：

- monitor **负责解释命令**
- vaddr_read **负责检查合法性**
- paddr_read **负责判断是否在物理内存**

monitor 不应该越界做 paddr 范围判断。

👉 **职责边界清晰，是 PA 中反复强调的设计思想**

------

## 8. 表达式求值：进入 PA 的核心主线

表达式求值是 Monitor 能力的关键组成部分，用于：

- `p EXPR`
- `x N EXPR`
- watchpoint

### 表达式求值必须分阶段

1. 词法分析（tokenize）
2. 语法分析（结构 + 优先级）
3. 求值（结合寄存器与内存）

当前阶段仅完成第一步。

👉 **详细实现与测试过程记录在：**

- 词法分析：📄 [`Topics/Expr/01-Lexical.md`](../../Topics/Expr/01-Lexical.md)

------

## 9. 本章最重要的结论（给未来的自己）

- CPU 的世界只有指令与状态
- Monitor 是“站在用户一侧”的观察者
- 内存与寄存器都是“被解释的状态”
- 表达式求值不是算法题，而是系统设计题

> **PA1 的真正目标，是建立“调试器视角的计算机模型”**

------

