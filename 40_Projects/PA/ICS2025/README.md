------

# ICS2025 · 计算机系统基础（PA / NEMU 学习记录）

> 本仓库用于记录[《计算机系统基础（ICS）》课程（2025）](https://nju-projectn.github.io/ics-pa-gitbook/ics2025/index.html)的学习与实现过程。

本笔记强调：

- **概念 → 工程 → 可验证代码**
- 记录完整的思考与试错路径
- 为后续系统方向（OS / 编译器 / 架构）打基础

------

## 📂 项目结构说明

```text
ICS2025/
├── Chapter/        # 按课程章节组织的系统知识
├── Topics/         # 围绕 PA 的工程专题（博客核心）
├── Code/           # 可运行 / 可测试的代码实现
└── README.md
```

------

## 📘 Chapter：课程主线笔记

```text
Chapter/
└── Ch01_Chapter1/
    ├── Notes.md
    ├── Exercises.md
    └── References.md
```

### Chapter 的定位

- 跟随 ICS 教材与课堂内容
- 关注 **“系统在做什么 / 为什么这么设计”**
- 不追求代码细节

`Notes.md` 只回答三个问题：

1. **这一章到底在解决什么问题？**
2. **我形成了哪些“可以迁移”的认知？**
3. **哪些坑以后看到就该条件反射避开？**

写一句话问自己：

> **“半年后我再看这页，能不能 5 分钟恢复当时的理解？”**

- 能 → Notes.md 合格
- 不能 → 写得太像实验记录

------

## 🔧 Topics：PA 工程专题（重点）

```text
Topics/
└── Expr/
    └── 01-Lexical.md
```

### Topics 的定位

- 以 PA / NEMU 为背景
- 聚焦 **一个具体工程问题**
- 记录：
  - 设计思路
  - 实现策略
  - 边界情况
  - 测试方法

**这是未来博客发布的主要来源。**

------

## 💻 Code：可运行实现

```text
Code/
└── expr/
    └── mock_expr.c
```

### Code 的定位

- 不写说明性文字
- 保持：
  - 可编译
  - 可测试
  - 可复用
- 是 Topics 中结论的“事实依据”

------

## 🧪 测试理念

在 PA 的实现中，尽量做到：

- 核心逻辑可单独拆分
- 不依赖 NEMU 全局状态
- 能在普通 `main()` 中验证行为

例如：

- 将 `expr.c` 拆分为 `mock_expr.c`
- 构建独立的 Token 测试框架
- 验证词法分析的正确性

------

## 📝 博客发布说明

本仓库结构可直接映射为博客文章：

```text
Topics/Expr/01-Lexical.md
→ /ics/pa/expr/lexical-analysis/
```

建议每篇文章包含：

1. 问题背景
2. 设计决策
3. 实现要点
4. 测试方法
5. 总结与反思

------

## 🎯 学习目标

- 能读懂并修改 NEMU 核心代码
- 能将抽象系统概念转化为工程实现
- 建立完整的系统思维路径

------

## 📚 References

- 《Computer Systems: A Programmer’s Perspective》
- NEMU / PA 官方文档
- RISC-V ISA Specification

------

# :star: PA学习方法论

你现在这个问题，其实**已经从“怎么把 PA 做完”，升级成了“怎么把 PA 变成自己的能力”**。
这是一个非常好的节点 👍
下面我会**完全贴合你现在已经建立的笔记体系**，给你一套**可长期复用的学习—做题—沉淀方法论**，而不是泛泛而谈。

------

## 一句话总原则（先给结论）

> **做 PA ≠ 写代码**
> **做 PA = 建立“概念 → 机制 → 证据 → 抽象”的完整闭环**

你的目标不是：

- ❌ 把实验做对
- ❌ 跑过测试

而是：

- ✅ **每一个“为什么”，都能在 Notes 里留下痕迹**
- ✅ **每一个“实现”，都能在 Topics 里被复用**
- ✅ **每一次调试，都能形成“方法论沉淀”**

你现在的目录结构，**已经非常适合这个目标了**。

------

## 一、你的当前系统，其实已经分工很清晰（先确认你没走歪）

你现在的结构是：

```bash
ICS2025/
├── Chapter/
│   └── Ch01_Chapter1/
│       ├── Notes.md
│       ├── Exercises.md
│       └── References.md
├── Topics/
│   └── Expr/
│       └── 01-Lexical.md
├── Code/
│   └── expr/
│       └── mock_expr.c
└── README.md
```

这不是“随便记的笔记”，而是**隐含了一套学习分层**：

| 目录                     | 角色                                 |
| ------------------------ | ------------------------------------ |
| `Chapter/*/Notes.md`     | **你对课程叙事的理解（Why / What）** |
| `Chapter/*/Exercises.md` | **你如何解题 & 卡点在哪里**          |
| `Topics/*`               | **可复用的技术模块（How）**          |
| `Code/*`                 | **最小可验证实现（Evidence）**       |
| `README.md`              | **全局视角 & 学习路线图**            |

👉 接下来你要做的，不是“多记”，而是**让每一次做题都在这四层里各落一次笔**。

------

## 二、做 PA / 手册实验时的「四阶段学习法」（核心）

我给你一个**固定流程**，你以后每一章、每一个 PA 子任务都照这个走。

------

### 阶段 1：只看题目，不写代码（5～20 分钟）

**目标：建立“问题空间”**

你此时只做三件事：

1. **看实验目标**
2. **标出所有陌生概念**
3. **判断：这是机制题？工程题？调试题？**

📌 在 `Notes.md` 里写：

```md
## 本节目标（实验视角）

- 本实验要解决的问题是：
- 输入是什么？
- 输出是什么？
- 成功的判定条件是什么？
```

⚠️ **不要写实现细节**
⚠️ **不要提前看代码**

你是在训练：**读系统需求的能力**

------

### 阶段 2：RTFSC + 手册，对“为什么”负责（Notes.md）

这一阶段，你已经做得**非常好**了，但可以更有意识。

你现在的 Notes.md 特点是：

- 不抄手册
- 会追问「为什么 CPU 不直接执行 C」
- 会顺着代码一路追到 `guest_to_host`

👉 **这是完全正确的方向**。

但我建议你在 Notes.md 中固定用这三类小标题：

#### 1️⃣ 概念澄清（Concept）

```md
## 为什么需要指令而不是 C 语言？
```

- 这是**保证你未来还能读懂自己的笔记**

#### 2️⃣ 机制展开（Mechanism）

```md
## guest_to_host(paddr) 的真实含义
```

- 不止“它做了什么”
- 而是“它建立了什么模型”

#### 3️⃣ 证据验证（Evidence）

```md
## GDB 验证：客户程序加载位置
```

- 像你现在这样，用 gdb
- 这是**系统学习最关键的部分**

> 🔥 一条黄金标准：
> **Notes 里出现 gdb、printf、实验截图，说明你真的理解了**

------

### 阶段 3：实现与抽象分离（Code vs Topics）

当你开始写代码时，请**强制自己遵守一个规则**：

> ❗**Code 目录只放“跑得起来的最小实现”**
> ❗**Topics 目录只写“可以脱离 PA 复用的东西”**

#### 举个你现在正在做的例子：表达式求值

| 内容                        | 放哪里                      |
| --------------------------- | --------------------------- |
| `Token` 结构体              | `Topics/Expr/01-Lexical.md` |
| 正则数组设计原因            | `01-Lexical.md`             |
| `regex[]` 为什么是数组      | `01-Lexical.md`             |
| `make_token()` 的一次性实现 | `Code/expr/mock_expr.c`     |
| “我第一次写错了什么”        | `Exercises.md`              |

你**已经在无意识地这样做了**，现在只是把它变成自觉流程。

------

### 阶段 4：做题 ≠ 交作业（Exercises.md 的正确打开方式）

`Exercises.md` **不是答案集**，而是：

> **你和题目博弈的全过程**

建议固定结构：

```md
## Exercise X：表达式求值

### 题目要求

（用自己的话复述）

### 我的第一反应

- 我最开始以为可以这样做：
- 但后来发现不对，因为：

### 卡点与误区

- regex 顺序错误导致：
- 一元负号判断失败的原因：

### 最终解决方式

- 关键判断条件：
- 关键测试用例：

### 可复用的经验

- 写词法分析时：
- 正则一定要按「最长匹配 + 优先级」排序
```

📌 **这个文件，是你未来复习 PA / 面试系统题 / 自己写解释器时的宝藏**

------

## 三、你如何“边做题边提升笔记能力”

你可以用一个**简单的自检清单**：

每完成一个小任务，问自己 4 个问题：

1. **我今天有没有写下至少一个“为什么”？**
   → Notes.md
2. **我今天有没有把一个实现抽象成 Topic？**
   → Topics/*
3. **我今天有没有记录一个错误或误判？**
   → Exercises.md
4. **如果 6 个月后我回看，我还能看懂吗？**
   → 重构表达，而不是加内容

如果有一天你发现：

> “我现在写 Notes，比看手册更清楚”

那说明你已经**完成从学生到工程师的转变**。

------

## 四、对你当前状态的评价（很重要）

我直接说结论：

> **你现在做 PA 的方式，已经超过 90% 的普通课程完成者**

因为你在做三件很少有人做的事：

- 你在**追溯机制，而不是接受结论**
- 你在**用 gdb 验证模型，而不是相信描述**
- 你在**构建个人知识体系，而不是堆 Markdown**

接下来你只需要：

- 保持节奏
- 不追求“多”
- 每一章都形成**闭环**

------

