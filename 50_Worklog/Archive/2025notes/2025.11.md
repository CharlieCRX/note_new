# 	11.3

## 数据库问题

现在已经将新加的电机数据存储到了`servoMotor_tb`中。并解决了加入后报错的问题（在`CenterWindow::init_UI()`中）：

```C++
MotorStatus *sta = new MotorStatus(this);
```

将其注释掉即可解决。

## 切换分组逻辑

现在要实现的是让控制器支持电机分组设置：

1. 代码中定义3个电机分组
2. 主界面`MotorCtrl`中，加入上拉框，根据电机组编号展示电机名称
3. 切换或选中电机组编号后，对应的电机的`getMotorID`也需要改变为根据电机编号来计算

## 代码耦合

### 问题描述

之前电机的功能ID为：

```C++
typedef enum {
    M_ALL=-1,
    M_X1 = 0,
    M_X2,
    M_Y1,
    M_Z1,
    M_Angle,
    M_Z2,
    M_Y2,

    M_end
}E_MOTOR_ID; // 功能枚举
```

之前`servo`初始化代码的时候，`DbCtrl`类会按照以下形式将数据库读入内存：

```bash
Index 0 | ID: 1 | Name: A_X1 |Speed: 30 | ClickDist: 100 | ModbusID: 1
Index 1 | ID: 2 | Name: A_X2 |Speed: 30 | ClickDist: 100 | ModbusID: 2
Index 2 | ID: 3 | Name: A_Y1 |Speed: 30 | ClickDist: 100 | ModbusID: 3 
Index 3 | ID: 4 | Name: A_Z1 |Speed: 30 | ClickDist: 0   | ModbusID: 4
Index 4 | ID: 5 | Name: A_θ  |Speed: 6  | ClickDist: 15  | ModbusID: 5
Index 5 | ID: 6 | Name: A_Z2 |Speed: 30 | ClickDist: 100 | ModbusID: 6
Index 6 | ID: 7 | Name: A_Y2 |Speed: 10 | ClickDist: 150 | ModbusID: 7
```

当界面中选中了电机`motorID = M_X1(0)`，展示该电机的位置信息的时候，系统做了这些事情（`getDistShowVal()`）：

1. 获取`M_X1`对应的方向：

   ```C
   DbCtrl::m_servoMotor_tb.at(motorID).dir
   ```

   此时明显可以看出，电机的功能ID已经跟数据库的序号耦合了。

2. 获取位置信息：`getLocation()`

   ```C++
   bool BaseConfig::getServoCurrentAbsolutePositionPulseCount(int motorID, quint64 &absPositionPulse) {
       return MotorRegs::get_instance()->readReg64(motorID, MotorRegs::S24_27, absPositionPulse);
   }
   
   // 等价于调用
   m_modbusIO->read(motorID+1, ModbusIO::HoldingRegisters, regAddr, regAddr+3, data)
   ```

   可以看出，此时功能ID已经跟对应的`modbusID`，有一层耦合关系了。并且`motorID + 1`可以看出来，这里的`motorID`并不是`modbusID`，而是功能码。

所以这就导致了一个问题。当我们加入了电机分组后，之前以`E_MOTOR_ID`（`motorID`）作为功能描述码，相应的从数据库获取数据和伺服控制器ID读写控制方式，都要变动。

> **UI 上的索引（`index` / 枚举 `E_MOTOR_ID`）不应再跟数据库里的记录序号耦合**。我们需要把“功能码/界面位置”和“数据库记录/Modbus ID/硬件地址”彻底解耦，并提供稳定的查找 API。

### 当前存在的难点

意识到界面展示的功能ID已经和电机真正的信息无关，但是系统很巧妙地将其联系在一起后，看看我们怎么才能将其中的逻辑抽离开来。并且新需求加入电机分组后，对应功能码`M_X1`在不同的电机分组ID中，对应了不同的电机。

首先就是加入新的电机：

```bash
Index 0  | ID: 1  | Name: A_X1 | ModbusID: 1 
Index 1  | ID: 2  | Name: A_X2 | ModbusID: 2 
Index 2  | ID: 3  | Name: A_Y1 | ModbusID: 3 
Index 3  | ID: 4  | Name: A_Z1 | ModbusID: 4 
Index 4  | ID: 5  | Name: A_θ  | ModbusID: 5 
Index 5  | ID: 6  | Name: A_Z2 | ModbusID: 6 
Index 6  | ID: 7  | Name: A_Y2 | ModbusID: 7 
Index 7  | ID: 11 | Name: B_X1 | ModbusID: 11 
Index 8  | ID: 12 | Name: B_X2 | ModbusID: 12 
Index 9  | ID: 13 | Name: B_Y1 | ModbusID: 13 
Index 10 | ID: 14 | Name: B_Z1 | ModbusID: 14 
Index 11 | ID: 15 | Name: B_θ  | ModbusID: 15 
Index 12 | ID: 16 | Name: B_Z2 | ModbusID: 16 
Index 13 | ID: 17 | Name: B_Y2 | ModbusID: 17 
Index 14 | ID: 21 | Name: C_Z1 | ModbusID: 21 
Index 15 | ID: 22 | Name: C_θ  | ModbusID: 22 
```

- ID和`ModbuID`一一对应关系

这样通过`index`来获取电机信息的方法就不对了。如果我想获取`ID=1`的电机`A_X1`信息的话，应该怎么做？之前通过索引id来获取信息的代码怎么重构更好一点？

### 解决办法

不需要重构，因为后续这个表要被替换掉，所以这个数据库读写逻辑就先将错就错，我们也按照错误的`index`获取数据即可。首先修改数据表：

```bash
Index 0  | ID: 1  | Name: A_X1 | ModbusID: 1 
Index 1  | ID: 2  | Name: A_X2 | ModbusID: 2 
Index 2  | ID: 3  | Name: A_Y1 | ModbusID: 3 
Index 3  | ID: 4  | Name: A_Z1 | ModbusID: 4 
Index 4  | ID: 5  | Name: A_θ  | ModbusID: 5 
Index 5  | ID: 6  | Name: A_Z2 | ModbusID: 6 
Index 6  | ID: 7  | Name: A_Y2 | ModbusID: 7 
Index 7  | ID: 8  | Name: B_X1 | ModbusID: 8 
Index 8  | ID: 9  | Name: B_X2 | ModbusID: 9 
Index 9  | ID: 10 | Name: B_Y1 | ModbusID: 10 
Index 10 | ID: 11 | Name: B_Z1 | ModbusID: 11 
Index 11 | ID: 12 | Name: B_θ  | ModbusID: 12 
Index 12 | ID: 13 | Name: B_Z2 | ModbusID: 13 
Index 13 | ID: 14 | Name: B_Y2 | ModbusID: 14 
Index 14 | ID: 15 | Name: C_Z1 | ModbusID: 15 
Index 15 | ID: 16 | Name: C_θ  | ModbusID: 16 
```

这就是一错再错的将错就错数据库版本。验证通过，没问题了。下一步就是增加下拉栏，用来切换电机组了。

## 下拉框

现在要在`motorCtrl`中实现

```C++
UI_setupMotorGroupSelectors()
```

此函数的功能为：

- 下（上）拉框展示电机分组编号对应的分组名称（0、1、2对应的是前电机、后电机、驻波管电机）
- 用户选中后，相当于修改`m_current_groupID`

# 11.4

上午意识到数据库根据组id和功能码获取电机信息的方法是比较困难的方式。索性放弃将错就错开发，直接测试电机。

好吧，一下午到晚上8：40，没吃晚饭刚好测完收拾起来。

今天就这样结束了。

# 11.5

## 电机组问题思考

后续需要加入电机组的概念，所以当前项目结构需要做些调整。

电机后续要实现的功能：

1. 可配置的电机组
2. 蓝牙盒子统一记录电机核心信息

具体细节我们再阐述下。这里仅限于蓝牙盒子的讨论，暂时不进行对于可配置的电机组思考。

### 蓝牙盒子接口1：绝对位置接口

首先是蓝牙盒子作为统一零点管理的权威电机数据中心，直接管理每个电机的零点绝对位置以及限位信息。所有外设读取同一份数据，实现零点、限位的统一。

1. 获取特定电机的绝对位置信息（绝对零点和限位信息）

2. 判断绝对位置信息是否被修改：确保PC+PSP双设备同时修改限位、零点的时候，避免竞争问题

   是否蓝牙盒子可以储备一个电机信息的修改状态，类似`times%1000`，只要修改一次零点或者限位信息，就`times++`（就是核心思想而已，并不代表最终的变量名）

3. 一方设备修改限位、零点后，另一方在线设备在移动之前需要得知修改内容

4. 修改电机绝对位置信息

具体调用逻辑的话，就以切换某一个电机随后执行位置移动为一个完整流程，看下整体调用流程：

在`MotorCtrl`初始化的时候，已经获取特定电机的绝对位置信息。

1. 切换电机功能为旋转

   - 旋转按钮被clicked，选中旋转电机
   - 设置相对位移到数据库保存
   - 点击位置移动前进

2. 位置移动`actionDir()`

   - 从数据库中获取刚保存的[旋转电机] 移动的相对位移`L_distance`
   - 判断绝对位置信息是否被修改
     - 是：重新获取电机绝对位置信息
     - 否：继续沿用已经保存的绝对位置信息
   - 从伺服控制器中获取电机相对零点的相对位置`L1`
   - 从已保存的数据中获取蓝牙盒子保存的零点的绝对位置`L0`
   - 计算电机当前电机在绝对限位中的绝对位置`L_abs_position = L0 + L1`
   - 计算电机移动后最终的绝对位置：`L_target = L_abs_position + L_distance`
   - 判断`L_target `是否超出限位
     - 是：报错
     - 否：执行位置移动即可


## 蓝牙盒子接口定义

   ### 1. 获取电机绝对位置信息

   **接口描述**：获取特定电机的零点绝对位置和限位信息

   ```cpp
   /**
    * @brief 获取电机绝对位置信息
    * @param motorId 电机ID
    * @param[out] zeroPosition 零点的绝对位置
    * @param[out] positiveLimit 正限位绝对位置
    * @param[out] negativeLimit 负限位绝对位置  
    * @param[out] version 数据版本号（用于判断是否被修改）
    * @return bool 成功返回true，失败返回false
    */
   bool getMotorAbsoluteInfo(int motorId, 
                            int32_t& zeroPosition,
                            int32_t& positiveLimit, 
                            int32_t& negativeLimit,
                            uint32_t& version);
   ```

   **调用时机**：
   - `MotorCtrl`初始化时
   - 检测到版本号变化时
   - 切换电机功能时

   ### 2. 检查绝对位置信息版本

   **接口描述**：快速检查电机位置信息是否被修改

   ```cpp
   /**
    * @brief 检查电机绝对位置信息版本
    * @param motorId 电机ID
    * @param[out] currentVersion 当前版本号
    * @return bool 成功返回true，失败返回false
    */
   bool checkMotorInfoVersion(int motorId, uint32_t& currentVersion);
   ```

   **调用时机**：
   - 位置移动`actionDir()`执行前
   - 点动操作执行前

   ### 3. 设置电机零点位置

   **接口描述**：更新电机的零点绝对位置

   ```cpp
   /**
    * @brief 设置电机零点绝对位置
    * @param motorId 电机ID
    * @param zeroPosition 新的零点绝对位置
    * @return bool 成功返回true，失败返回false；且每次修改递增version
    */
   bool setMotorZeroPosition(int motorId, int32_t zeroPosition);
   ```

   **调用时机**：
   - 执行`setOrigin()`归零操作时
   - 用户手动设置零点时

   ### 4. 设置电机限位信息

   **接口描述**：更新电机的限位绝对位置

   ```cpp
   /**
    * @brief 设置电机限位信息
    * @param motorId 电机ID
    * @param positiveLimit 正限位绝对位置
    * @param negativeLimit 负限位绝对位置
    * @return bool 成功返回true，失败返回false；且每次修改递增version
    */
   bool setMotorLimits(int motorId, int32_t positiveLimit, int32_t negativeLimit);
   ```

   ## 数据结构和缓存设计

针对后续`servo`项目结构调整，需要加入蓝牙盒子的数据：

   ### 1. 电机位置信息缓存结构

   ```cpp
   struct MotorPositionInfo {
       int32_t zeroPosition;      // 零点绝对位置 L0
       int32_t positiveLimit;     // 正限位绝对位置
       int32_t negativeLimit;     // 负限位绝对位置
       uint32_t version;          // 数据版本号
   };
   ```

   ### 2. 版本号管理策略

   - **版本号格式**：`uint32_t`，每次修改递增
   - **版本检查**：移动前比较缓存版本与蓝牙盒子当前版本
   - **版本同步**：版本不一致时重新获取完整信息

## 绝对位置的2次思考

### 当前系统存在的问题

当前行车移动中，设置原点的思路就是直接**清除伺服控制器绝对位置脉冲数**。

这个绝对位置脉冲记录了电机的绝对位置。当前系统中设置了电机原点后，设置限位的方法是：

1. 从零点开始，向上移动到限位块，记录当前位置，作为上限位
2. 从零点开始，向下移动到限位块，记录当前位置，作为下限位

但是这样导致的问题就是，如果在某个时刻，重新清除了电机绝对位置脉冲数，那么上下限位都无效了。这时候需要重新设置限位。

### 解决思路

绝对位置的记录与相对位置的记录区分。

将当前的系统的位置信息分为两个：

- 绝对位置：上下限位 + 相对零点的绝对位置（不会随意修改）
- 相对位置：用户展示，可以随意修改

面向管理员操作：绝对位置的设置和修改，就只限制在设置界面中。当电机（这里以`Z1`为例）位置移动到水平面后：

- 点击设置界面，输入管理员密码并进入
- 点击设置绝对零点按钮，弹出确认弹窗，点击确认按钮

同样地，设置上下限位也是同样地思路。这样设置上下限限位、设置绝对位置的零点，确保是管理员控制即可。

面向操作用户的操作：

- 设置相对零点：将当前的绝对位置`L_0`设为电机移动的相对零点`relativeZeroPosition`。此时`L_0`会被记录在绝对位置体系中。默认`L_0 = 0`。

  如果此时绝对位置为20mm，设置为相对零点的话，那么`L_0 = 20`

### 引入绝对位置系统的位置移动逻辑

这样绝对位置信息就由三个核心变量组成：

- 上限位：`positiveLimit`；
- 下限位：`negativeLimit`；
- 相对零点的绝对位置：`relativeZeroPosition`

现在我们以左右位置移动为例，思考下引入绝对位置系统后，位置移动`actionDir()`中判断是否超出绝对限位的逻辑：

#### 1.计算期待移动到的绝对位置

- 获取基于相对零点移动的相对位移`L_distance`（存储于本机数据库中）
- 获取相对零点的绝对位置`relativeZeroPosition`
- 计算目标位置的绝对位置：`L_targetAbsPos = relativeZeroPosition ± L_distance`

#### 2.与绝对位置的限位进行比对

判断计算出的目标位置的绝对位置，是否在上下限位内：

- `L_targetAbsPos < positiveLimit`
- `L_targetAbsPos > negativeLimit`

如果满足上述判断条件，则验证位置移动并未超出绝对限位。可以执行位置移动。

## 当前数据库的思考

后面系统要根据组id和功能码，计算对应电机的`motorID`。然后根据`motorID`去获取电机的配置信息。

蓝牙盒子需要支持获取的数据结构为：

```sql
typedef struct __servoMotor_tb__{
    int id;
    char name[8];
    char model[64];
    char position[64];
    int modbusID;
    
    int gearRatio;
    float outsideDiameter;
    int screwPitch;
    float speed;
    float clickDistance;
    float currLocation;
    int dir;
    char linkStat[8];
    int isEnable;               // 是否采用此电机
    
    int maxLimit;
    int minLimit;
    float relativeZeroPosition; // 相对零点的绝对位置
    int version;                // 电机信息版本
}T_servoMotor_tb;
```

现在需要将之前每个设备维护的单一电机信息，变为蓝牙盒子统一维护的电机信息。这里会通过统一的接口访问。在初始化的时候，会调用获取电机信息的逻辑。

## 电机信息接口

与蓝牙盒子需要做到的交互：

### 电机结构信息

```C++
typedef struct __servoMotor_tb__{
	int id;
	char name[8];
	char model[64];
	//char position[64]; // 通过ModbusID定义电机运动方向后，这个定义不在作为配置记录
	int modbusID;
	int groupID; // 组ID
	int gearRatio;
	float outsideDiameter;
	int screwPitch;
	//float speed;   //直接读取电机速度，如果电机速度丢失，则提示用户配置默认速度
	float clickDistance;
	//float currLocation;  // 去掉这个
	int dir;
	//char linkStat[8];   这个自行在上位软件处理，不传到小盒子内
	int isEnable; // 是否采用此电机
	int maxLimit;
	int minLimit;
	int specialLimit; //特殊限位起始，只记录限位值，具体逻辑由上层业务处理
	int specialStop; //特殊限位结束，只记录限位值，具体逻辑由上层业务处理
	float relativeZeroPosition; // 相对零点的绝对位置
	int version; // 电机信息版本
}T_servoMotor_tb;
```

### 虚拟接口

#### 1.获取所有电机信息

```C++
/**
 * @brief 获取所有电机信息
 * @return QVector<T_servoMotor_tb> 电机信息列表
 */
virtual QVector<T_servoMotor_tb> getAllMotorsInfo() = 0;
```

#### 2.根据电机ID获取电机信息

```C++
/**
 * @brief 根据电机ID获取电机信息
 * @param motorId 电机ID
 * @return T_servoMotor_tb 电机信息
 */
virtual T_servoMotor_tb getMotorInfo(int motorId) = 0;
```

#### 3.更新电机信息到蓝牙盒子

```C++
/**
 * @brief 更新电机信息到蓝牙盒子
 * @param motorInfo 电机信息
 * @return bool 成功返回true，失败返回false；且每次修改递增version
 */
virtual bool updateMotorInfo(const T_servoMotor_tb &motorInfo) = 0;
```

# 11.24

婚嫁结束。开始正常上班了。:laughing:今天脑子并不是特别在状态，所以今天就理顺要做的逻辑吧。

## 电机组重构逻辑

要加入的功能有：

1. 电机组区分
2. 绝对位置体系
3. 配套电机体系（共享同一套限位配置）
4. 禁用/启用单电机

## 创建开发分支

为了方便后续软件使用，现在要进行分支管理。此时远程和本地都没有新的分支，需要创建并推送到远程。只有 main，想基于 main 创建 develop。

### **1️⃣ 从 main 创建 develop 分支**

```bash
git checkout -b develop
```

说明：

- `-b` 表示创建并切换
- 这会基于你当前的 main 创建一个新的分支

### 2️⃣ 推送到远程并设为跟踪分支

```bash
git push -u origin develop
```

说明：

- `-u`（与 `--set-upstream` 同功能）会绑定远程 develop
- 以后直接 `git push` 就行，不用带分支名

## 电机编号映射逻辑

电机分组后，获取电机配置ID的映射函数逻辑为:

```C++
// 核心映射函数：根据功能+组号 -> MODBUS_ID
static int getModbusID(E_MOTOR_ID motor_func) {
    return 10 * m_current_group + motor_func;
}
```

这样对于获取电机的ID函数`getMotorID()`，其需要将选中的功能码传输给`getModbusID()`获取最终的电机编号即可。

但是如何指定对应的电机组ID`m_current_group`呢？

## 电机组的选择

我们实现了`GroupManager`类，以此来记录当前电机组号以及对应的获取电机ID的功能：

```C++
#ifndef GROUPMANAGER_H
#define GROUPMANAGER_H
#include "commdef.h"
class GroupManager {
private:
    static int m_current_group; // 组号

public:
    static void setCurrentGroup(int group_id) {
        m_current_group = group_id;
    }

    static int getCurrentGroup() {
        return m_current_group;
    }

    // 核心映射函数：根据功能+组号 -> MODBUS_ID
    static int getModbusID(E_MOTOR_ID motor_func) {
        return 10 * m_current_group + motor_func;
    }
};

#endif // GROUPMANAGER_H
```

然后在`main`函数中，**设置 GroupManager 当前组 ID = 0**， 并且 **允许后续 UI 事件动态修改 GroupManager 的 group**，然后 MotorCtrl 也能更新内部状态。

`setCurrentGroup()`预留了后续电机界面切换电机组后，重新设置电机组ID的功能。但是分组后，如果不是组ID=0，那么对应的数据怎么组织呢？

## 展示组1的电机信息

现在想要获取电机组1中，对应电机的信息。通过研究当下电机的展示和操作逻辑，我们看下如何下手。

切换电机组后，默认跳转到此电机组中，能够正常使用的电机上。首先就是X1、X2电机信息的展示。

### 双电机时展示X1/X2信息

将原先motorID与modbusID耦合的代码改为：

```C++
if(m_frontBackModel_btgrp->checkedId() == BothMotors){
    int x1_motorID = GroupManager::getModbusID(M_X1);
    int x2_motorID = GroupManager::getModbusID(M_X2);
    m_currVal_lb->setText(QString("%1\n%2").arg(getDistShowVal(x1_motorID), getDistShowVal(x2_motorID)));
}
```

### 获取电机的速度

下面就是获取电机速度`getSpeedShowVal()`的时候，当判断当前电机为旋转电机的时候，要使用旋转电机的速度计算方法（所有旋转电机都适用）所以这里需要通过 `modbus_id` 找回对应的 `E_MOTOR_ID`。

所以之前的判断：

```C++
if(M_Angle == motorID)
```

需要改为：

```C++
if(M_Angle == GroupManager::getMotorFuncFromModbusID(motorID))
```

明天处理的目标就是替换数据库表示！下班！

# 11.25

今天就要跟烦人的数据库战斗爽了！😎别给咱丢面啊~

## 当前数据存储逻辑

要想修改之前的数据库逻辑，首先要理解系统之前与数据库的交互逻辑。

这里依然以控制系统启动后，电机展示X1X2信息的逻辑出发，看下哪里用到了数据库保存的数据。

### 获取当前电机的方向

在展示当前电机的位置信息`getDistShowVal()`时，位置信息由：

- 电机的当前位置
- 电机的运动方向

这两项决定。转换为代码（在`getDistShowVal()`函数中定义）为：

```C++
float val = getLocation(motorID)*DbCtrl::m_servoMotor_tb.at(motorID).dir;
```

电机的当前位置是通过读取伺服控制器实时访问的；而电机的运动方向则是通过读取`m_servoMotor_tb`这个列表信息获取到的。

那么我们看下运动方向是怎么保存到这个结构中的。

#### 数据库处理逻辑

内存中的伺服电机配置数据 (`m_servoMotor_tb`) 始终与数据库中的最新数据保持同步：

```C++
typedef struct __servoMotor_tb__{
    int id;
    char name[8];
    char model[64];
    char position[64];
    int modbusID;
    float outsideDiameter;
    int gearRatio;
    int screwPitch;
    float speed;
    float clickDistance;
    float currLocation;
    int maxLimit;
    int minLimit;
    int dir;
    char linkStat[8];
    int isEnable; // 是否采用此电机
}T_servoMotor_tb;

static QVector<T_servoMotor_tb>  m_servoMotor_tb;
```

`DbCtrl::m_servoMotor_tb`：是内存中的电机配置表

- **类型和作用:** 这是一个静态成员变量，类型为 `QVector<T_servoMotor_tb>`。它是一个存储了所有伺服电机配置信息的**列表**或**向量**。
- **数据来源:** 在 `DbCtrl::DbInit` 执行成功后，所有数据库中 `servoMotor_tb` 表里的数据（包括默认数据）都会被加载到这个静态向量中。
- **关键点:** 这是一个**内存缓存**，目的是让应用程序可以快速访问电机配置，而无需每次都查询数据库

其初始化是由函数`initOrLoadServoMotors()`实现的：

```C++
int DbCtrl::initOrLoadServoMotors(QSqlDatabase &db);
```

- 检查 `servoMotor_tb` 表是否存在且是否有数据
- 确定是首次初始化还是只需加载数据
- 从 `servoMotor_tb` 表中读取所有电机配置的字段值。
- 将数据库中的持久化数据加载到静态内存容器 `DbCtrl::m_servoMotor_tb` 中，供上层业务逻辑使用。
- 完成 `servoMotor_tb` 的初始化或加载工作。

#### 当前存在的耦合问题

在当前的设计中，`motorID` 作为内存数组的索引来访问电机数据，与数据在数据库中的**逻辑顺序和加载顺序**产生了**强耦合**。

| **元素**                     | **依赖关系**                                         |
| ---------------------------- | ---------------------------------------------------- |
| **`motorID` (索引)**         | **`m_servoMotor_tb` 向量中的位置 (0, 1, 2...)**      |
| **`m_servoMotor_tb` 的位置** | **数据库查询 `SELECT \*` 的返回顺序**                |
| **数据库查询顺序**           | **数据插入的物理顺序 或 数据库默认的 `id` 字段排序** |

**核心风险：**

1. **数据变更的脆弱性 (Fragility):**
   - 如果数据库中的电机顺序发生变化（例如，手动删除再重新插入，或者使用 `ORDER BY` 以外的查询方式，虽然 SQLite 通常按 `rowid` 或 `id` 排序），`motorID = 2` 对应的电机可能会变成另一个电机。
   - 如果未来您决定在数据库中插入一个新的电机（如 ID=8），但希望它在列表中出现在第 0 个位置（例如，作为系统主轴），那么所有依赖于索引的 `motorID` 都将错位。
2. **代码的可读性差:** `m_servoMotor_tb.at(3)` 很难直观地告诉业务逻辑它正在操作哪个电机，除非你时刻记住 “索引 3 对应的是 X1”。
3. **不一致性:** 您的数据库设计中，`T_servoMotor_tb` 结构体包含了一个明确的 `id` 字段 (`int id;`)，但业务代码却在使用另一个隐式的 ID（向量索引）。这引入了两个 ID 体系，容易混淆。

### 修改思路

#### 1.结构修改

现在由于业务修改，需要将电机的信息修改为：

```C++
typedef struct __servoMotor_tb__{
	int id;
	char name[8];
	char model[64];
	//char position[64]; // 通过ModbusID定义电机运动方向后，这个定义不在作为配置记录
	int modbusID;
	int groupID; // 组ID
	int gearRatio;
	float outsideDiameter;
	int screwPitch;
	//float speed;   //直接读取电机速度，如果电机速度丢失，则提示用户配置默认速度
	float clickDistance;
	//float currLocation;  // 去掉这个
	int dir;
	//char linkStat[8];   这个自行在上位软件处理，不传到小盒子内
	int isEnable; // 是否采用此电机
	int maxLimit;
	int minLimit;
	int specialLimit; //特殊限位起始，只记录限位值，具体逻辑由上层业务处理
	int specialStop; //特殊限位结束，只记录限位值，具体逻辑由上层业务处理
	float relativeZeroPosition; // 相对零点的绝对位置
	int version; // 电机信息版本
}T_servoMotor_tb;
```

#### 2.存储介质的改变

之前每个程序都维护自己的一份电机配置参数，这就会导致：

> 如果两个程序控制相同的电机，A程序修改了电机参数，但是B程序无法得知A的修改内容，所以需要手动同步一份

为了解决这个问题，就需要将电机的配置放到一个权威的配置中心。这里我选用了一个数据盒子，通过modbus协议来与数据盒子交互。

这样两个程序在修改完电机的配置后，另一个电机也会读取到修改的配置。

基于对代码片段（`dbctrl.h` 和 `dbctrl.cpp`）的分析，结合您提出的两个重大变更（结构体修改和存储介质切换），当前代码体系中重构的**高风险点**可以归纳为以下四类：

------

## 🛑 当前代码体系重构的三大高风险点

### 风险一：强耦合带来的雪崩效应（最直接的风险）

**问题核心：** 数据访问逻辑与数据结构（`T_servoMotor_tb`）和数据存储容器（`QVector`）高度绑定。

| **高风险点**          | **详细描述**                                                 | **影响范围**                                                 |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **索引依赖**          | 大量函数（如 `getSpeed`, `setClickDist`, `checkIfEnabled` 等）使用 **`qint32 motorID`** 作为参数，这个 `motorID` 实际上是 **`QVector` 的索引**。 | **所有上层业务逻辑和所有访问函数**。一旦如前所述将 `QVector` 换成 `QMap`，所有使用索引的调用都会失败或逻辑错误。 |
| **裸数据访问**        | 代码直接通过`m_servoMotor_tb.at(motorID).isEnable` 方式**裸露地访问**静态成员的内部字段。 | 只要修改 `T_servoMotor_tb` 结构体（例如，删除 `position` 字段），所有直接访问该字段的代码都会立即产生**编译错误**。 |
| **DB ID 与 索引混淆** | 在 `setMotorEnableState` 等函数中，代码使用了 `UPDATE ... WHERE id=%2`，并且 `id` 的值是 `motorID + 1`。这明确地将 **`QVector` 索引** 与 **数据库主键 ID** (假设从 1 开始) 绑定在一起。 | 任何修改/更新数据库的操作。如果 `motorID` 不再是顺序的，更新操作将错误地修改其他电机的配置。 |

------

### 风险二：结构体变更带来的数据兼容性挑战

**问题核心：** `T_servoMotor_tb` 结构体的修改。

| **高风险点**               | **详细描述**                                                 | **影响范围**                                 |
| -------------------------- | ------------------------------------------------------------ | -------------------------------------------- |
| **旧数据（SQLite）的迁移** | 当您修改 `T_servoMotor_tb` 结构体后，您的 `servoMotor_tb` 表结构必须同步更新（删除旧字段，新增新字段）。如果用户已经有了旧版本的数据库文件，**重构后的代码必须能安全地处理数据库升级**。 | `DbInit` 和所有数据库加载/保存逻辑。         |
| **新旧字段的映射**         | 您新增了 `groupID`, `specialLimit`, `version` 等字段，这些字段在初始化时需要合理的默认值。如果 `DbInit` 中插入默认数据的逻辑没有完全覆盖新字段，可能导致未初始化或错误的数据。 | `DbInit` 和 `createAndInitServoMotorTable`。 |

------

### 风险三：存储介质切换（Modbus）的额外复杂性

**问题核心：** 切换到 Modbus 数据盒子作为权威配置中心。

| **高风险点**     | **详细描述**                                                 | **影响范围**                     |
| ---------------- | ------------------------------------------------------------ | -------------------------------- |
| **性能瓶颈**     | 从本地 SQLite 访问内存是毫秒级的。通过 Modbus（通常是串口或 TCP/IP）访问外部盒子是**网络或 IO 延时**。如果 Modbus 访问不是异步的，或访问频率过高，将严重**阻塞**主程序 UI 或控制逻辑。 | 所有需要读取配置参数的业务逻辑。 |
| **原子性与事务** | Modbus 通常不提供像 SQL 那样的事务保证。如果一个电机的多个参数需要同时更新（如 `minLimit` 和 `maxLimit`），而其中一个写入失败，配置盒子里将留下**半成品**的错误数据。 | 所有修改电机配置的函数。         |

### 重构的专业建议总结

鉴于这些风险，我的建议（“数据访问门面模式”）正是针对性地解决两个主要风险：

1. **Repository 模式 (阶段一)**：直接解决**风险一（耦合）**和**风险二（结构体变更）**。它将数据结构和访问逻辑隔离，使得结构体修改和旧数据的迁移成为局部问题。
2. **抽象接口 (阶段二)**：直接解决**风险三（介质切换）**。它允许您先用 Modbus 在后台测试，不影响当前 SQLite 系统的运行，并且让上层代码不用关心底层是 Modbus 还是 SQLite。

这是一个涉及**数据架构（Schema）修改**和**持久化存储机制（Persistence Mechanism）重大变更**的复杂重构任务。在大规模重构中，更改核心数据结构的访问方式（从索引到 ID）确实会引发**雪崩式的修改**。这种“牵一发而动全身”的感觉正是我们作为重构专家需要解决的问题。

作为一名专业的重构和 Clean Code 编写者，我的建议是采用 **渐进式重构（Strangler Fig Pattern / Mikado Method）** 的核心思想：**引入抽象层，分阶段替换，而不是一步到位。**

我们称之为 **“数据访问门面模式”（Data Access Facade）**。

## 解决思路：引入“索引适配层”

问题的核心在于：上层业务代码依赖于旧的、脆弱的 `qint32 motorID`（实际上是索引）。我们不能直接修改所有调用点，而是应该在**数据结构**和**调用者**之间插入一个**适配层（Adapter）**。

> 这个实现将负责：
>
> 1. **清空**旧的 `QVector` 和适配器。
> 2. **查询**数据库。
> 3. 在循环中，将数据**加载**到新的 `m_servoMotor_tb_by_id` (`QMap<int, T_servoMotor_tb>`) 中，键是数据库主键 `id`。
> 4. 同时，填充 **`s_motorIndexToDBIDMap`** (`QMap<qint32, int>`)，将加载的**顺序索引**映射到**数据库 ID**。

### 1. 第一阶段：隔离和适配（重构的第一步）

**目标：** 保持所有公共接口（`getSpeed(qint32 motorID)` 等）不变，但在内部实现中，将索引映射到真正的数据库 ID。

注意：保持旧的 `m_servoMotor_tb` 不变，直到所有函数都改造完毕再删除



**步骤 1.1: 修改数据结构（DbCtrl::m_servoMotor_tb）**

将 `QVector<T_servoMotor_tb>` 替换为 `QMap<int, T_servoMotor_tb>`，其中 `int` 是数据库主键 `id`。

- **`dbctrl.h`:**

  ```C++
  // 原代码 (QVector)
  static QVector<T_servoMotor_tb>  m_servoMotor_tb;
  
  // 重构后 (QMap)
  // 使用数据库 ID (T_servoMotor_tb::id) 作为 Key
  static QMap<int, T_servoMotor_tb>  m_servoMotor_tb_by_id; 
  ```

**步骤 1.2: 引入“索引适配器”**

我们需要一个新的静态结构来维护**旧索引**和**新主键 ID** 的映射关系。

- **`dbctrl.h` (新增):**

  ```C++
  // 静态成员：映射旧的数组索引(0, 1, 2...) 到 数据库主键 ID (1, 2, 3...)
  static QMap<qint32, int> s_motorIndexToDBIDMap; 
  ```

**步骤 1.3: 修改加载逻辑 (`initOrLoadServoMotors`)**

在数据加载时，填充 `QMap` 和 `s_motorIndexToDBIDMap`。

- **`dbctrl.cpp` (`initOrLoadServoMotors` 核心改动):**

  ```C++
  // ... 在加载数据循环中 ...
  
  // 从数据库中获取真正的 DB ID (Primary Key)
  int motorDBID = sqlQuery.value("id").toInt();
  d_tb.id = motorDBID;
  
  // 1. 填充新的 QMap
  m_servoMotor_tb_by_id.insert(motorDBID, d_tb);
  
  // 2. 填充索引适配器。当前的循环次数 (index) 就是旧的 motorID。
  // QMap 是有序的，我们可以用一个计数器来实现 index
  static qint32 currentIndex = 0; 
  s_motorIndexToDBIDMap.insert(currentIndex, motorDBID);
  currentIndex++;
  
  // ...
  ```

在 `initOrLoadServoMotors` 函数的末尾添加一个**临时验证逻辑**，专门用于打印新旧数据结构的关键信息：

1. **`m_servoMotor_tb_by_id` (新 Map)**：确认所有电机数据都已加载，并且 Map 的 **Key** (数据库 ID) 正确。
2. **`s_motorIndexToDBIDMap` (适配器)**：确认每个旧索引 (0, 1, 2...) 都正确地映射到了相应的 **数据库 ID**。
3. **一致性检查**：通过适配器查找到的 ID，从 `m_servoMotor_tb_by_id` 中取出的电机数据，必须与旧的 `m_servoMotor_tb` (`QVector`) 顺序对应。

**步骤 1.4: 改造所有公共接口的内部实现**

本阶段的目标是：**隔离所有外部调用对旧索引`qint32 motorID`的依赖**，并在内部实现中使用 **`s_motorIndexToDBIDMap`** 和 **`m_servoMotor_tb_by_id`**。

- **`dbctrl.cpp` (以 `getSpeed` 为例):**

  ```C++
  // 原代码（强耦合）：
  // float DbCtrl::getSpeed(qint32 motorID)
  // {
  //     return m_servoMotor_tb.at(motorID).speed; 
  // }
  
  // 重构后的代码（解耦）：
  float DbCtrl::getSpeed(qint32 motorID)
  {
      // 1. 使用索引适配器，将旧索引 motorID 转换为真正的数据库主键 ID
      if (!s_motorIndexToDBIDMap.contains(motorID)) {
           QLOG_ERROR() << "Motor ID (Index) not found: " << motorID;
           return 0.0f; // 错误处理
      }
      int motorDBID = s_motorIndexToDBIDMap.value(motorID);
  
      // 2. 使用数据库主键 ID 访问新的 QMap 缓存
      if (!m_servoMotor_tb_by_id.contains(motorDBID)) {
           QLOG_ERROR() << "Motor DB ID not found in QMap: " << motorDBID;
           return 0.0f; // 错误处理
      }
      return m_servoMotor_tb_by_id.value(motorDBID).speed; 
  }
  ```

------

### 2. 第二阶段：渐进式替换（消除旧接口）

在完成第一阶段后：

1. **所有业务代码** 不需要改动，仍然使用 `getSpeed(motorID)`。
2. **核心数据结构** 已经解耦，不再依赖于数据库的顺序。

接下来，您可以**逐步**进行替换：

1. **添加新的函数接口（使用主键 ID）**：

   ```C++
   // dbctrl.h
   static float getSpeedByID(int motorDBID); // 新增
   ```

2. **改造上层调用者**：在业务逻辑代码中，每当发现一个地方能轻松获取到**数据库主键 ID** 时，就将 `getSpeed(motorID)` 的调用替换为 `getSpeedByID(motorDBID)`。

3. **淘汰旧接口**：当所有调用都替换完毕后，您可以安全地删除所有以 `qint32 motorID`（索引）为参数的旧函数（如 `getSpeed`），并删除 `s_motorIndexToDBIDMap` 适配器。

### 总结方法论

| **步骤**                | **行动**                                                     | **结果**                                           | **目的**                                 |
| ----------------------- | ------------------------------------------------------------ | -------------------------------------------------- | ---------------------------------------- |
| **1. 适配 (Adapter)**   | 引入 `s_motorIndexToDBIDMap` 和 `m_servoMotor_tb_by_id`，并在旧接口内部进行 ID 转换。 | **零停机时间**，业务代码不改动，但数据结构已解耦。 | 保持兼容性，控制修改范围，实现安全过渡。 |
| **2. 隔离 (Facade)**    | 将所有的公共访问函数（如 `getSpeed`）的内部实现都指向 `m_servoMotor_tb_by_id`。 | 核心数据访问逻辑集中，便于后续修改。               | 封装变化，准备统一接口。                 |
| **3. 替换 (Migration)** | 创建新的 ID 驱动接口 (`getSpeedByID`)，逐步替换上层业务代码中的旧调用。 | 逐步淘汰旧接口，验证新逻辑。                       | 减少一次性大量修改带来的风险。           |

这种**引入适配层**的策略是处理遗留代码（Legacy Code）和核心数据结构变动的最佳实践，它能让您在**不立即修改所有调用点**的前提下，完成底层的架构升级。

# 11.26

走的太极端了。已知电机信息不需要数据库存储，所以之前的数据库组织方法可以放弃了。

然后另一个导致系统复杂的是，就是motorID与电机配置索引耦合的问题，这个问题也好解决：

依旧按照motorID作为下标进行索引，但是初始化的时候，需要加入空数据以支撑这个想法。

那么还存在什么问题呢？整理下当前已知的问题：

1. 能通过MODBUS进行数据的存取，并且能够实现数据的初始化。
2. 验证分组正确存取。

## MODBUS读写

现在需要通过Qt5来对modbus进行读写。

### 1.通信基础

| 参数     | 说明         |
| -------- | ------------ |
| 协议     | Modbus RTU   |
| 波特率   | 9600 bps     |
| 数据位   | 8            |
| 停止位   | 2            |
| 校验位   | 无           |
| 从机地址 | 0xFF（广播） |

### 2.数据组织方式

每个电机的信息，由蓝牙盒子统一存储在连续的54个寄存器中，其中每个寄存器占用2个字节。每个电机的基地址计算方式：

```bash
电机基地址 = 0x0064 + 电机ID × 108
```

而寄存器的结构为：

| 偏移 | 字段                 | 类型     | 寄存器数 | 说明                  |
| ---- | -------------------- | -------- | -------- | --------------------- |
| 0x00 | id                   | short    | 1        | 电机编号              |
| 0x02 | name                 | char[8]  | 4        | 电机名称              |
| 0x0A | model                | char[64] | 32       | 电机型号              |
| 0x4A | modbusID             | short    | 1        | 电机从机地址          |
| 0x4C | groupID              | short    | 1        | 电机分组ID            |
| 0x4E | gearRatio            | short    | 1        | 齿轮传动比            |
| 0x50 | outsideDiameter      | float    | 2        | 外径(mm)              |
| 0x54 | screwPitch           | short    | 1        | 丝杆螺距(mm)          |
| 0x56 | clickDistance        | float    | 2        | 点动距离              |
| 0x5A | dir                  | short    | 1        | 方向(1正 -1反)        |
| 0x5C | isEnable             | short    | 1        | 是否启用(1启用 0禁用) |
| 0x5E | maxLimit             | short    | 1        | 最大限位              |
| 0x60 | minLimit             | short    | 1        | 最小限位              |
| 0x62 | specialLimit         | short    | 1        | 特殊限位起始值        |
| 0x64 | specialStop          | short    | 1        | 特殊限位结束值        |
| 0x66 | relativeZeroPosition | float    | 2        | 相对零点的绝对位置    |
| 0x6A | version              | short    | 1        | 结构体版本号          |

最终要转换为电机程序中的结构：

```c++
typedef struct __servoMotor_config__{
	int id;
	char name[8];
	char model[64];
	//char position[64]; // 通过ModbusID定义电机运动方向后，这个定义不在作为配置记录
	int modbusID;
	int groupID; // 组ID
	int gearRatio;
	float outsideDiameter;
	int screwPitch;
	//float speed;   //直接读取电机速度，如果电机速度丢失，则提示用户配置默认速度
	float clickDistance;
	//float currLocation;  // 去掉这个
	int dir;
	//char linkStat[8];   这个自行在上位软件处理，不传到小盒子内
	int isEnable; // 是否采用此电机
	int maxLimit;
	int minLimit;
	int specialLimit; //特殊限位起始，只记录限位值，具体逻辑由上层业务处理
	int specialStop; //特殊限位结束，只记录限位值，具体逻辑由上层业务处理
	float relativeZeroPosition; // 相对零点的绝对位置
	int version; // 电机信息版本
}T_servoMotor_config;
```

### 3.读取电机0的配置示例

```bash
读命令：
FF 03 00 64 00 36 91 DD 

回复：
FF 03 6C 00 02 00 01 00 08 00 09 00 02 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03 00 02 00 01 00 04 00 03 00 02 00 01 00 05 00 04 00 03 00 02 EF 1F 
```

但是读到的数据，需要按照每个字段所占空间和类型，转换为对应的结构`T_servoMotor_tb`才能使用。

同时，modbus蓝牙盒子只负责存储108个字节的数据，数据格式不关心。所以需要严格按照寄存器大小格式来实现这个读写功能。

请你依据以上逻辑，基于Qt5，实现这个通过MODBUS进行任意电机ID的配置读写控制。

## modbus读写差异

现在独立项目可以实现蓝牙盒子读写电机配置的功能。但是如何迁移到当前系统呢？趁此机会，学习下这个MODBUS读写逻辑。

### 1.电机配置信息的基地址

Modbus 的地址单位是“寄存器”，不是“字节”：

1. **电机配置总共占用了多少个寄存器？** 根据 `#define MOTOR_REGISTER_COUNT 54`，是一个电机配置占 **54 个寄存器**。
2. **下一个电机地址应该在哪里？** 应该从前一个电机配置结束后紧接着的下一个寄存器开始

地址每次 +1 跳过 1 个寄存器，不是 +2 字节。

所以要使用“54 寄存器”为步长

```bash
电机0：0x0064 + 0*54 = 0x0064
电机1：0x0064 + 1*54 = 0x009A
```

### 2.构造 Modbus 0x03 读保持寄存器请求帧

一个完整的 Modbus RTU 读请求帧结构如下：

| **字段**                      | **值 (ID=1)**         | **字节数** | **说明**       |
| ----------------------------- | --------------------- | ---------- | -------------- |
| 🚢 从机地址 ($\text{Addr}$)    | $0xFF$                | 1          | 广播地址       |
| ⚙️ 功能码 ($\text{Func}$)      | $0x03$                | 1          | 读保持寄存器   |
| 🏡 起始地址 ($\text{Start}$)   | $0x009\text{A}$ (154) | 2          | 高位在前       |
| 🔢 寄存器数量 ($\text{Count}$) | $0x0036$ (54)         | 2          | 高位在前       |
| ✅ CRC-16 校验码               | 自动计算              | 2          | 低位在前 (LRC) |
| **总长度**                    |                       | **8 字节** |                |

这个 8 字节的请求帧（由 `readHoldingRegisters` 函数内部的逻辑构造）会被发送到串口。

主站发出这个请求后，它期望收到一个 **成功的** Modbus RTU 响应帧，这个响应帧格式为

| **字段**                               | **值**              | **字节数**   | **说明**                                                  |
| -------------------------------------- | ------------------- | ------------ | --------------------------------------------------------- |
| 🚢 从机地址 ($\text{Addr}$)             | $0xFF$              | 1            | 广播地址                                                  |
| ⚙️ 功能码 ($\text{Func}$)               | $0x03$              | 1            | 读保持寄存器                                              |
| 🔢 **数据字节数** ($\text{Byte Count}$) | $0x6\text{C}$ (108) | 1            | $54 \text{ 个寄存器} \times 2 \text{ 字节}/\text{寄存器}$ |
| 🔢 **实际数据** ($\text{Data}$)         | 108 字节            | 108          | 54 个寄存器的原始数据                                     |
| ✅ CRC-16 校验码                        | 自动计算            | 2            | 低位在前 (LRC)                                            |
| **总长度**                             |                     | **113 字节** |                                                           |

总共113个字节。

# 11.27

当前已经验证，通过modbus来正常读写蓝牙盒子是正常的。但是现在存在的问题是，如何能利用项目中已经存在的逻辑来实现读写呢？

经过调试，发现是`read`逻辑存在问题。

# 11.28

周五了。今天任务就是找出为什么在`DbCtrl`中对蓝牙盒子进行蓝牙读写，会导致连接不上。

## 蓝牙连接流程

在main函数中，因为要通过读取数据库配置来确定使用何种方式连接，所以会进行初始化数据库的操作。示例代码：

```C++
DbCtrl::DbInit(0);

if (DbCtrl::m_systemInfo_tb.useBt && !initializeBluetoothConnection(a)) {
    QLOG_WARN() << "Main: 蓝牙连接初始化失败，应用程序将退出。";
    return -1; // 确保 main 函数也返回错误码
}
```

所以在数据库初始化完毕之前，不应该使用与modbusio通信相关的接口。

所以使用modbusio中的蓝牙进行读写的逻辑，应该放在初始化接口后再使用。

明确了这一点后，使用蓝牙来写modbusio的逻辑就通过了。下一步就是替换`T_servoMotor_tb`列表了。

## 替换`m_servoMotor_tb`来源

现在已经验证了蓝牙和串口来写MODBUS数据没什么问题了，那么下一步就需要将`initOrLoadServoMotors()`的逻辑，替换为使用modbus来实现。

### 当前`m_servoMotor_tb`的来源

是通过函数`initOrLoadServoMotors()`来实现的。首先是判断数据库是否存在此表，不存在则进行初始化流程`createAndInitServoMotorTable()`。

如果存在数据就将其加载到内存中。

### 现在`m_servoMotor_tb`的来源

现在依旧使用`initOrLoadServoMotors()`，但是内部逻辑需要修改：

1. 判断是否初始化：查询电机0的数据`readMotorConfig(0)`，获取`version`字段，判断是否为0。如果为0，则未初始化；为其他则已经初始化

2. 未初始化：调用`createAndInitServoMotorTable()`进行电机信息初始化，但是需要插入类似数据（以电机0为例）：

   ```C++
   typedef struct __servoMotor_config__{
   	int id = 1;
   	char name[8] = "A_X1";
   	char model[64] = "null";
   	int modbusID = 1;
   	int groupID = 0; // 组ID
   	int gearRatio = 10;
   	float outsideDiameter
   	int screwPitch;
   	//float speed;   //直接读取电机速度，如果电机速度丢失，则提示用户配置默认速度
   	float clickDistance;
   	//float currLocation;  // 去掉这个
   	int dir;
   	//char linkStat[8];   这个自行在上位软件处理，不传到小盒子内
   	int isEnable; // 是否采用此电机
   	int maxLimit;
   	int minLimit;
   	int specialLimit; //特殊限位起始，只记录限位值，具体逻辑由上层业务处理
   	int specialStop; //特殊限位结束，只记录限位值，具体逻辑由上层业务处理
   	float relativeZeroPosition; // 相对零点的绝对位置
   	int version; // 电机信息版本
   }T_servoMotor_config;
   ```

   其他数据与之前的`createAndInitServoMotorTable`初始化数据库逻辑相同。并且限位`maxLimit`和`minLimit`都设置为0，即不允许未配置限位进行使用。

   这里新增数据的方法，就是批量调用`MotorRegs`中的`verifyWriteRead()`函数。不过由于这7个电机写入和读出处理时间较长，需要等待一会实现。

我们将把原本基于 **SQLite数据库** 的电机参数管理（DAL层），重构为直接基于 **Modbus/蓝牙盒子** 的硬件参数管理。

以下是重构方案，主要涉及 `dbctrl.h` 和 `dbctrl.cpp`。

### 核心变更点：

1. **移除 SQL 依赖**：`initOrLoadServoMotors` 不再查询 `servoMotor_tb` 表。
2. **增加 硬件检测逻辑**：读取 Motor 0 的 `version` 字段来判断是否初始化。
3. **增加 硬件初始化逻辑**：替代原有的 `createAndInitServoMotorTable`，改为 `initRemoteMotorConfigs`，通过 Modbus 批量写入默认值。
4. **增加 内存映射逻辑**：将读取到的 `T_servoMotor_config` (硬件层结构) 转换为 `T_servoMotor_tb` (应用层结构)，以保证上层 UI 逻辑不需要修改。

同时还有结构体的修改：

由于 `T_servoMotor_tb` 中包含一些应用层所需的**状态和描述**字段（如 `position`, `speed`, `currLocation`, `linkStat`），而 `T_servoMotor_config` 原始定义中没有这些字段，我们必须采取一个折衷方案：

1. **修改 `MotorConfig.h`**：在 `T_servoMotor_config` 结构体尾部**添加**应用层所需的字段，但这些字段**不参与** Modbus 的读写操作。
2. **修改 `dbctrl.h` 和 `dbctrl.cpp`**：将 `m_servoMotor_tb` 和相关变量的类型改为 `T_servoMotor_config`，并更新 `initOrLoadServoMotors` 中的逻辑，**直接**填充 `T_servoMotor_config`。
3. **同时重构配置写入函数**：移除所有 SQL 语句，改为 Modbus 读写。

# 11.29

周六快乐)

今天继续昨天的移植。

## 替换数据库2

现在已经实现了启动的时候，从蓝牙盒子中获取电机配置信息的功能。但是在基础配置界面中，我们也需要将展示的信息重新读取到界面上。这次调整的重心是`Baseconfig`

## baseconfig对原有 SQLite 数据库电机配置信息的依赖关系

| **序号** | **依赖点 (代码逻辑)**         | **数据库/SQLite 依赖的体现**                                 | **切换到 Modbus 的影响和建议**                               |
| -------- | ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1**    | **配置表格模型** (最核心依赖) | `BaseConfig` 成员变量 `QSqlTableModel *m_tModel;` 和 `QTableView *m_tView;`。它使用 `QSqlTableModel` 直接与 `servoMotor_tb` 表绑定，实现数据的加载和编辑。 | **必须重构。** 远程 Modbus 数据无法使用 `QSqlTableModel`。您需要用 **自定义 Model** (如继承自 `QAbstractTableModel`) 来替换 `m_tModel`，新的 Model 通过 `DbCtrl` 的 getter/setter 间接读写 Modbus 数据。 |
| **2**    | **配置保存逻辑**              | 在 `on_save_bt_clicked()` 或类似函数中，调用 `m_tModel->submitAll()`。这会将表格视图中修改的数据一次性写入 SQLite 数据库。 | **必须移除。** Modbus 写入需要针对每个修改的字段调用 `DbCtrl` 中新的 Modbus 写入函数（例如 `DbCtrl::setClickDist(motorID, dist)`）。新的保存逻辑将是：遍历表格 -> 获取修改值 -> 调用 Modbus 写入函数。 |
| **3**    | **配置加载/同步**             | `on_save_bt_clicked()` 成功后，调用 `DbCtrl::DbInit(true);` 来重新加载数据库到内存，以更新缓存。 | **可以保留或简化。** 既然 `DbCtrl::DbInit` 现在是 Modbus-aware 的，它的作用是重新从硬件加载配置并更新内存，理论上可以保留。但如果采用自定义 Model，Model 在写入成功后应自行更新内存。 |
| **4**    | **其他配置应用**              | 在 `on_save_bt_clicked()` 中，读取 `DbCtrl::m_servoMotor_tb.at(i).speed` 和 `.gearRatio` 等字段，然后调用 `setServoSpeed` 等函数将速度配置写入硬件寄存器。 | **保持不变。** 这一步读取的是内存中的 `DbCtrl::m_servoMotor_tb`，由于您前几步已经将 `DbCtrl` 的加载逻辑改为 Modbus，只要内存数据是正确的，这段逻辑就不需要修改。 |

在 `BaseConfig` 中主要需要完成以下两大步骤来切换依赖：

1. **废弃 `QSqlTableModel`：** 移除 `m_tModel` 和 `m_tView` 的所有数据库绑定逻辑。
2. **创建自定义表格模型：** 实现一个新的 Model，该 Model 负责：
   - **读数据：** 从 `DbCtrl::m_servoMotor_tb` 读取数据，展示在表格中。
   - **写数据：** 在 `on_save_bt_clicked()` 中，遍历 Model 数据，调用 Modbus 写入函数（如 `DbCtrl::setClickDist`、`DbCtrl::setMotorEnableState` 等）将更改写入蓝牙盒子。

这是架构上最大的挑战，因为它要求用 Qt 自定义数据模型的方案来替换 Qt 提供的 SQL 模型方案。

并且还有一个问题，就是写的时候，需要统一调用`MotorRegs`的`writeMotorConfig()`方法，并不能单独读写蓝牙盒子的配置。

核心目标是：

1. **移除** `QSqlTableModel` 和 `QTableView` 的数据库依赖。
2. **创建**一个自定义的数据模型 (`BaseConfigTableModel`) 来显示和编辑电机配置。
3. **修改**保存逻辑 (`on_save_bt_clicked`)，使其通过 **`MotorRegs::writeMotorConfig()`** 一次性写入完整的配置结构体，而不是单独写入字段。

不过在重构之前，应该需要先将baseconfig中的逻辑理解清楚。

## baseconfig逻辑

