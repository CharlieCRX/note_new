# 12.1

## 分组机制

当前需要加入分组。

电机分组逻辑在`GroupManager`中。每个分组有固定的几个电机：

```c++
    M_X1
    M_X2,
    M_Y1,
    M_Z1,
    M_Angle,
    M_Z2,
```

但是之前的逻辑中，并没有分组的概念，所以之前电机信息的初始化、加载等是通过

```C++
int DbCtrl::initOrLoadServoMotors(QSqlDatabase &db);

int DbCtrl::initRemoteMotorConfigs();
```

但是现在由于加入了分组。第一组的下标就是0-5，但是第二组的下标就是10-15（以此类推）。

因为要遵循结构不变动：

```C++
QVector<T_servoMotor_config> DbCtrl::m_servoMotor_tb;
```

所以这样的索引，就会导致初始化的时候，需要加入空数据来填充。请你依据这个分组思想，加入第二组（前缀B）电机：

```C++
B_X1
B_X2
B_Y1
B_Z1
B_Angle
B_Z2
```

那么第一组前缀就是以`A_`开头。

请你依据此思想，首先加入第二组电机的初始化以及读取逻辑。并且完美适配`m_servoMotor_tb`。另外，需要做两件事：

1. **过滤无效数据**：在 `loadMotorData` 中，跳过那些为了占位而存在的空数据（即 GroupManager 分组机制产生的中间空洞）。
2. **增量保存（脏数据检查）**：利用 Qt Model/View 的特性，在编辑时标记“脏数据”（Dirty Flag），保存时只处理被标记的行。

分组机制加完了，现在需要做的是，在界面中加入分组逻辑。

## 切换分组

等了好久，终于将基础工作做完，然后就是处理这个界面切换分组的逻辑了。

现在要在界面中加入一个下拉框，可以切换电机组。

电机组`GroupManager`在main函数中首先设置了默认分组为0。随后`MotorCtrl`类就在调用获取`motoeID`的时候，就会使用到组ID来实现基础的思路。

现在需要在`MotorCtrl`的界面中，加入一个下拉框，可以切换电机组（机组0、1）。其属性为：

- 放在界面下方
- 展示机组0、1

为了实现这个功能，我们需要修改以下文件：

1. **`motorCtrl.h`**: 声明新的 `QComboBox` 成员变量和用于处理组切换的槽函数。
2. **`MotorCtrl.cpp`**:
   - 在布局设置函数 (`UI_setupLayouts`) 中创建 `QComboBox`，配置其选项（机组0, 机组1），并将其添加到界面的下方布局中。
   - 连接 `QComboBox` 的 `currentIndexChanged` 信号到新的槽函数。
   - 实现新的槽函数，用于调用 `GroupManager::setCurrentGroup()` 来切换当前的电机组。

# 12.2

## bug修改

现在已经将测试环境搭好了，在测试的时候，发现的问题记录。

现在存在两个伺服控制器，并且一个modbus从地址改为了5（对应的是`A_Angle`的MODBUS地址）；

另一个modbus从地址改为了15（对应的是`B_Angle`的MODBUS地址）

然后进入设置界面后，进行通讯测试（函数`on_connect_test_clicked()`），发现`A_Angle`是在服的，但是`B_Angle`不在服，反而是`B_Z2`在服了。

# 12.3

今天任务就是：

1. 解决电机初始化的逻辑
2. 让`B_Angle`电机正常旋转
3. 解决配置速度慢的问题

# 12.4

已经解决了旋转轴的位置移动问题，但是现在点动是存在问题的。

## 点动逻辑

现在需要调试点动逻辑。为了方便调试，需要将首先需要将点动按钮展示出来。在函数`UI_setupRunConfigPanel()`中修改。

好的，现在已知的是，B组旋转电机，点动逻辑有问题。

好的，现在已经将点动运动检测，加入了第二组电机的支持。现在正常了。

## 电机信息初始化逻辑

现在电机初始化逻辑是：

1. 读取蓝牙盒子信息
2. 如果信息不存在，那就进行初始化流程

但是信息不存在有两个场景:

1. 接口通，但是确实不存在数据
2. 接口不通

那么需要将初始化逻辑，放在仅在接口通但是确实不存在数据的时候，才能初始化。

## 双电机逻辑

先解决双电机点动经常错误的问题吧。X1X2当前的点动问题：

1. 发完广播后，写错误

   ```bash
   [modbusbt.cpp:418 virtual bool ModbusBt::write(int, ModbusIO::RegisterType, int, QVector<quint16> &)] ModbusBt::write - 蓝牙发送广播数据成功！ 
   [motorregs.cpp:152 bool MotorRegs::writeReg16(qint32, quint32, quint16)] "电机-1写入成功,16(53,0)" 
   [motorCtrl.cpp:2059 bool MotorCtrl::jogStop(int)] 双电机确保安全，再手动停止X1、X2使能 
   [modbusbt.cpp:452 virtual bool ModbusBt::write(int, ModbusIO::RegisterType, int, QVector<quint16> &)] "ModbusBt::write - 蓝牙写请求发送成功，但未收到回应." 
   [motorregs.cpp:150 bool MotorRegs::writeReg16(qint32, quint32, quint16)] "电机0写入失败,16(53,0)" 
   [motorregs.cpp:152 bool MotorRegs::writeReg16(qint32, quint32, quint16)] "电机1写入成功,16(53,0)" 
   [motorCtrl.cpp:2063 bool MotorCtrl::jogStop(int)] "MotorCtrl::jogStop - 电机[X1X2]伺服使能已断开" 
   ```

2. 某些场景下，点动响应较慢（依旧是发送广播后的读取失败）

   ```bash
   INFO  2025-12-04T18:36:21.940 [modbusbt.cpp:418 virtual bool ModbusBt::write(int, ModbusIO::RegisterType, int, QVector<quint16> &)] ModbusBt::write - 蓝牙发送广播数据成功！ 
   INFO  2025-12-04T18:36:21.940 [motorregs.cpp:152 bool MotorRegs::writeReg16(qint32, quint32, quint16)] "电机-1写入成功,16(277,0)" 
   INFO  2025-12-04T18:36:21.940 [motorCtrl.cpp:2252 bool MotorCtrl::clearBrakeDOConfig(int)] "成功屏蔽[全部]电机DO刹车功能！" 
   
   ----------------------- 这5秒时间，是读取但是未响应的时间
   ERROR 2025-12-04T18:36:27.034 [modbusbt.cpp:452 virtual bool ModbusBt::write(int, ModbusIO::RegisterType, int, QVector<quint16> &)] "ModbusBt::write - 蓝牙写请求发送成功，但未收到回应." 
   ERROR 2025-12-04T18:36:27.034 [motorregs.cpp:150 bool MotorRegs::writeReg16(qint32, quint32, quint16)] "电机0写入失败,16(277,8)" 
   ERROR 2025-12-04T18:36:27.034 [motorCtrl.cpp:2263 bool MotorCtrl::restoreBrakeDOConfig(int)] "配置[A_X1]电机DO刹车功能失败！" 
   ```

   # 12.5
   
   ## 点动的优化逻辑
   
   - X1X2位置超差在点动之前检测
   
   重构
   
   ```C++
   void MotorCtrl::actionJog(int dir)
   {
       if (!canStartJog()) return;
   
       // 获取电机ID
       int motorID = getMotorID();
       m_jog_done = false;
       m_allDone = false;
   
       disableAllbt(dir);
       logJogStart(motorID, dir);
   
       // 预启动电机
       if (!applyJogConfig(motorID, dir)) return;
       if (!isPositionWithinLimit(motorID, dir)) return;
   
       // 点动控制伺服使能
       enableJogServo(motorID, dir);
   
       m_jog_dir = dir;
       m_checkWoker = new QThread;
       connect(m_checkWoker, &QThread::started, this, &MotorCtrl::checkJog);
       connect(m_checkWoker, &QThread::finished, this, &MotorCtrl::on_threadFinished);
       m_checkWoker->start();
   }
   ```
   
   将其中的关于点动配置相关的，都抽象为一个函数`canStartJog()`。其中主要逻辑包括：
   
   1. 双电机场景：判断速度、位置是否一致

## 刷新位置数据

能否在`getlocation()`完毕后发送信号给`refreshRealLoc()`自动将位置信息展示在界面上

# 12.6

今天任务就是最终任务，将B组的双电机运行起来。

## 双电机展示逻辑

`on_funSl_changed()`函数中，关于双电机的判断和展示逻辑。

## 界面调整

本次界面调整包括：

1. 取消主界面的图片展示
2. 取消配置界面的图片展示
3. 将位置显示和电机组下拉框放在合适的位置



# 12.8

现在要加入绝对位置系统。

## 绝对位置系统

绝对位置系统与**上下限位**和**绝对位置零点**是有关系的。

- 在配置绝对位置系统时，首先调用函数`setOriginCore()`，对电机的绝对位置脉冲位置清零（一般是水平面或者固定其开始的位置）
- 以此基础上，配置上下限位，绝对零点（初始时为0）以及特殊位置限位

引入了绝对位置系统后，之前的位置展示`getLocation()`逻辑依然不变，依旧是获取电机的绝对位置脉冲。此时，绝对位置零点和相对位置零点都是0

### 相对位置清零操作

用户后续根据业务需要，可以自行调整相对位置零点。其步骤和原理如下（假设已经做完绝对位置初始化，上下限位为1000cm）：

1. 将电机移动到合适位置，假设为距离**绝对零点**的200cm处
2. 此时用户点击**相对位置清零**按钮，此时相对零点的位置 200 cm（字段`relativeZeroPosition`）会被记录到内存和蓝牙盒子中。
3. 相对位置信息刷新：更新当前电机的相对位置为 0 cm（绝对位置 200cm - 相对零点位置 200 cm）
4. 相对限位处理：加入相对零点后，其相对的上限位就变为了 1000 - 200 = 800 cm；下限位变为了 -1000 - 200 = -1200 cm

### 相对位置展示

用户界面展示的应为基于相对零点的位置系统。所以界面展示电机位置信息的时候，需要：

1. 获取电机的绝对位置
2. 用绝对位置减去**相对零点**的在绝对位置系统的位置，就是电机的相对位置

那么另一个用到的就是相对限位。电机在点动和位置移动的时候，需要时刻检测当前位置是否超出限位（相对和绝对位置都需要检测）

## 要修改的地方

### 配置界面的绝对位置系统

需要加入的是：

- 设置绝对位置原点按钮

### 用户界面的相对位置系统

- 设置相对位置零点按钮
  - 记录当前相对零点的位置到内存结构和存储中
- 相对限位更新，超出限位提示超出相对位置限位
- 位置系统需要 - 相对零点

# 12.14

今天的任务就是调试B组电机，看看有哪些问题。

## 1.速度设置失败问题

在B组双电机设置速度设置的时候，报错速度设置失败。

```bash
INFO  2025-12-14T09:52:43.533 [baseconfig.cpp:983 static bool BaseConfig::setServoSpeedRpm(int, quint16)] "设置电机[B_X1]位置速度 (130)RPM 开始..." 
ERROR 2025-12-14T09:52:44.011 [modbusbt.cpp:465 virtual bool ModbusBt::write(int, ModbusIO::RegisterType, int, QVector<quint16> &)] "ModbusBt::write - 蓝牙写请求发送成功，但未收到回应." 
```

修改方案：

在`setServoSpeedRpm()`中加入三次写操作。

## 2.获取信息失败

读取速度和位置，均设置3次

## 3.运动过程中展示位置信息错误

### 3.1 问题描述

- 旋转电机在点动的时候，位置展示总会固定出现一个355左右的度数。
- X1X2点动的时候，位置展示也会出现一个固定的值

### 3.2 日志记录

```bash
INFO  2025-12-14T12:17:35.668 [motorCtrl.cpp:859 QString MotorCtrl::getDistShowVal(qint32)] "最终展示的相对位置为349.733" 
INFO  2025-12-14T12:17:35.668 [motorCtrl.cpp:1803 bool MotorCtrl::isX1X2NotSync()] "-----> 开始检查X1、X2是否同步 <------" 
INFO  2025-12-14T12:17:35.718 [motorCtrl.cpp:1822 bool MotorCtrl::isX1X2NotSync()] "电机B_X1读取当前位置成功，pulse=-273781" 
INFO  2025-12-14T12:17:35.772 [motorCtrl.cpp:1849 bool MotorCtrl::isX1X2NotSync()] "电机B_X2读取当前位置成功，pulse=271660" 
INFO  2025-12-14T12:17:35.772 [motorCtrl.cpp:1874 bool MotorCtrl::isX1X2NotSync()] "绝对位置脉冲数 : 电机[B_X1] = (-273781)pulse, 电机[B_X2] = (-271660)pulse" 
INFO  2025-12-14T12:17:35.772 [motorCtrl.cpp:1880 bool MotorCtrl::isX1X2NotSync()] "X1、X2位置差值: (2.71469)mm" 
INFO  2025-12-14T12:17:35.773 [motorCtrl.cpp:1886 bool MotorCtrl::isX1X2NotSync()] "-----> TRUE: X1、X2电机位置同步 <------" 
INFO  2025-12-14T12:17:35.773 [motorCtrl.cpp:2071 void MotorCtrl::checkJog()] "判断点动的电机[B_Angle]是否超出限位" 
INFO  2025-12-14T12:17:35.821 [motorCtrl.cpp:741 float MotorCtrl::getLocation(int)] "getLocation: 电机[B_Angle] 第 1 次尝试读取成功。" 
INFO  2025-12-14T12:17:35.821 [motorCtrl.cpp:757 float MotorCtrl::getLocation(int)] "getLocation: 电机[B_Angle]当前的绝对位置脉冲数为(-2034096)pulse" 
INFO  2025-12-14T12:17:35.821 [motorCtrl.cpp:763 float MotorCtrl::getLocation(int)] "getLocation: 旋转电机[B_Angle]当前角度为 (558.681) ° " 
INFO  2025-12-14T12:17:35.821 [motorCtrl.cpp:2083 void MotorCtrl::checkJog()] 刷新位置展示数据 
INFO  2025-12-14T12:17:35.821 [motorCtrl.cpp:850 QString MotorCtrl::getDistShowVal(qint32)] 电机相对位置信息展示 
INFO  2025-12-14T12:17:35.873 [motorCtrl.cpp:741 float MotorCtrl::getLocation(int)] "getLocation: 电机[B_Angle] 第 1 次尝试读取成功。" 
INFO  2025-12-14T12:17:35.874 [motorCtrl.cpp:757 float MotorCtrl::getLocation(int)] "getLocation: 电机[B_Angle]当前的绝对位置脉冲数为(-2034096)pulse" 
INFO  2025-12-14T12:17:35.874 [motorCtrl.cpp:763 float MotorCtrl::getLocation(int)] "getLocation: 旋转电机[B_Angle]当前角度为 (558.681) ° " 
INFO  2025-12-14T12:17:35.874 [motorCtrl.cpp:853 QString MotorCtrl::getDistShowVal(qint32)] "[B_Angle]电机绝对位置为558.681" 
INFO  2025-12-14T12:17:35.874 [motorCtrl.cpp:856 QString MotorCtrl::getDistShowVal(qint32)] "[B_Angle]电机的相对零点位置为[0]" 
INFO  2025-12-14T12:17:35.874 [motorCtrl.cpp:859 QString MotorCtrl::getDistShowVal(qint32)] "最终展示的相对位置为558.681" 
```

### 3.3问题解决

因为在点动结束的时候，并没有将B_Angle的电机检测关闭，所以导致在X1X2前进的时候，还会检测旋转轴电机。

## 4.X1X2电机停止后一直使能

### 4.1问题描述

X1X2前进完成后，一直使能，电机有电流声。

可惜的是日志没记录，也没复现。

## 5.设置B_Z1速度失败

### 5.1问题描述

设置B组Z1的时候，获取速度总失败，并且设置速度也总是失败。

### 5.2日志记录

```bash
MotorRegs::verifyWriteRead -- 尝试 1 成功！写入和读回的电机配置完全一致。" 
INFO  2025-12-14T12:47:39.280 [baseconfig.cpp:734 void BaseConfig::on_tViewClicked()] "电机配置写入硬件成功: Index=13, ModbusID=14" 
INFO  2025-12-14T12:47:39.926 [joystickcontrollermanager.cpp:54 void JoystickControllerManager::enable()] JoystickController ➔ 摇杆保持禁用状态 (计数:  1 ) 
INFO  2025-12-14T12:47:42.440 [baseconfig.cpp:1310 void BaseConfig::on_cancel_clicked()] on_cancel_clicked : 开始处理取消操作... 
INFO  2025-12-14T12:47:42.511 [baseconfig.cpp:1328 void BaseConfig::on_cancel_clicked()] BaseConfig: '返回'按钮被点击，发出 dialogClosed 信号。 
ERROR 2025-12-14T12:47:45.041 [modbusbt.cpp:597 virtual bool ModbusBt::read(int, ModbusIO::RegisterType, int, int, QVector<quint16> &)] "ModbusBt::read - 蓝牙读请求发送成功，但未收到回应" 
ERROR 2025-12-14T12:47:45.042 [baseconfig.cpp:1066 static int BaseConfig::getServoSpeedRpm(int)] "电机B_Z1读取点动速度失败，第1次尝试" 
ERROR 2025-12-14T12:47:45.518 [modbusbt.cpp:597 virtual bool ModbusBt::read(int, ModbusIO::RegisterType, int, int, QVector<quint16> &)] "ModbusBt::read - 蓝牙读请求发送成功，但未收到回应" 
ERROR 2025-12-14T12:47:45.518 [baseconfig.cpp:1066 static int BaseConfig::getServoSpeedRpm(int)] "电机B_Z1读取点动速度失败，第2次尝试" 
ERROR 2025-12-14T12:47:45.801 [modbusbt.cpp:510 void ModbusBt::praseMdbmsg(int, quint16, const QByteArray &, QVector<quint16> &)] "报文总长度错误，期望7字节，实际14字节" 
INFO  2025-12-14T12:47:45.801 [baseconfig.cpp:1060 static int BaseConfig::getServoSpeedRpm(int)] "电机B_Z1读取点动速度成功，RPM=0" 
INFO  2025-12-14T12:47:45.804 [baseconfig.cpp:1085 static int BaseConfig::getServoSpeedRpm(int)] "电机B_Z1读取位置移动速度成功，RPM=434" 
ERROR 2025-12-14T12:47:45.804 [baseconfig.cpp:1108 static int BaseConfig::getServoSpeedRpm(int)] "电机B_Z1点动速度和位置速度不一致，Jog=0，Pos=434" 
INFO  2025-12-14T12:47:47.109 [joystickcontrollermanager.cpp:54 void JoystickControllerManager::enable()] JoystickController ➔ 摇杆保持禁用状态 (计数:  1 ) 
ERROR 2025-12-14T12:47:49.381 [modbusbt.cpp:510 void ModbusBt::praseMdbmsg(int, quint16, const QByteArray &, QVector<quint16> &)] "报文总长度错误，期望7字节，实际14字节" 
INFO  2025-12-14T12:47:49.381 [baseconfig.cpp:1060 static int BaseConfig::getServoSpeedRpm(int)] "电机B_Z1读取点动速度成功，RPM=0" 
INFO  2025-12-14T12:47:49.439 [baseconfig.cpp:1085 static int BaseConfig::getServoSpeedRpm(int)] "电机B_Z1读取位置移动速度成功，RPM=434" 
ERROR 2025-12-14T12:47:49.439 [baseconfig.cpp:1108 static int BaseConfig::getServoSpeedRpm(int)] "电机B_Z1点动速度和位置速度不一致，Jog=0，Pos=434" 
INFO  2025-12-14T12:47:50.124 [joystickcontrollermanager.cpp:54 void JoystickControllerManager::enable()] JoystickController ➔ 摇杆保持禁用状态 (计数:  1 ) 
INFO  2025-12-14T12:47:52.718 [baseconfig.cpp:1060 static int BaseConfig::getServoSpeedRpm(int)] "电机B_Z1读取点动速度成功，RPM=434" 
INFO  2025-12-14T12:47:52.769 [baseconfig.cpp:1085 static int BaseConfig::getServoSpeedRpm(int)] "电机B_Z1读取位置移动速度成功，RPM=434" 
INFO  2025-12-14T12:47:57.684 [baseconfig.cpp:965 static bool BaseConfig::setServoSpeed(int, float)] "正在修改电机[B_Z1]，motorID = [13]的电机速度" 
INFO  2025-12-14T12:47:57.684 [baseconfig.cpp:986 static bool BaseConfig::setServoSpeedRpm(int, quint16)] "设置电机[B_Z1]位置速度 (87)RPM 开始..." 
ERROR 2025-12-14T12:47:58.211 [modbusbt.cpp:465 virtual bool ModbusBt::write(int, ModbusIO::RegisterType, int, QVector<quint16> &)] "ModbusBt::write - 蓝牙写请求发送成功，但未收到回应." 
ERROR 2025-12-14T12:47:58.211 [motorregs.cpp:150 bool MotorRegs::writeReg16(qint32, quint32, quint16)] "电机13写入失败,16(516,87)" 
ERROR 2025-12-14T12:47:58.211 [baseconfig.cpp:999 static bool BaseConfig::setServoSpeedRpm(int, quint16)] "电机B_Z1设置位置速度失败，RPM=87，第1次尝试" 
INFO  2025-12-14T12:47:58.634 [motorregs.cpp:152 bool MotorRegs::writeReg16(qint32, quint32, quint16)] "电机13写入成功,16(516,87)" 
INFO  2025-12-14T12:47:58.634 [baseconfig.cpp:993 static bool BaseConfig::setServoSpeedRpm(int, quint16)] "电机B_Z1设置位置速度成功，RPM=87" 
INFO  2025-12-14T12:47:58.634 [baseconfig.cpp:1017 static bool BaseConfig::setServoSpeedRpm(int, quint16)] "设置电机[B_Z1]点动速度 (87)RPM 开始..." 
ERROR 2025-12-14T12:47:59.160 [modbusbt.cpp:465 virtual bool ModbusBt::write(int, ModbusIO::RegisterType, int, QVector<quint16> &)] "ModbusBt::write - 蓝牙写请求发送成功，但未收到回应." 
ERROR 2025-12-14T12:47:59.160 [motorregs.cpp:150 bool MotorRegs::writeReg16(qint32, quint32, quint16)] "电机13写入失败,16(21,87)" 
ERROR 2025-12-14T12:47:59.161 [baseconfig.cpp:1030 static bool BaseConfig::setServoSpeedRpm(int, quint16)] "电机B_Z1设置点动速度失败，RPM=87，第1次尝试" 
INFO  2025-12-14T12:47:59.267 [motorregs.cpp:152 bool MotorRegs::writeReg16(qint32, quint32, quint16)] "电机13写入成功,16(21,87)" 
INFO  2025-12-14T12:47:59.268 [baseconfig.cpp:1024 static bool BaseConfig::setServoSpeedRpm(int, quint16)] "电机B_Z1设置点动速度成功，RPM=87" 
INFO  2025-12-14T12:47:59.268 [motorCtrl.cpp:1177 bool MotorCtrl::netSetSpeed(int, float)] "电机[B_Z1]设置位置速度成功，转速为 (20) " 
```

遗憾的是，无法复现这个问题。

## 设置外径

> **外径与位移是严格成比例的**

只需要：

$\boxed{ D_{\text{真实}} = D_{\text{当前}} \times \frac{\text{实际位移}}{\text{期望位移}} }$

# 12.15

## DI逻辑

因为要经常与P100S的 P3-30 和 P3-31寄存器打交道，所以这里理解下其逻辑。

### P3-30

此参数决定了 P100S 电机的 DI 分配给了哪些接口。

在`servo`系统中，`P3-30`的值为2，这表示伺服可以通过模拟的数字 DI1~8 来控制。并且DI 1~8的功能是由寄存器：

- P3-38~P3-45这 8 个寄存器决定的

```C++
    m_p100scfgs.append(qMakePair(MotorRegs::P3_38, 28));
    m_p100scfgs.append(qMakePair(MotorRegs::P3_39, 16));
    m_p100scfgs.append(qMakePair(MotorRegs::P3_40, 22));
    m_p100scfgs.append(qMakePair(MotorRegs::P3_41, 23));
    m_p100scfgs.append(qMakePair(MotorRegs::P3_42, 27));
```

对应的功能为：

P3-38到P3-45对应的分别是DI1和DI8的功能。

- P3-38 = 28。DI1 设置`CTRG`，内部位置命令触发。是触发位置运动的功能。

  > 在内部位置寄存器模式时，选择内部位置寄存器控制命令（POS0-2）后，此信号触发，电机根据内部位置寄存器命令运转。当数字输出零速度信号（ZSPD=1）后，才接受下一次触发内部位置命令

- P3-39 = 16.DI2 设置`CMODE`，复合模式控制模式设定。这里PA4为3，所以仅看（1）即可。

  > 当 PA-4 设置为 3，4，5 时，处于混合控制模式，可通过此输入端子可切换控制模式：
  > (1)PA-4 为 3 时,CMODE OFF，为位置模式；CMODE ON，则为速度模式；（之前就设置的值为3）
  > (2)PA-4 为 4 时,CMODE OFF，为位置模式；CMODE ON，则为转矩模式；
  > (3)PA-4 为 5 时,CMODE OFF，为速度模式；CMODE ON，则为转矩模式

- P3-40 = 22.DI3 设置`JOGP`，正向点动。

  > 速度模式下，PA22=5 时，此信号接通，电机正方向寸动，点动速度受 PA21 设置。
  > 注意：此信号跟反向寸动同时接通，寸动功能无效。

- P3-41 = 23.DI4设置`JOGN`，反向点动。

  > 速度模式下，PA22=5 时，此信号接通，电机反方向寸动，点动速度受 PA21 设置。
  > 注意：此信号跟反向寸动同时接通，寸动功能无效。

- P3-42 = 27. DI5 设置`HOLD`，内部位置控制命令停止。是位置移动的紧急停止信号。

  > 在内部位置寄存器模式时，此信号接通，电机将停止运转

### P3-31

`P3-31`模拟的就是 DI1-8的具体值。

## 1.B组电机运动时，A组电机移动

### 1.1 问题描述

B组双电机在点动的时候，又出现了A组电机运动的问题。

# 12.17

## 摇杆逻辑问题

### 1. 问题描述

在点动开始后，快速松开摇杆然后再推上去，此时弹窗提示点动仍在运行，并且松开摇杆后，点动依旧运行。

### 2. 根本问题分析：点动停止的异步性

| **函数/变量**                            | **作用**     | **当前实现的问题**                                           |
| ---------------------------------------- | ------------ | ------------------------------------------------------------ |
| **`on_actionUpRightFrontBt_released()`** | 摇杆松开事件 | **只设置 `m_allDone = true;`**                               |
| **`m_allDone`**                          | 停止信号标志 | 控制 `checkJog` 线程的 `do/while` 循环。                     |
| **`checkJog()`**                         | 运动监控线程 | **异步停止**：循环退出后才调用 `actionJogStop()`。           |
| **`m_jog_done`**                         | 状态锁       | 在 `actionJog()` 中被设置为 `false`，在 `checkJog()` 退出时（通过 `em_jogDone(true)` 或 `on_threadFinished`）被设置为 `true`。 |

### 3. 导致错误的流程：

1. **用户推摇杆：** $\rightarrow$ `on_actionUpRightFrontBt_pressed()` $\rightarrow$ `actionJog()` $\rightarrow$ `m_jog_done = false` $\rightarrow$ 启动 `checkJog` 线程。
2. **用户快速松开摇杆：** $\rightarrow$ `on_actionUpRightFrontBt_released()` $\rightarrow$ **`m_allDone = true;`**。
3. **系统状态（第一次错误）：**
   - `checkJog` 线程中的 `do/while(!m_allDone)` 循环检测到 `m_allDone` 为 `true`。
   - **关键：** 线程需要 `msleep(100)`，然后退出 `do/while` 循环。
   - 在这 **100 毫秒的延迟** 加上 CPU 调度时间后，线程才会执行循环外的 `actionJogStop()`。
   - **松开摇杆后，电机仍在运行** (直到 `actionJogStop` 执行)。
4. **用户在电机未停止时快速再推摇杆：** $\rightarrow$ 再次调用 `on_actionUpRightFrontBt_pressed()` $\rightarrow$ 尝试调用 `canStartJog()`。
5. **系统状态（第二次错误）：**
   - `canStartJog()` 检查 `if (!m_jog_done)`。
   - 由于 `m_jog_done` 要等到 `checkJog` 线程完全退出（并触发 `on_threadFinished` 或 `em_jogDone` $\rightarrow$ 连接的槽函数）后才会被重置为 `true`，此时它仍然是 `false`。
   - $\rightarrow$ `canStartJog` 返回 `false` 并可能**弹出提示**："请等待上次点动完全停止"。
   - **弹窗出现，但电机仍然在运行** (因为它还没走到 `actionJogStop`)。

## 错误流程

流程如下：

1. **第一次点动开始：** `on_action...pressed()` $\rightarrow$ `actionJog()` $\rightarrow$ **`m_jog_done = false;`**，`checkJog` 线程启动。
2. **用户松开摇杆：** `on_action...released()` $\rightarrow$ **`m_allDone = true;`**。
3. **用户立即推动摇杆（太快）：** $\rightarrow$ 第二次调用 `on_action...pressed()`。
   - 此时 `checkJog` 线程还未捕捉到 `m_allDone = true`，且 `m_jog_done` 仍为 `false`。
   - **`canStartJog` 拒绝第二次点动**，并可能弹出警告。
   - **关键错误点：** 第二次 `on_action...pressed()` 中的 `m_allDone = false;` 被执行了。

当第二次点动尝试快速发生时：

1. 第一次点动的 `checkJog` 线程还在循环中，正要退出，它依赖于 `m_allDone = true` 来停止。
2. 第二次 `on_action...pressed()` 启动，它**无条件地执行了 `m_allDone = false;`**。
3. 第一次点动的 `checkJog` 线程现在永远也看不到 `m_allDone = true` 了，它会卡死在 `do/while(!m_allDone)` 循环中，**点动永远不会停止！**

### 保护 `m_allDone` 的重置

`m_allDone = false` 只有在**确定可以开始一次全新的点动**时，才应该被设置。

**【修改位置 A】：`on_actionUpRightFrontBt_pressed()`**

将 `m_allDone = false` 移到 `actionJog()` 内部，并仅在 `canStartJog` 检查通过后执行。



## 错误点动失效2

1. **不要在 `actionJog` 里面写 `m_allDone = false`**（这是你当前问题的死穴）。
2. **按下即锁定**：按下按钮后，在代码逻辑层面立刻置 `m_jog_done = false`，禁止后续任何新的点动请求进入，直到当前流程结束。
3. **UI反馈**：可以把按钮设置为“按下”状态的视觉效果，但在逻辑未完成前，不接受第二次 `pressed` 信号

# 12.18

## 12.18工作记录

客户上午过来初步检查行车运行系统，针对当前运行情况，提出了以下要求：

1. 提供行车运行精度校验方法手册，方便客户验证是否行车运行精度是否达标（验收难点）。手册需要提供：
   - 验证安装是否符合标准的方法
   - 验证运行精度是否达标的方法
2. 提供标准的绝对零点的位置（锚定伺服控制器中绝对零点对应现实的机械0点位置，方便客户测量累计的物理偏差）
3. 提供**自动** 绝对位置 归零方法（出现了机械绝对零点和软件绝对零点不一致后，方便一键绝对位置回零）
4. 要求行车运行能够自动避让 特殊位置 （例如通风管道以及其他线路）
5. 提供电机控制软件的使用手册

# 12.22

欢迎回到南京。

## 接近传感器

### NPN NO 传感器的工作原理

 **M18KN12W** 是一款 NPN 常开型传感器：

- **平时（未感应）**：黑线（输出端）处于悬空状态（高阻态），不导通。
- **动作（感应到金属）**：黑线与蓝线（0V/GND）内部接通。此时，黑线会输出一个**低电平信号（0V）**。

### DI 口的配置选择：3 还是 103？

这取决于伺服驱动器对“限位有效”的定义。在 P100S 驱动器中：

- **设置为 3 (CCW 驱动禁止)**：
  - **逻辑**：低电平（接通 0V）有效。
  - **现象**：平时不报 Err 7，但**一旦传感器感应到金属（输出 0V），驱动器立刻报限位停止**。
  - **缺点**：不防断线。如果限位传感器的电源线断了，传感器永远无法输出信号，电机会撞坏机械结构。
- **设置为 103 (常闭 CCW 驱动禁止)**：
  - **逻辑**：高电平（断开）有效。
  - **现象**：由于您的传感器是 NO（常开），平时不感应时就是断开的。**驱动器一开机检测到断开，立刻认为撞了限位，报错 Err 7**。
  - **优点**：符合安全标准（Fail-safe）。如果线断了，机器会报错停机，保护设备。

#### 选择建议

**方案 A（最简单，直接配合您的传感器）**：设置 **P3-00 = 3**。

- 这样传感器感应到金属时（常开点闭合），电机停止。平时不报错。

**方案 B（最安全，但需更换传感器）**：设置 **P3-00 = 103**，并更换传感器为 **NPN NC（常闭）** 型。

- 这样平时传感器一直给驱动器信号，一旦撞限位或断线，信号消失，驱动器报警停止。

### 设置 DI1、2

现在已经通过代码将两个物理输入端子设置为了：

- DI1：正转驱动禁止
- DI2：反转驱动禁止

```C++
    // 测试物理 DI1-2 能否控制限位转动
    m_p100scfgs.append(qMakePair(MotorRegs::PA20, 0));
    m_p100scfgs.append(qMakePair(MotorRegs::P3_00, 3));
    m_p100scfgs.append(qMakePair(MotorRegs::P3_01, 4));
```

- **DI1** 映射为 **正转驱动禁止 (CCW Inhibit)**，将 **DI2** 映射为 **反转驱动禁止 (CW Inhibit)** 。

设置完毕后，报错 ERR7：驱动禁止异常（CCW / CW 驱动禁止输入端子都断开。）

### 如何应用到 DI 口（接线图示）

对于 P100S 驱动器，接线时需要注意公共端（COM）的极性：

1. **传感器供电**：棕色线接 +24V，蓝色线接 0V。
2. **信号连接**：将黑线（信号线）接入伺服 CN1 的 **DI1 (20脚)**。
3. **公共端处理**：为了配合 NPN 传感器的低电平输出，必须将 CN1 的 **COM (16脚)** 接到外部电源的 **+24V**。

### 测试 X1 轴的前进限位

设想双电机前进的限位，就是X1前进的限位、X2后退限位的场景。

将X1的DI1接通后，正转应该是不能动的。

# 12.23

今天继续思考ERR7报错问题。

## Err7报错解决

为了实现电机使用机械极限行程保护，所以进行了 **正转驱动禁止** 的实验。

### 前置步骤

#### 1. 配置寄存器

```C++
    m_p100scfgs.append(qMakePair(MotorRegs::PA20, 0));
    m_p100scfgs.append(qMakePair(MotorRegs::P3_00, 3));
```

- `PA-20` = 0：输入禁止的功能有效。
- `P3-0`= 3：DI1 设置为正转驱动禁止的功能
  - OFF：禁止正转(CCW)转动；
  - ON ：允许正转(CCW)转动。
- `PA-83` = 0：当机械碰到机械限位开关，限制该方向的转矩为0
- **PA55（输入端子有效电平控制字）**：
  - 这是一个4位二进制参数，分别对应D14、D13、D12、D11
  - **Bit0对应D11**：设为1表示高电平有效
  - 设置后：DI1高电平=ON，低电平=OFF

#### 2. 物理接线

现在寄存器配置完毕后，使用了 NPN NO 传感器**M18KN12W** ：

- **平时（未感应）**：黑线（输出端）处于悬空状态（高阻态），不导通。
- **动作（感应到金属）**：黑线与蓝线（0V/GND）内部接通。此时，黑线会输出一个**低电平信号（0V）**。

1. **电源连接**：
   - 将驱动器 **E24V（引脚44）** 连接到传感器 **棕色线（+24V）**
   - 将驱动器 **EOV（引脚43）** 连接到传感器 **蓝色线（0V）**
2. **信号连接**：
   - 将驱动器 **COM（引脚16）** 连接到 **E24V（引脚44）**（共阳接法）
   - 将传感器 **黑色线（信号输出）** 连接到驱动器 **DI1（引脚20）**

#### 3. 工作状态

当我使用Dp-In查看DI1的输入时：

- 默认为1
- 靠近金属后，输出为0

此时电机状态：

- `DI1` = 1：电机正转禁止，反转正常。
- `DI1` = 0：电机报错Err7

### 设置DI2为反转驱动禁止

尝试解决Err7报错。将 DI2 设置为 **反转驱动禁止** 的功能。

- `P3-1` = 4：反转驱动禁止
- `P3-15`= 2：数字输入 DI 强制有效。此时 2 对应的是 DI2 输入为 `1`。模拟反转驱动有信号
- `PA55` = 0b10：将 DI2 的输入取反

# 12.24

今天的任务：

- 禁用电机后，屏蔽对应的 UI
- 加入双限位的判断

## 以查询取代参数

**如果一个参数：**

- 只依赖于当前对象状态
- 没有表达“调用者的意图差异”（“谁对这个信息负责？”）
- 在多个地方都以相同规则被计算

👉 那它就不该是参数

## 禁用电机的逻辑

现在想实现的功能是：

1. 在配置界面将某个电机设置为不启用`isEnable`
2. 对应的在界面上便不会展示其按钮（界面上屏蔽）
3. 配置此电机的时候，也不会让其配置成功，而是提示此电机并未配置

## 电机参数

我们不妨看下，流转全局的电机参数是怎么获取和修改的。

### 1.初始化读取蓝牙盒子

在系统初始化的时候，`main`调用函数`initOrLoadServoMotors()`来进行机组配置的初始化。

最终读取的电机数据，会保存在：

```C++
QVector<T_servoMotor_config> DbCtrl::m_servoMotor_tb;
```

# 12.25

## DI限位控制

现在已经加入了 DI 的输入限位。现在行车运行到硬件限位后，需要让电机停止使能并提示已经运行到硬件限位处。

### 点动控制

在运行后，需要检测当前速度是否为0，如果为0，则走点动停止逻辑并且提示

```tex
电机速度为0，可能到达限位
```

- `checkJog()`加入 0 速的检测提示

### 位置移动

与点动逻辑类似，在`checkMove()`中加入 0 速提示。

但是一定要注意，当前速度寄存器要判断转速范围。现在默认是大于 3000 转默认是负转速，要用65536 减去这个转速。

# 12.29

现在需要加入特殊位置限制。

## 前进方向预启动

现在已知Z轴在X轴的某一区间内，是不允许上升至某个高度的。同理，如果Z轴在某一个高度，不允许X轴移动。

其实就是两个判断：

1. 判断Z轴是否超出安全限位
2. 判断X1X2位置是否位于警戒区域内

如果这两个判断均为正确，则弹窗提示需要降低Z轴电机到安全限位内。

## 周末错误异常

电机X1X2的位置超差，怀疑是点动没有配置，但是位置移动检测也是漏洞百出了。

# 12.30

## X轴的限位安全（预警）

当 X 轴位于或将进入某些危险区间时，Z 轴的高度不得超过某一安全上限

也就是说：

- 危险不是“方向本身”
- 危险是 **「X 位置 + Z 高度」的组合状态**

预警：

- 判断方向为前进：如果Z轴超出安全限位，且前进即将进入危险区域，则警告提示。
- 判断方向为后退：如果Z轴超出安全限位，且后退即将进入危险区域，则警告提示。

## X轴运动的限位安全

- 前进中：如果前方是危险区域，并且Z轴超出安全限位，则警告提示
- 后退中：如果后方是危险区域，并且Z轴超出安全限位，则警告提示

这样好像启动前和启动后的限位逻辑相同，均为X轴前进后退的时候，上方有一个限制区域，不允许Z轴上升到某一高度

