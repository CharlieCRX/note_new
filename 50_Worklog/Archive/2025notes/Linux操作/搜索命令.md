统计下在日常开发中，经常使用到的 Linux 命令
## 搜索文件
经常用到的搜索文件场景统计
### 当前目录搜索文件名
搜寻当前目录及其子目录下，是否存在`abc.zip`的文件
```bash
find . -type f -name "abc.zip"
```
- `.` → 从当前目录开始搜索
- `-type f` → 只找普通文件（不找目录）
- `-name "abc.zip"` → 文件名完全匹配 `abc.zip`
如果你不确定大小写（比如 `ABC.ZIP` 也想匹配），可以用：
```bash
find . -type f -iname "abc.zip"
```
如果你只记得部分文件名，比如包含 `abc`，可以用通配符：
```bash
find . -type f -name "*abc*.zip"
```
### 搜索的同时打印文件信息

> [!应用场景]
> 我想知道这些`abc.zip`的文件都在哪些位置

最简单的办法：`find + ls -l`（最简）
```bash
find . -type f -name "abc.zip" -exec ls -lh {} \;
```
- `-exec ... {} \;` → 对找到的每个文件执行命令
- `ls -lh` → 用人类可读方式显示大小（KB/MB/GB），显示修改时间
- **`-exec ls -lh {} \;`**
   这是 `find` 的执行动作：
  - **`-exec`** 表示对每个匹配到的文件执行后面的命令。
  - **`ls -lh`** 是你要执行的命令，`-l` 用长格式显示，`-h` 让大小人类可读（KB/MB）。
  - **`{}`** 是占位符，会被当前找到的那个文件路径替换。
  - **`\;`** 是 `-exec` 的结束标志，注意这里 `;` 需要用反斜杠转义（防止被 shell 提前解析）。

### 快速查询文件脚本
如果搜索文件很常用，就将其设置为脚本，进行快速查找文件：
```bash
# 快速搜索当前目录及子目录的文件，显示大小和修改时间，按修改时间排序（最新在上）
# 用法: fsearch abc.zip 或 fsearch abc
fsearch() {
    if [ -z "$1" ]; then
        echo "请提供搜索关键字，例如：fsearch abc.zip"
        return 1
    fi
    # find + ls -lh + 排序
    find . -type f -iname "*$1*" -exec ls -lh --time-style=long-iso {} + | sort -k6,7r
}
```
将其放入到`~/.bashrc`中，修改完毕后：
```bash
source ~/.bashrc
```
使用示例：
```bash
fsearch abc.zip   # 搜索文件名包含 abc.zip 的文件，按修改时间倒序
fsearch abc       # 搜索文件名包含 abc 的文件，按修改时间倒序
```

## 搜索包含关键字的文件

### 当前目录及子目录递归搜索

```bash
grep -rn "关键字" .
```

解释：

- `-r` → 递归当前目录及子目录
- `-n` → 显示匹配行的行号
- `"关键字"` → 你要搜索的文本
- `.` → 从当前目录开始

输出示例：

```bash
./path/to/file.txt:23:这里包含关键字的行
```

- `23` 表示行号

### 特殊文件路径

#### 1. **grep + grep 过滤**

因为搜索出来的很多文件可能并不是我们寻找的范围。例如多个架构中均存在某一个关键字`pmu_io_domains`，但是现在仅仅想看与`myzr`架构相关的文件。其文件会以`myzr`作为关键词。

>  **用 `grep` 搜索关键字**（例如 `pmu_io_domains`），但结果要**只保留文件路径里带有 `myzr` 的文件**。

先全局搜，再用第二层 grep 过滤文件路径：

```bash
grep -rn "pmu_io_domains" . | grep "myzr"
```

- 第一个 `grep` 搜索关键字

- 第二个 `grep` 用来过滤，只保留路径中包含 `myzr` 的结果

如果 `myzr` 出现在文件名（或路径）里，可以直接让 `grep` 只搜索匹配的文件：

#### 2. **grep 的 `--include`**

如果 `myzr` 出现在文件名（或路径）里，可以直接让 `grep` 只搜索匹配的文件：

```bash
grep -rn "pmu_io_domains" --include="*myzr*" .
```

这样 grep 从源头就跳过不相关的文件。

优点：更快，不会去读那些无关文件。
