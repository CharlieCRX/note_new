# 日志系统

现在需要在`servoV6`程序中，加入完善的日志系统。基于cmake的构建方式，记录下加入日志后的适配问题。

## 问题描述

当前项目的目录结构为：

```bash
Administrator@CRX MINGW64 /f/project/servoV6 (master)
$ ll
total 80
-rw-r--r-- 1 Administrator 197121   825 Jul 24 16:57 CMakeLists.txt
-rw-r--r-- 1 Administrator 197121 39275 Jul 25 11:19 CMakeLists.txt.user
-rw-r--r-- 1 Administrator 197121 13653 Jul 24 18:54 README.md
drwxr-xr-x 1 Administrator 197121     0 Jul 24 17:25 app/
drwxr-xr-x 1 Administrator 197121     0 Jul 24 16:34 build/
drwxr-xr-x 1 Administrator 197121     0 Jul 24 17:57 core/
drwxr-xr-x 1 Administrator 197121     0 Jul 24 17:03 drivers/
drwxr-xr-x 1 Administrator 197121     0 Jul 24 16:55 external/
drwxr-xr-x 1 Administrator 197121     0 Jul 24 19:04 tests/
drwxr-xr-x 1 Administrator 197121     0 Jul 24 17:04 transport/
```

现在已知的是在`core`下的`CMakeList.txt`为：

```cmake
add_library(corelib
    BusinessLogic.cpp
    Motor.cpp
    IMotor.h
    Logger.cpp
)


# 设置 corelib 的公共头文件目录
# 任何链接 corelib 的目标都可以通过 #include <BusinessLogic.h> 等方式找到头文件
target_include_directories(corelib PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

# 链接 spdlog 到 corelib
# corelib 内部的代码（如 BusinessLogic 和 Logger）会使用 spdlog
target_link_libraries(corelib PRIVATE spdlog::spdlog)
```

我现在想在所有的子项目均中使用`Logger.h`作为日志系统，我该怎么设计各个子目录下`CMakeList.txt`的格式

> 核心需求是：
>
> 1. 将 **spdlog** 作为子项目（而不是通过 `find_package` 安装）集成到你的 `servoV6` 项目中。
> 2. 在 `core` 子项目中创建一个 `Logger.h` 和 `Logger.cpp`，封装 spdlog 的使用。
> 3. 让 `servoV6` 项目的所有其他子项目（如 `app/`、`drivers/`、`transport/` 等）都能够方便地使用 `core/Logger.h` 进行日志记录。

## corelib改动

在`servoV6/core/CMakeLists.txt`定义 `corelib`，包含 `Logger.cpp`，并链接 `spdlog`。

修改的点就是将链接的`spdlog`作为公共库链接。这样会自动处理 `spdlog` 的公共编译定义和头文件路径，并将它们传递给任何链接 `corelib` 的目标。

```cmake
add_library(corelib
    BusinessLogic.cpp
    Motor.cpp
    Logger.cpp
)


# 设置 corelib 的公共头文件目录
# 任何链接 corelib 的目标都可以通过 #include <BusinessLogic.h> 等方式找到头文件
target_include_directories(corelib PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

# 链接 spdlog 到 corelib
# corelib 内部的代码（如 BusinessLogic 和 Logger）会使用 spdlog
# 外部依赖  corelib 的使用者也间接依赖 spdlog 的头文件，所以将其改为 PUBLIC
target_link_libraries(corelib PUBLIC spdlog::spdlog)
```

- 当 `app`、`drivers` 等子项目链接 `corelib` 时，它们不仅需要 `corelib` 的二进制文件，还需要 `corelib` 所依赖的**公共头文件**和**链接信息**。

- 通过 `target_link_libraries(corelib PUBLIC spdlog::spdlog)`，CMake 会自动处理 `spdlog` 的公共编译定义和头文件路径，并将它们传递给任何链接 `corelib` 的目标。

  这意味着当 `app` 链接 `corelib` 时，它也能够正确找到 `spdlog` 的头文件，而无需在 `app` 的 `CMakeLists.txt` 中显式地 `target_include_directories` 或 `target_link_libraries(MyApp PRIVATE spdlog)`。

## 其他子项目

这些子项目现在只需要链接 `corelib` 就能使用 `Logger.h`。

以 `servoV6/app/CMakeLists.txt` 为例：

```cmake
...
target_link_libraries(servoV6
    PRIVATE
        Qt6::Core
        Qt6::Gui
        Qt6::Quick
        corelib
        driverslib
        transportlib
)
...
```

- 无需显式链接 spdlog，因为它已经通过 corelib 传递。
- 无需显式添加 core/include 路径，因为它已经通过 corelib 的 PUBLIC 接口传递

------



## 调整目录结构与 CMake 配置

将日志功能从核心业务逻辑（`core`）中分离出来，放到一个通用的 `utils` 目录是更好的工程实践。这提高了模块的内聚性，也使得日志系统可以独立于 `core` 模块进行维护和使用。

现在，我们来调整 CMake 配置，以适应这个新的目录结构。

### 1. 新的目录结构

首先，确保你的项目目录结构更新为如下所示：

```bash
servoV6/
├── CMakeLists.txt              # 主 CMakeLists.txt
├── app/
│   └── CMakeLists.txt
├── core/
│   ├── CMakeLists.txt
│   ├── BusinessLogic.cpp
│   ├── Motor.cpp
│   └── IMotor.h
├── drivers/
│   └── CMakeLists.txt
├── external/
│   └── spdlog/
│       └── CMakeLists.txt
├── tests/
│   └── CMakeLists.txt
├── transport/
│   └── CMakeLists.txt
└── utils/                      # 新增的 utils 目录
    ├── CMakeLists.txt          # utils 目录的 CMakeLists.txt
    ├── Logger.h                # Logger.h 移动到这里
    └── Logger.cpp              # Logger.cpp 移动到这里
```

------

### 2. CMakeLists.txt 文件修改

#### 2.1. `servoV6/CMakeLists.txt` (主项目)

主项目需要添加 `utils` 子目录。

```cmake
cmake_minimum_required(VERSION 3.10)
project(servoV6 VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

option(BUILD_SHARED_LIBS "Build shared libraries" OFF)

# 1. 添加 spdlog 子项目 (不变)
add_subdirectory(external/spdlog)

# 2. 添加 utils 子项目 (新增)
add_subdirectory(utils)

# 3. 添加 core 子项目 (不变)
add_subdirectory(core)

# 4. 添加其他子项目 (不变)
add_subdirectory(app)
add_subdirectory(drivers)
add_subdirectory(transport)
add_subdirectory(tests)
```

#### 2.2. `servoV6/core/CMakeLists.txt` (核心业务逻辑库)

`corelib` 不再包含 `Logger.h` 和 `Logger.cpp`。它现在需要**链接 `utilslib`** 来使用日志功能。

```CMake
# servoV6/core/CMakeLists.txt

add_library(corelib
    BusinessLogic.cpp
    Motor.cpp
    IMotor.h
)

# 设置 corelib 的公共头文件目录 (不变)
target_include_directories(corelib PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

# 链接 utilslib
# corelib 现在依赖 utilslib 来获取日志功能。
# 如果 corelib 的某些公共接口（例如，返回错误信息）也间接依赖日志信息，
# 那么这里也应该使用 PUBLIC 链接，但通常 PRIVATE 就足够了。
target_link_libraries(corelib PRIVATE utilslib)
```

**适配问题：**

- **移除日志源文件：** 从 `corelib` 的 `add_library` 中移除了 `Logger.h` 和 `Logger.cpp`。
- **添加 `utilslib` 依赖：** `corelib` 现在通过 `target_link_libraries(corelib PRIVATE utilslib)` 来间接使用 `spdlog`。

#### 2.3. `servoV6/utils/CMakeLists.txt` (新增)

这个新的 `CMakeLists.txt` 将负责构建包含 `Logger.h` 和 `Logger.cpp` 的 **`utilslib`**。

```CMake
# servoV6/utils/CMakeLists.txt

add_library(utilslib
    Logger.h
    Logger.cpp
)

# 设置 utilslib 的公共头文件目录
# 任何链接 utilslib 的目标都可以通过 #include <Logger.h> 找到头文件
target_include_directories(utilslib PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

# 链接 spdlog 到 utilslib
# utilslib 内部的 Logger.cpp 会直接使用 spdlog。
# 由于 Logger.h 可能会暴露 spdlog 的类型（如 std::shared_ptr<spdlog::logger>），
# 并且其他模块通过 utilslib::utilslib 使用日志功能，
# 所以这里将 spdlog::spdlog 设为 PUBLIC，确保依赖正确传递。
target_link_libraries(utilslib PUBLIC spdlog::spdlog)

# 如果你希望其他项目能够通过 find_package 找到 utilslib
# 并且它是一个通用的独立库，你可以添加安装和导出规则。
# 但在这个内部子项目场景下，通常不需要。
```

**适配问题：**

- **新库目标：** 引入了新的库目标 `utilslib`。
- **依赖传递的重新配置：** `utilslib` 现在直接 `PUBLIC` 链接 `spdlog::spdlog`。这意味着任何链接 `utilslib` 的目标，都会自动继承 `spdlog` 的头文件和链接信息。

#### 2.4. 其他子项目 (`app/CMakeLists.txt`, `drivers/CMakeLists.txt`, `transport/CMakeLists.txt`)

这些子项目现在可以根据需要选择链接 `corelib` 或直接链接 `utilslib` 来使用日志功能。

**方案一：继续通过 `corelib` 间接使用日志（如果你想保持 `corelib` 封装日志）**

这与之前相同，如果 `corelib` 内部广泛使用日志，并且你希望所有依赖 `corelib` 的模块都能够获得日志功能，这是简单的方式。

以 `servoV6/app/CMakeLists.txt` 为例：

```CMake
# servoV6/app/CMakeLists.txt

add_executable(servoV6 main.cpp)

# 链接 corelib。由于 corelib 链接了 utilslib，且 utilslib 链接了 spdlog::spdlog，
# MyApp 将通过这种依赖链自动获得 spdlog 的头文件和链接信息。
target_link_libraries(MyApp PRIVATE corelib)
```

**方案二：直接链接 `utilslib` (如果你希望其他模块独立使用日志)**

如果 `app`、`drivers` 等模块不依赖 `corelib` 的其他功能，但仍需要日志功能，那么直接链接 `utilslib` 更清晰。

以 `servoV6/app/CMakeLists.txt` 为例：

```CMake
# servoV6/app/CMakeLists.txt

add_executable(MyApp main_app.cpp)

# 如果 MyApp 不依赖 corelib 的其他功能，只想要日志，可以直接链接 utilslib
target_link_libraries(MyApp PRIVATE utilslib)

# 如果 MyApp 既依赖 corelib 又需要日志（独立于 corelib 的日志使用），可以同时链接
# target_link_libraries(MyApp PRIVATE corelib utilslib)
# 但通常情况下，如果 corelib 已经封装并使用了日志，并且其他模块都通过 corelib 间接使用，
# 那么只需要链接 corelib 即可（因为 utilslib 通过 PUBLIC 链到了 corelib）。
```

**我推荐方案一**，即让其他模块通过链接 `corelib` 来间接获取日志功能。这样，`corelib` 仍然是你的主要业务逻辑模块，所有需要日志的地方都隐式地通过它获取。这简化了其他模块的 CMake 配置。



### 3. 代码修改 (最小)

- `core/Logger.h` 和 `core/Logger.cpp` 移动到 `utils/` 目录下。
- 所有使用 `Logger.h` 的源文件，现在应该 `include <Logger.h>`，前提是你的 CMake 配置正确地将 `utils` 的 `include` 目录传递给了这些编译目标。而我们通过 `target_include_directories(utilslib PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})` 和依赖链已经做到了这一点。

### 总结适配问题与解决方案

1. **目录重组：** 将 `Logger.h` 和 `Logger.cpp` 移动到 `utils/` 目录。
2. **新增 `utils` 子项目：** 在 `servoV6/CMakeLists.txt` 中添加 `add_subdirectory(utils)`。
3. **创建 `utilslib` 库：** 在 `servoV6/utils/CMakeLists.txt` 中定义 `add_library(utilslib ...)`，并设置其公共头文件路径。
4. **`utilslib` 链接 `spdlog`：** `target_link_libraries(utilslib PUBLIC spdlog::spdlog)`，确保 `spdlog` 的依赖正确传递给 `utilslib` 的使用者。
5. **`corelib` 链接 `utilslib`：** `target_link_libraries(corelib PRIVATE utilslib)`，让 `corelib` 可以使用日志功能。
6. **其他模块链接：** 其他模块（如 `app`）只需要链接 `corelib` (如果它们依赖 `corelib` 的其他功能，且 `corelib` 间接提供了日志），或者直接链接 `utilslib` (如果它们只想要日志功能且不依赖 `corelib`)。由于 `utilslib` 是 `PUBLIC` 链接 `spdlog` 的，所以间接依赖的传递是自动的，无需额外配置。

这种分离使得日志系统成为一个独立的、可复用的组件，整个项目的结构也更加清晰和模块化。

## 测试系统加入日志系统

当前GoogleTest的测试提下如下：

```bash
Administrator@CRX MINGW64 /f/project/servoV6/tests (master)
$ ll
total 12
-rw-r--r-- 1 Administrator 197121 1370 Jul 25 16:17 CMakeLists.txt
drwxr-xr-x 1 Administrator 197121    0 Jul 24 15:55 mocks/
-rw-r--r-- 1 Administrator 197121    0 Jul 24 16:15 test_adapter.cpp
-rw-r--r-- 1 Administrator 197121 3031 Jul 24 19:04 test_businesslogic.cpp
-rw-r--r-- 1 Administrator 197121    0 Jul 24 18:01 test_motor.cpp
```

`Logger` 单例封装了 `spdlog` 的初始化和使用，并通过单例模式确保全局只有一个日志实例。

现在，我们来讨论如何在 **Google Test** 环境下正确地集成和使用这个日志系统，并确保所有测试过程中的日志都能被记录下来。

### 自定义测试入口

Google Test 允许你编写自己的 `main` 函数，而不是使用 `gtest_main` 提供的默认 `main` 函数。这将为你提供一个理想的位置来初始化你的日志系统。

#### 1. 修改 `tests/CMakeLists.txt`

你需要创建一个单独的源文件来承载你的自定义 `main` 函数，并将其作为你测试可执行文件的入口。这意味着你将不再直接链接 `gtest_main`。

```cmake
# tests/CMakeLists.txt

# --- 定义一个公共变量，用于存放所有测试共享的源文件 ---
# 这样可以避免在每个测试可执行文件中重复添加公共源文件。
set(TEST_COMMON_SOURCES
    test_main.cpp # 新增：自定义的测试入口文件，包含 main 函数和日志初始化
)

# --- test_businesslogic ---
add_executable(test_businesslogic
    ${TEST_COMMON_SOURCES}
    test_businesslogic.cpp
    mocks/MockMotor.h
)
set_property(TARGET test_businesslogic PROPERTY AUTOMOC OFF AUTOUIC OFF)
target_link_libraries(test_businesslogic PRIVATE
  gtest          # 链接 gtest 而不是 gtest_main
  gmock
  utilslib       # 日志库
  corelib        # 核心业务逻辑库
)

# --- test_motor ---
add_executable(test_motor
    ${TEST_COMMON_SOURCES}
    test_motor.cpp
)
set_property(TARGET test_motor PROPERTY AUTOMOC OFF AUTOUIC OFF)
target_link_libraries(test_motor PRIVATE
  Qt6::Core      # 注意：如果你的 corelib 或 driverslib 依赖 Qt6::Core，那么所有链接它们的测试也需要。
  gtest
  gmock
  utilslib
  corelib
  driverslib
)

# --- test_adapter ---
add_executable(test_adapter
    ${TEST_COMMON_SOURCES}
    test_adapter.cpp
)
set_property(TARGET test_adapter PROPERTY AUTOMOC OFF AUTOUIC OFF)
target_link_libraries(test_adapter PRIVATE
  gtest
  gmock
  utilslib
  driverslib
  transportlib
)

# --- 注册测试 (不变) ---
include(GoogleTest)
gtest_discover_tests(test_businesslogic)
gtest_discover_tests(test_motor)
gtest_discover_tests(test_adapter)
```

**修改点解释：**

- **`TEST_COMMON_SOURCES`**: 引入了一个变量来存储所有测试可执行文件共用的源文件，这里就是 `test_main.cpp`。
- **移除 `gtest_main`，添加 `gtest`**: 当你提供自己的 `main` 函数时，你需要链接不包含 `main` 函数的 `gtest` 库，而不是 `gtest_main`。
- **Qt6::Core 依赖**: 留意 `test_motor` 和 `test_adapter` 中对 `Qt6::Core` 的依赖。确保 `corelib`, `driverslib`, `transportlib` 等实际需要的库也正确地链接了 `Qt6::Core`，否则可能会有链接错误。

#### 2. 创建 `tests/test_main.cpp`

这是一个新的文件，它将包含所有测试可执行文件通用的 `main` 函数。在这个 `main` 函数中，我们将初始化你的 `Logger` 单例。

```cpp
// tests/test_main.cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <Logger.h> // 包含你的 Logger 单例头文件
#include <string>
#include <filesystem> // 用于创建日志目录

namespace fs = std::filesystem;

// 可以在这里定义一个全局的测试监听器，如果需要的话
 class CustomTestEventListener : public ::testing::EmptyTestEventListener {
 public:
     void OnTestStart(const ::testing::TestInfo& test_info) override {
         LOG_INFO("Running test: {}.{}", test_info.test_suite_name(), test_info.name());
     }
     void OnTestEnd(const ::testing::TestInfo& test_info) override {
         if (test_info.result()->Failed()) {
             LOG_ERROR("Test failed: {}.{}", test_info.test_suite_name(), test_info.name());
         } else {
             LOG_INFO("Test passed: {}.{}", test_info.test_suite_name(), test_info.name());
         }
     }
 };

int main(int argc, char** argv) {
    // 1. 初始化 Google Test 框架
    ::testing::InitGoogleTest(&argc, argv);
    ::testing::InitGoogleMock(&argc, argv); // 如果使用了 Google Mock，也需要初始化

    // 2. 初始化你的日志系统
    // 定义日志文件路径
    std::string log_dir = "test_logs";
    fs::create_directories(log_dir); // 确保日志目录存在

    std::string log_file_path = log_dir + "/tests_log.txt";
    std::string log_level = "debug"; // 在测试中通常使用debug级别，以便记录更多信息

    Logger::getInstance().init(log_file_path, log_level);

    // 可以在这里添加一个自定义的测试事件监听器，用于记录测试的开始和结束
    // ::testing::TestEventListeners& listeners = ::testing::UnitTest::GetInstance()->listeners();
    // listeners.Append(new CustomTestEventListener());

    // 3. 运行所有测试
    int result = RUN_ALL_TESTS();

    // 4. (可选) 确保所有日志都已写入文件
    // 虽然 Logger::init 中设置了 flush_on(info)，但为了确保测试结束时所有日志都写入，
    // 可以在这里手动强制刷新所有 logger。
    spdlog::shutdown(); // 强制关闭所有logger并刷新缓冲区

    return result;
}
```

**`test_main.cpp` 解释：**

- **`#include <utils/Logger.h>`**: 包含了你现在位于 `utils` 目录下的 `Logger` 头文件。
- **日志目录和文件：** 代码中创建了一个 `test_logs` 目录，并将日志输出到 `test_logs/tests_log.txt`。这使得测试日志与普通应用程序日志分开，更易于管理。
- **日志级别：** 在测试环境中，通常将日志级别设置为 `debug` 或 `trace`，以便捕获更详细的执行信息，有助于调试。
- **`spdlog::shutdown()`**: 在 `RUN_ALL_TESTS()` 之后调用 `spdlog::shutdown()` 是一个好习惯。它会强制关闭所有 `spdlog` 的 logger，并确保所有缓冲区中的日志都已写入到目标（例如文件）。这对于确保在测试结束时不会丢失任何日志非常重要。
- **`CustomTestEventListener` (可选):** 注释掉的代码展示了如何利用 Google Test 的事件监听器来在每个测试开始和结束时自动打印日志。如果你希望测试报告中也包含这些信息，可以取消注释并使用它。

#### 3. 如何在测试代码中使用日志

在你的 `test_businesslogic.cpp`、`test_motor.cpp` 等测试文件中，你可以像常规应用程序代码一样使用 `LOG_INFO`, `LOG_DEBUG` 等宏：