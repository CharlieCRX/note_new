# P100S点动移动参数解析

现在需要我将原有的点动逻辑代码重新梳理下，然后根据手册解决新版本`servoV6`的点动控制逻辑

## 原有逻辑

```CPP
void MotorCtrl::actionJog(int dir)
{
    if (!canStartJog()) return;

    // 获取电机ID
    int motorID = getMotorID();
    m_jog_done = false;
    m_allDone = false;

    disableAllbt(dir);
    logJogStart(motorID, dir);

    // 预启动电机
    if (!applyJogConfig(motorID, dir)) return;
    if (!isPositionWithinLimit(motorID, dir)) return;

    // 点动控制伺服使能
    enableJogServo(motorID, dir);

    m_jog_dir = dir;
    m_checkWoker = new QThread;
    connect(m_checkWoker, &QThread::started, this, &MotorCtrl::checkJog);
    connect(m_checkWoker, &QThread::finished, this, &MotorCtrl::on_threadFinished);
    m_checkWoker->start();
}
```

这里除去不重要的界面设置和日志启动，预启动电机是最重要的逻辑：

```cpp
bool MotorCtrl::applyJogConfig(int motorID, int dir);
```

### 预启动逻辑

预启动逻辑`applyJogConfig()`是：

- 主电机点动配置：**调用 `jogConfig`**，尝试为 `motorID` 指定的电机设置点动配置。
- 双电机控制模式下的联动配置（特定条件），~~这个我们先按下不谈~~
- 函数结束

所以逻辑较为重要的就是`jogConfig()`。这个函数的作用是根据传入的电机ID和方向，来设置电机的点动模式。该函数主要根据电机ID，分为两种不同的处理逻辑。其逻辑为：

- 当电机ID为 `M_Y2` 时
- 当电机ID不是 `M_Y2` 时

针对 P100S 电机的型号并没有`M_Y2`这个编号的电机，所以只需要看不是`M_Y2`部分的逻辑：

- 步骤1：设置点动模式：函数会尝试向指定电机 `motorID` 的 `P3_31` 寄存器写入 `MotorRegs::JogMode`（代表点动模式）的值。
- 步骤2：设置点动方向
  - **判断方向**：根据传入的 `dir` 参数，判断点动方向。
    - 如果 `dir` 小于0，`act` 变量会被设置为 `MotorRegs::JogRunDec`，表示后退或负方向点动。
    - 如果 `dir` 不小于0，`act` 变量默认为 `MotorRegs::JogRunInc`，表示前进或正方向点动。
  - **写入寄存器**：函数再次尝试向指定电机 `motorID` 的 `P3_31` 寄存器写入 `act` 的值，从而控制电机的具体点动方向。

### 奇妙的P3-31

这里预启动的重点就是根据运动方向，向`P3-31`地址的寄存器写入不同的值。

- `JogMode`：点动模式，此枚举值为`2`。二进制为`0b0010`
- `JogRunDec`：负方向点动模式，此值为`6`。二进制为`0b0110`
- `JogRunDec`：正向点动模式，此值为`10`。二进制为`0b1010`

而要弄明白各种`P3-31`寄存器参数对于点动的影响，我们首先看下`P3-31`寄存器的功能以及在当前电机的用途。

`P3-31`寄存器的功能是：虚拟输入端子状态值。我们这时候要在这里重新提下，之前完成的《P100S位置移动参数解析》里面关于此参数的相关设置。看看 P3-31 如何控制正/反向点动。

控制动作的步骤应该是：

1. **写入 JogMode（P3-31 = 0b0010）**
    激活 `bit1=0` → CMODE=0：速度模式。

   这里`bit1`对应的是DI2的输入为1，而DI2之前（P3-39）设置的功能码为`16`, 设置`CMODE`，复合模式控制模式设定。

   > PA-4 为 3 时,CMODE OFF，为位置模式；CMODE ON，则为速度模式

   所以当在混合运动模式下，设置DI2为1的高电平，就是启动混合模式的速度模式。

    ✅ 这一步是设定运动模式的先决条件。

2. **写入点动方向触发位**

   - 正向点动 → P3-31 = `0b0010_0110` = `0x24` （bit1=0, bit2=0）
     - `P3-40 = 22 (JOGP)` 正向点动，对应 `P3-31.bit2`（bit2 = 1 → 有效）
   - 反向点动 → P3-31 = `0b0010_1010` = `0x28`（bit1=0, bit3=0）
     - `P3-41 = 23 (JOGN)` 反向点动，对应 `P3-31.bit3`（bit3 = 1 → 有效）

所以其实总体逻辑就是：

- 切换混合模式为速度模式
- 根据移动方向，选择正向点动还是负向点动。

分析完毕`applyJogConfig()`逻辑后，我们下一步进行点动的其他逻辑分析。

### 伺服使能

> 预配置好点动的逻辑后，下一步就是电机使能启动了。但是我觉得，点动开始之前，就需要使能。
>

伺服使能+正向/负向点动配置，此时电机就可以正常点动运行了。此时就来到了检查是否点动停止了。

`checkJog` 函数是一个**监控线程**，它的核心职责是**在电机进行点动（jog）运动时，持续检查其状态，并在达到特定条件时安全地停止运动**。

这里我们不去探究复杂`checkJog()`的复杂逻辑，直接去看如何优雅地停止点动`jogStop`。

### 优雅地点动停止

`jogStop()`对于 P100S 的停止流程主要分为三个阶段：**减速、抱闸、断电**。

#### 1. 减速阶段：平稳停车

- **进入点动模式**：首先，函数向电机的 `P3_31` 寄存器写入 **`JogMode`** 值。这一步非常关键，它告诉电机控制器不要立即停止，而是进入点动模式下的**受控减速过程**。这就像汽车踩下刹车，但不是紧急制动，而是缓慢减速。（此时设置就是取消点动DI输入）
- **读取抱闸参数**：在减速的同时，函数会读取两个重要的参数：
  - **`PA47`**：获取 **抱闸后延迟断电的时间**。这是一个安全裕量，确保在抱闸动作完成后，伺服才断电。
  - **`PA49`**：获取 **抱闸时电机的最小转速**。这个值设定了一个安全阈值，确保只有当电机转速足够低时，才能进行抱闸操作。

#### 2. 抱闸阶段：机械锁定

- **轮询等待**：这是一个**核心的同步机制**。函数进入一个 `while` 循环，持续读取电机的当前转速。
  - **循环条件**：它会一直等待，直到当前转速 (`S0` 寄存器) **小于或等于**预设的最小抱闸转速 (`PA49`)。
  - **超时保护**：为了防止电机出现故障导致程序卡死，这个循环设置了 5 秒的超时保护。
- **延时等待**：一旦转速达到安全值，循环结束。然后，函数会等待 `PA47` 中设置的**抱闸延迟时间**。这段等待时间非常重要，它确保了抱闸装置有足够的时间完全闭合，牢固地锁定电机，从而避免在断电瞬间由于惯性滑动。

#### 3. 断电阶段：最终停止

- **断开伺服使能**：这是停止流程的最后一步。函数向电机的 `PA53` 寄存器写入 `0`，从而**切断伺服驱动的励磁**。这相当于彻底切断了电机的动力来源。
- **发送完成信号**：最后，调用 `McuCtrl::finshed()` 并刷新电机位置，通知系统的其他部分此次运动已经完全结束。

### 总结

当进行点动进行的时候，需要：

- 切换混合模式为点动模式
- 正/负向点动

停止逻辑：

- 减速
- 抱闸
- 断电

点动就仅仅需要关注这两点。现在基于这两点，开发

```CPP
bool startPositiveRPMJog() override;
bool startNegativeRPMJog() override;
bool stopRPMJog() override;
```

## 开发逻辑

基于现在的接口实现点动的逻辑。

```CPP
bool startPositiveRPMJog() override;
bool startNegativeRPMJog() override;
bool stopRPMJog() override;
```



