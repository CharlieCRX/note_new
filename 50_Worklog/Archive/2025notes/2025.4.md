# 2025.4

## 3.31

1. TX到底接那个引脚？（用时1小时，问题出在了不理解串口、连接规则以及设备手册的规范）

   首先电脑要与设备进行的通信，需要通过PC上的USB接口，连接到设备上的UART接口才能进行通信。串口是查看系统启动日志、程序输出（类似`printf`打印）的唯一窗口（没有屏幕时）。

   PC要想连接设备，就需要一根USB转串口的线，这根线的一端是USB口连接PC，一端是串口线连接嵌入式设备。

   串口线主要由两根分线组成，一个是TX（`Transmit`发送线），一个是RX（`Receive`接受线）。

   而通信的时候，当PC作为发送设备的时候，PC将指令或数据通过发送线TX，发送给设备，设备此时要想收到数据，就需要通过设备自己的RX线接口。

   所以根据一个设备发送信息，一个设备接收信息，嵌入式设备的RX线会接收计算机通过TX发送过来的指令数据。

   看手册：CPU的J3_1:RX管脚(正方形焊盘)，所以应该与TX管脚连接。

## 4.1

### mv命令的测试

vscode通过ssh打开目录下的文件`1.txt`。此时在linux上执行

```bash
mv 1.txt 2.txt
```

可以看出vscode打开文件的时候，并不会导致重命名失效

### 快速编译arm项目

使用策略是修改 shell 配置文件（`~/.bashrc`），在文件末尾添加以下内容

```bash
alias armgcc='arm-linux-gnueabihf-gcc'
```

保存并退出文件后，执行`source ~/.bashrc`使配置生效即可。

但是缺点是已经打开的终端会话（tmux），也需要执行相同的更新配置命令才能使用。下次可以试着用软连接。

### Vim操作

- 实现将以`-I`开头的字符串改为`换行符-I`

  ```bash
  :%s/-I/\r-I/g
  ```

  命令含义：

  - `%`：表示对整个文件进行操作。
  - `s`：代表替换命令。
  - `/ -i`：查找以 `-I` 开头的字符串。你可以按需调整前面的空格。
  - `\r-I`：把匹配到的字符串替换成换行符和 `-I`。`\r` 代表换行符。
  - `g`：表示全局替换，也就是替换文件里所有匹配的字符串

### 头文件保护机制

头文件保护机制是为了防止头文件被重复包含的。当一个项目比较大时，可能会有多个源文件包含同一个头文件，或者在头文件嵌套包含的情况下，同一个头文件可能会被多次包含进同一个源文件中。如果没有头文件保护机制，这会导致重复定义错误，因为编译器会将头文件的内容复制到每个包含它的源文件中，重复包含就会使得相同的定义（如变量、结构体、函数声明等）出现多次。

头文件保护机制通过预处理器指令来实现。常见的做法是使用 `#ifndef`（如果未定义）、`#define`（定义宏）和 `#endif`（结束条件编译）这三个预处理器指令组合。其工作原理如下：

- 当第一次包含头文件时，预处理器会检查一个特定的宏是否已经被定义。如果该宏未定义（`#ifndef` 条件为真），则会定义这个宏（`#define`），并继续处理头文件中的内容。
- 当再次包含同一个头文件时，由于之前已经定义了该宏，`#ifndef` 条件为假，预处理器会跳过 `#ifndef` 和 `#endif` 之间的内容，从而避免了头文件内容的重复处理。

### 链接顺序

链接器在链接过程中会按照从左到右的顺序查找符号。

符号就是程序中变量、函数等的名字。当一个目标文件或库文件中出现对某个符号的引用，链接器会在后面的文件中查找是否有定义这个符号的内容。

例如两个文件

`file1.c`：

```C
#include <stdio.h>

extern void foo();  // 声明 foo 函数

int main() {
    foo();  // 调用 foo 函数
    return 0;
}
```

`file2.c`

```C
#include <stdio.h>

void foo() {  // 定义 foo 函数
    printf("Hello from foo!\n");
}
```

**编译链接**

首先编译这两个文件成目标文件（`.o` 文件）

```bash
gcc -c file1.c -o file1.o
gcc -c file2.c -o file2.o
```

然后，我们链接这两个目标文件来生成最终的可执行文件：

```bash
gcc file1.o file2.o -o my_program
```

如果我们按照正确的顺序（`file1.o` 和 `file2.o`）来链接，程序会按照预期工作。因为在 `file1.o` 中调用了 `foo()` 函数，而 `file2.o` 中定义了这个函数。链接器会先查找 `file1.o` 中调用的 `foo`，然后在后面的 `file2.o` 中找到 `foo` 的定义，成功链接。

然而如果我们按照错误的顺序链接

```bash
gcc file2.o file1.o -o my_program
```

这时，链接器会先看到 `file2.o` 中的 `foo` 函数定义，但它还没有遇到 `file1.o` 中对 `foo` 函数的调用。因此，链接器在第一次看到 `foo` 时，并不知道 `file1.o` 需要它，所以会报错，找不到 `foo` 函数的引用。

### 交叉编译

#### 目的

将多文件项目，编译好后传输到设备中并运行。

#### 平台

PC：Ubuntu 24.04.2 LTS + arm-linux-gnueabihf-gcc；嵌入式设备：MYZR-SSD2351-EK112；

#### 头文件问题

首先分析项目的makefile，看下编译流程

```bash
make -nB > compile_process.txt
```

然后执行make命令，结果发现编译报错。这里通过重定向功能将标准输出和错误信息同时保存到`build_log.txt`中

```bash
make &> build_log.txt
```

第一个报错：

执行命令

```bash
arm-linux-gnueabihf-gcc -Wall -std=gnu99 -fPIC -g -I. -I./uart -I./i2c -I./app -I./dev -I../arm_include -I../ad7768  -I../three_src -I../common   -c -o app/app.o app/app.c

```

结果报错：

```bash
app/app.c: In function ‘create_calc_buf’:
app/app.c:47:24: error: ‘CALC_DATA_KEY’ undeclared (first use in this function)
   47 |     id = shmget((key_t)CALC_DATA_KEY, sizeof(T_calc_data), 0666|IPC_CREAT);
      |                        ^~~~~~~~~~~~~
app/app.c:47:24: note: each undeclared identifier is reported only once for each function it appears in
app/app.c:47:46: error: ‘T_calc_data’ undeclared (first use in this function)
   47 |     id = shmget((key_t)CALC_DATA_KEY, sizeof(T_calc_data), 0666|IPC_CREAT);
      |   
```

但是这个全局变量`CALC_DATA_KEY`存在于`common/shares_def.h`中，并且此头文件也被`app.c`引用

```C
#include "commondef.h"
```

此文件所在的路径为`collecter/app/commondef.h`，点开此头文件，可以看到全局变量所在的头文件`shares_def.h`被引用了

```C
#include "shares_def.h"
```

但是，为什么还是会出现全局变量未定义呢？

问题排查：

- **头文件搜索路径问题**：`shares_def.h` 位于 `common` 目录下，需要确保该目录在编译命令的头文件搜索路径中。

  首先检查编译流程`compile_process.txt`，检查是否将头文件`shares_def.h`搜索路径正确添加。（`-I../common`）

  ```c
  $COMPILE_OPT -Wall -std=gnu99 -fPIC -g 
  	-I. 
  	-I./uart 
  	-I./i2c 
  	-I./app 
  	-I./dev 
  	-I../arm_include 
  	-I../ad7768  
  	-I../three_src 
  	-I../common
  ```

  很明显，头文件的搜索路径已经被正确添加了，但是还是没有引用到。路径的正确性没问题。

  但是这时候我发现，项目中存在了两个相同名称的头文件`shares_def.h`！😒

  ```bash
  crx@crxVMstation:~/work/2351/bigproj$ sudo find / -name 'shares_def.h'
  /home/crx/work/2351/bigproj/collecter/app/shares_def.h
  /home/crx/work/2351/bigproj/common/shares_def.h
  ```

  而`app.c`所使用的全局变量，存在于`common/shares_def.h`

  ```bash
  crx@crxVMstation:~/work/2351/bigproj$ grep -r "CALC_DATA_KEY"
  collecter/app/app.c:    id = shmget((key_t)CALC_DATA_KEY, sizeof(T_calc_data), 0666|IPC_CREAT);
  collecter/app/app.c:        ERR_LOG("shmget error key=%d len=%d\n", CALC_DATA_KEY, sizeof(T_calc_data));
  common/shares_def.h:#define  CALC_DATA_KEY         
  ```

  那么这个`collector/app`目录下的头文件`shares_def.h`跟`common`目录下的头文件差异在哪？

  ```diff
  --- common/shares_def.h 2024-11-04 15:57:09.755985800 +0800
  +++ collecter/app/shares_def.h  2024-04-17 17:48:09.968240300 +0800
  @@ -2,7 +2,6 @@
   #ifndef _SHARES_DEF_H_^M
   #define _SHARES_DEF_H_^M
   ^M
  -#define MAX_CHN_CNT                 4^M
   ^M
   #define MEM_1K                                 (1024)^M
   #define MEM_1M                          (1024*MEM_1K)^M
  @@ -16,15 +15,8 @@
   #define CFG_FILE                                   "/version/config.ini"^M
   ^M
   #define STORGE_BASE_PATH                "/www/data/"^M
  -^M
  -^M
  -#define  CALC_DATA_KEY                                 (1234)^M
  -typedef struct calc_data_{^M
  -    int wave_len;^M
  -    float wave_data[MAX_CHN_CNT][MEM_1M/sizeof(float)];^M
  -    float fft_data[MAX_CHN_CNT][MEM_1M/sizeof(float)];^M
  -}T_calc_data;^M
  -^M
  +#define FPGA_DATA_NAME_LIST             "/tmp/list_f"^M
  +#define SENSOR_DATA_NAME_LIST           "/tmp/list_s"^M
   ^M
   typedef struct user_cfg_s{^M
     uint32_t  debug;^M
  ```

  可以看出，在 `common/shares_def.h` 文件里定义了 `#define CALC_DATA_KEY (1234)`，但 `collecter/app/shares_def.h` 文件中并没有这个定义。同理结构体`T_calc_data`也是只在`common/`下的头文件中定义。

  那么报错问题，应该是编译器错误地包含了`collecter/app/shares_def.h`文件，出现了未定义的错误。

  那现在我该怎么做？我怀疑是两个文件是重复的，并且其中有一个文件是无效或者两者互为补充的。现在通过vscode的分析，发现两者是重复+互补，准备将两个文件替换成一个头文件`common/shares_def.h`

  按住Ctrl键后选中两个文件，进行文件的替换。

- **头文件保护机制问题**：检查头文件`shares_def.h`是否存在头文件保护。打开头文件：

  ```C
  #ifndef _SHARES_DEF_H_
  #define _SHARES_DEF_H_
  #define MAX_CHN_CNT                 4
  //...
  #define  CALC_DATA_KEY					(1234)
  #endif //_SHARES_DEF_H_
  ```

  发现是存在头文件保护的，这个部分没问题。

- **头文件合并问题**：两个文件`collecter/app/shares_def.h`和`common/shares_def.h`，进行合并

  上文可以看出问题在于出现了两个同名文件，并且两个文件的内容既互补又重复，所以进行两个文件的合并。合并完成后，再次执行make命令，查看编译结果

  ```bash
  make &> build_log.txt
  ```

  此时报错

  ```C
  arm-linux-gnueabihf-gcc -Wall -std=gnu99 -fPIC -g -I. -I./uart -I./i2c -I./app -I./dev -I../arm_include -I../ad7768  -I../three_src -I../common   -c -o app/app.o app/app.c
  In file included from app/commondef.h:42,
                   from app/app.c:2:
  ../common/shares_def.h:74:21: error: duplicate member ‘gain’
     74 |         uint32_t    gain[MAX_CHN_CNT];
        |                     ^~~~
  
  ```

  在编译`app.c`的时候，发现在 `../common/shares_def.h` 文件的第 74 行出现了成员重复定义的问题，具体是 `gain` 成员重复。查看代码，发现是`gain` 成员可被多次定义在同一个结构体`user_cfg_t`里。

  ```C
  #define MAX_CHN_CNT   4
  typedef struct user_cfg_s{
      uint32_t  gain[4];
      //...
      uint32_t    gain[MAX_CHN_CNT];
  }user_cfg_t;
  ```

  为了文件的健康，删除了没有宏定义的`gain[4]`。删除后再次执行make编译。报错

  ```bash
  arm-linux-gnueabihf-gcc -Wall -std=gnu99 -fPIC -g -I. -I./uart -I./i2c -I./app -I./dev -I../arm_include -I../ad7768  -I../three_src -I../common   -c -o app/calc.o app/calc.c
  In file included from app/calc.c:1:
  app/commondef.h: In function ‘trace_bin’:
  app/commondef.h:219:5: warning: this ‘else’ clause does not guard... [-Wmisleading-indentation]
    219 |     else
        |     ^~~~
  app/commondef.h:222:9: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the ‘else’
    222 |         free(strBuf);
        |         ^~~~
  app/calc.c: In function ‘deal_err’:
  app/calc.c:54:18: error: ‘T_app_cfgctrl’ {aka ‘struct app_cfgctrl’} has no member named ‘show_charts’
     54 |     g_app_cfgctrl->show_charts = 0;
        |                  ^~
  app/calc.c:55:18: error: ‘T_app_cfgctrl’ {aka ‘struct app_cfgctrl’} has no member named ‘adjust_en’
     55 |     g_app_cfgctrl->adjust_en = 0;
        |                  ^~
  
  ```

  发现是我刚才的`shares_def.h`没有被删除？我合并完毕代码后，使用了mv命令来将源文件重命名为新文件

  ```bash
  mv shares_def.h shares_def_h_backup
  ```

  但是仍存在源文件，很奇怪，估计是linux删除的时候，vscode没关闭此文件导致的。测试一下。

  很遗憾，经过测试vscode打开文件，并不会影响mv重命名文件。😢

  现在删除完毕后，再次执行make命令。

#### 函数声明与定义问题

  编译文件`dev/gyro.c`的时候，发现报错

  ```bash
  arm-linux-gnueabihf-gcc -Wall -std=gnu99 -fPIC -g -I. -I./uart -I./i2c -I./app -I./dev -I../arm_include -I../ad7768  -I../three_src -I../common   -c -o dev/gyro.o dev/gyro.c
  In file included from dev/gyro.c:1:
  ./app/commondef.h: In function ‘trace_bin’:
  ./app/commondef.h:219:5: warning: this ‘else’ clause does not guard... [-Wmisleading-indentation]
    219 |     else
        |     ^~~~
  ./app/commondef.h:222:9: note: ...this statement, but the latter is misleadingly indented as if it were guarded by the ‘else’
    222 |         free(strBuf);
        |         ^~~~
  dev/gyro.c: At top level:
  dev/gyro.c:8:5: error: conflicting types for ‘gyro_get’; have ‘int(T_depth_info *)’ {aka ‘int(struct depth_info *)’}
      8 | int gyro_get(T_depth_info *gyro_info)
        |     ^~~~~~~~
  
  ```

  可能的原因：

  - 函数声明与定义不匹配

    先声明后定义，检查函数`gyro_get`的定义和声明，查看是否存在返回值或参数类型不一致的情况：

    声明在`collecter/dev/user_dev.h`

    ```C
    int gyro_get(T_gyro_info *gyro_info);
    ```

    定义在`collecter/dev/gyro.c`

    ```C
    int gyro_get(T_depth_info *gyro_info)
    {
      // TODO 
      return 0;
    }
    ```

    很明显，定义时的变量是错误的。将定义时候的参数类型`T_depth_info`改为`T_gyro_info`即可。

  - 类型定义不一致：排除此可能。因为只有一个头文件`collecter/dev/user_dev.h`对 `gyro_get` 函数有确切的声明。

这个部分问题较为简单解决。

#### 链接

编译没问题后，来到了链接流程：

```bash
armgcc
    -lm
    -L../arm_lib
    -lpthread
    -lrt
    -lsqlite3
./uart/uart_x.o
./i2c/user_i2c.o
./app/app.o
/app/arp.o
./app/calc.o
./app/cfg.o
./app/cJSON.o
./app/db.o
./app/dictionary.o
./app/filelock.o
./app/iniparser.o
/app/packet_sni_fwd.o
./app/storage.o
./app/test.o
/dev/adc.o
/dev/depth.o
./dev/fpga.o
./dev/gain.o
./dev/gyro.o
./dev/gyro_hcm360b.o
./dev/rubidiumclock.o  .
./ad7768/ad7768.o
    -o collecter
../arm_lib/libfftw3.a 
    -lm
```

这里的 `armgcc` 是 `arm-linux-gnueabihf-gcc` 的别名。

但是链接时候报错，报错很多，我们先看前面部分的报错信息

##### 重复定义问题

重复定义的报错信息是在链接阶段出现的，链接器负责将多个目标文件（`.o` 文件）和库文件组合成一个可执行文件。当链接器发现同一个标识符（如变量、函数等）在多个目标文件中被定义时，就会抛出重复定义的错误。

链接报错：

```bash
ld: ./i2c/user_i2c.o:/home/crx/work/2351/bigproj/collecter/./app/commondef.h:61: multiple definition of `db'; ./uart/uart_x.o:/home/crx/work/2351/bigproj/collecter/./app/commondef.h:61: first defined here
ld: ./i2c/user_i2c.o:/home/crx/work/2351/bigproj/collecter/./app/commondef.h:74: multiple definition of `head'; ./uart/uart_x.o:/home/crx/work/2351/bigproj/collecter/./app/commondef.h:74: first defined here

//.....
```

- 重复定义的目标文件和位置

  ```bash
  ./i2c/user_i2c.o:/home/crx/work/2351/bigproj/collecter/./app/commondef.h:61
  ```

  指出 `user_i2c.o` 这个目标文件存在重复定义的问题；重复定义发生在 `commondef.h` 文件的第 61 行

- 重复定义的标识符

  ```bash
  multiple definition of `db'
  ```

  明确指出重复定义的标识符是 `db`，即变量 `db` 在多个地方被定义

- 首次定义的目标文件和位置

  ```bash
  ./uart/uart_x.o:/home/crx/work/2351/bigproj/collecter/./app/commondef.h:61: first defined here
  ```

  表示 `db` 变量首次定义在 `uart_x.o` 目标文件中。首次定义的位置是 `commondef.h` 文件的第 61 行。

问题分析：头文件中直接定义全局变量，会导致该变量的定义被包含在所有包含该头文件的源文件中，从而在链接时引发重复定义的问题。

在头文件`commondef.h`中，db的定义为

```C
sqlite3 *db;
```

所以预处理的时候，两个源文件都会包含相同的全局变量`db`的定义。链接器在将 `user_i2c.o` 和 `uart_x.o` 以及其他可能的目标文件和库文件链接成可执行文件时，会发现 `db` 变量在多个目标文件中都有定义，从而抛出重复定义的错误。

为了实现文件里使用另一个文件中定义的变量，这时就可以借助 `extern` 关键字来声明该变量，告知编译器这个变量在其他地方已经定义过了，无需再次分配内存。

```c
extern sqlite3 *db;
```

##### 未定义的引用问题

报错信息

```bash
ld: ./app/app.o: in function `get_run_time':
/home/crx/work/2351/bigproj/collecter/app/app.c:687:(.text+0x2c9a): undefined reference to `sqlite3_free_table'
ld: ./app/db.o: in function `check_license':
/home/crx/work/2351/bigproj/collecter/app/db.c:33:(.text+0xa6): undefined reference to `sqlite3_open'
ld: /home/crx/work/2351/bigproj/collecter/app/db.c:43:(.text+0x12e): undefined reference to `sqlite3_get_table'
ld: /home/crx/work/2351/bigproj/collecter/app/db.c:45:(.text+0x150): undefined reference to `sqlite3_free'
ld: /home/crx/work/2351/bigproj/collecter/app/db.c:55:(.text+0x178): undefined reference to `sqlite3_get_table'
ld: /home/crx/work/2351/bigproj/collecter/app/db.c:57:(.text+0x19a): undefined reference to `sqlite3_free'
```

- 未定义的目标文件和位置

  ```bash
  ./app/app.o: in function `get_run_time': /home/crx/work/2351/bigproj/collecter/app/app.c:687:
  ```

  指出在目标文件`app.o`中存在未定义引用的问题。未定义引用发生在`app/app.c`函数`get_run_time`的687行

- 未定义的引用

  ```bash
  undefined reference to `sqlite3_free_table'
  ```

  链接过程中找不到 `sqlite3_free_table` 函数的定义。

解决思路：

- 库文件路径指定问题

   SQLite 库位于 `arm_lib/libsqlite3.so` ，并且对于`collector/collector`，其相对路径为`../arm_lib`。所以链接命令中指定库文件路径

  ```bash
   -L../arm_lib
  ```

  是OK的，路径指定应该没问题。

- 链接顺序

  链接器按照从左到右的顺序处理目标文件和库文件，若库文件放置的位置在目标文件之前，会导致未定义引用错误。这里修改Makefile，将库的处理放到目标文件的后面。

  ```makefile
  $(TARGET_NAME): $(THIS_OBJS)
  	$(CC) $(THIS_OBJS) $(LIBADDS) ../arm_lib/libfftw3.a -o $(TARGET_NAME) -lm
  ```

破案了文件拷贝错误。重新给了一版。

## 4.2

今天继续ssd2351的交叉编译。

### PATH作用

在终端输入命令时，系统会按照 `PATH` 中列出的目录顺序**从左到右**查找可执行文件。找到第一个匹配的程序后立即执行。

通过将工具链路径放在 `PATH` 的最前面（`新路径:$PATH`），系统会优先使用您的交叉编译工具，而不是系统默认的 `gcc`。

**`:$PATH` 的意义**：保留系统原有的搜索路径（如 `/usr/bin`、`/bin` 等）。 `:` 是用于分隔不同路径的分隔符。

如果末尾不添加`:$PATH`，则`PATH` 环境变量中仅保留工具链的 `bin` 目录，不再包含任何系统默认路径（如 `/usr/bin`、`/bin`、`/usr/local/bin` 等）。这样会导致所有非工具链命令都会失效。除非输入其完整路径。例如下面就是新增路径的时候，后面没有保留系统原有的搜索路径的结果：

```bash
crx@crxVMstation:~$ gcc
Command 'gcc' is available in the following places
 * /bin/gcc
 * /usr/bin/gcc
The command could not be located because '/bin:/usr/bin' is not included in the PATH environment variable.
gcc: command not found
```

并且如果删除了，需要重新在`.bashrc`中设置系统默认的路径，然后刷新配置。

```bash
export PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin
```

### 设置交叉编译工具

现在SSD2351用到的交叉编译工具是存放在目录

```bash
crx@crxVMstation:~/ssd2351/tool/toolchain/arm-sigmastar-linux-gcc-12.4.0-uclibc-1.0.46-gnueabihf$ pwd
/home/crx/ssd2351/tool/toolchain/arm-sigmastar-linux-gcc-12.4.0-uclibc-1.0.46-gnueabihf
```

配置环境变量`~/.bashrc`，设置交叉工具链。

1. 首先将工具链的`bin`目录（存放交叉编译的工具，包括gcc、ld等），添加到`path`的最前面。格式为`新路径:$PATH`

   ```bash
   export PATH=/home/crx/ssd2351/tool/toolchain/arm-sigmastar-linux-gcc-12.4.0-uclibc-1.0.46-gnueabihf/bin:$PATH
   ```

2. 设置别名，快速调用其中的程序

   ```bash
   alias armgcc='arm-sigmastar-linux-uclibcgnueabihf-12.4.0-gcc'
   alias armld='arm-sigmastar-linux-uclibcgnueabihf-12.4.0-ld'
   ```

3. 额外的配置

   ```bash
   export CROSS_COMPILE=arm-sigmastar-linux-uclibcgnueabihf-12.4.0-
   export ARCH=arm
   ```

这样就设置完毕了。

### Makefile配置交叉编译工具链

上一步修改完毕交叉编译工具后，现在就需要修改Makefile中的编译选项了。

```makefile
CROSS_COMPILE ?= arm-sigmastar-linux-uclibcgnueabihf-12.4.0-
CC = $(CROSS_COMPILE)gcc
```

- **`CROSS_COMPILE`**：

  这是一个变量，存储了交叉编译工具链的前缀字符串。
  `?=` 表示"如果未定义则赋值"，允许通过命令行覆盖该值。

- **`$(CROSS_COMPILE)gcc`**：

  通过变量引用拼接出完整的编译器命令。最终会展开为：
  `arm-sigmastar-linux-uclibcgnueabihf-12.4.0-gcc`

而在bash中，变量引用需要`${CROSS_COMPILE}`

```bash
crx@crxVMstation:~/work/2351/app/arm_lib$ echo ${CROSS_COMPILE}gcc
arm-sigmastar-linux-uclibcgnueabihf-12.4.0-gcc
```

### tar命令

```bash
tar zxvf sqlite-autoconf-*.tar.gz
```

这条命令做了什么：

- **`z`**：该选项代表 `--gzip`，意思是使用 `gzip` 算法对归档文件进行压缩或解压缩。

  在 `tar` 命令里，`z` 选项通常和 `x`（解压）或 `c`（创建归档）一起使用。当使用 `z` 选项时，`tar` 会自动识别 `.tar.gz` 或 `.tgz` 这样的文件扩展名，并使用 `gzip` 算法进行相应的处理。

- **`x`**：即 `--extract` 或 `--get`，其作用是从归档文件中提取文件。当你想要把一个已经打包好的 tarball 解压时，就需要使用这个选项。

- **`v`**：也就是 `--verbose`，它的功能是在操作过程中显示详细的信息。当使用 `v` 选项时，`tar` 命令会在解压或打包文件的过程中，逐行输出每个被处理的文件的名称，这样你就可以实时了解操作的进度。

- **`f`**：代表 `--file`，该选项用于指定要处理的归档文件的名称。在使用 `tar` 命令时，`f` 选项后面必须紧跟要处理的文件的名称。

- **`C`**：指定解压的目标目录。


### dmesg命令

`dmesg` 是一个用于显示内核环缓冲区（kernel ring buffer）信息的命令。内核环缓冲区会记录系统启动时和运行过程中内核产生的各种信息，包括硬件检测、驱动加载、系统错误等。

使用`tail` 命令用于查看文件或标准输入的末尾几行内容。默认情况下，`tail` 会显示文件的最后 10 行。

`dmesg | tail`表示将最近的内核信息的最后10行输出出来，可以很方便地检测U盘设备是否插入。

### /dev/sd存储设备

一般情况下，通过 USB 插入到设备上的存储设备，通常会被识别为以 `/dev/sd` 开头的文件。

在 Linux 系统中，SCSI 子系统负责管理各种存储设备，包括传统的 SCSI 硬盘、USB 存储设备、SD 卡等。

将 USB 存储设备插入到设备上时，系统的设备管理器会检测到该设备，并将其作为一个 SCSI 设备进行处理，通常会分配一个形如 `/dev/sdX`（X 为 a、b、c 等字母）的设备文件来代表它。

所以通过命令

```bash
ls /dev/sd*
```

就是打印`/dev` 目录下所有以 `sd` 开头的文件，就是展示所有的SCSI磁盘设备。

而`lsblk` 是一个用于列出块设备信息的命令，它会以树形结构展示系统中所有块设备（如硬盘、USB 闪存驱动器、光盘驱动器等）及其相互关系。

```bash
sda      8:0    0   100G  0 disk
├─sda1   8:1    0     1M  0 part
└─sda2   8:2    0   100G  0 part /var/snap/firefox/common/host-hunspell
```

说明磁盘sda被分区为sda1和sda2。

### grep命令

`grep` 是一个强大的文本搜索工具，用于在输入文本中查找包含指定模式的行。其主要作用为

1. 基本文本搜索

   在文件中查找包含指定字符串的行。使用 `-i` 选项可以忽略大小写进行搜索。

   ```bash
   grep "pattern" filename
   ```

2. 递归搜索目录

   使用 `-r` 或 `-R` 选项可以递归地在指定目录及其子目录下的所有文件中进行搜索。

   ```bash
   grep -r "pattern" directory
   ```

3. 显示行号

   使用 `-n` 选项可以在输出结果中显示匹配行的行号。

   ```bash
   grep -n "pattern" filename
   ```

4. 从标准输入搜索

   `grep` 可以从标准输入接收数据进行搜索。

   ```bash
   command | grep "pattern"
   ```

### 嵌入式设备的网线连接

因为串口传输速度太慢，所以现在需要寻求网线的传输，已知Ubuntu的ip地址

```bash
inet 192.168.1.13  netmask 255.255.255.0  broadcast 192.168.1.255
```

配置PC同一子网（如PC是 `192.168.1.13`，设备可用 `192.168.1.100`）

```bash
ifconfig eth0 192.168.1.100 netmask 255.255.255.0 up
```

配置好后，可以通过telnet命令连接到设备

### 获取U盘数据

现在由于ssh的动态链接库缺失，导致无法使用scp命令快速传输文件，所以现在通过U盘将动态链接库发送到设备上。这里记录下，设备如何拿到U盘的数据

#### 检测U盘设备

插入U盘后，查看设备节点

```bash
dmesg | tail
```

输出为

```BASH
/customer # dmesg | tail
scsi host0: usb-storage 1-1:1.0
phy phy-soc:u2phy2@0x1f285200.1: high-speed connect
scsi 0:0:0:0: Direct-Access     aigo     U268             2.00 PQ: 0 ANSI: 4
sd 0:0:0:0: [sda] 15728640 512-byte logical blocks: (8.05 GB/7.50 GiB)
sd 0:0:0:0: [sda] Write Protect is off
sd 0:0:0:0: [sda] Mode Sense: 03 00 00 00
sd 0:0:0:0: [sda] No Caching mode page found
sd 0:0:0:0: [sda] Assuming drive cache: write through
 sda: sda1 sda2
sd 0:0:0:0: [sda] Attached SCSI removable disk
```

可以看出U盘设备包含两个分区，分别是 `sda1` 和 `sda2`，并且成功地连接到设备上了。

确认块设备

```bash
ls /dev/sd*  # 列出所有SCSI设备
```

输出为：

```bash
/customer # ls /dev/sd*
/dev/sda   /dev/sda1  /dev/sda2
```

#### 挂载U盘

将U盘连接到系统的某个位置，让系统能够访问和使用这个设备上的文件和数据。

**创建挂载点**

```bash
mkdir -p /mnt/usb
```

**挂载设备**

根据U盘文件系统类型选择命令。首先查看U盘设备的文件系统

```bash
crx@crxVMstation:~/work/2351/app/arm_lib$ lsblk -f /dev/sdb
NAME   FSTYPE FSVER LABEL     UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
sdb
├─sdb1 ntfs         大白菜U盘 CCD234DBD234CC08
└─sdb2 vfat   FAT32 EFI       0BD9-1497
```

我们将数据存放在了`ntfs`的设备`sdb1`中了，所以要挂载`sdb1`。将其挂载到`/customer/usb`

```bash
mount /dev/sda1 /customer/usb
```

**验证挂载**

`df` 命令用于显示文件系统磁盘空间的使用情况，包括已用空间、可用空间、挂载点等信息。通过`grep`工具将挂载到`/customer/usb`的那部分信息筛选出来

```bash
/customer/usb # df -h | grep usb
/dev/sda1                 6.1G      3.9G      2.3G  63% /customer/usb
```

可以发现usb存储设备挂载成功。然后列出usb的文件

```bash
/customer/usb # ls /customer/usb/
DBC                                   crx
OneKeyBak                             pwm
PEData                                pwm.v
RTL                                   windows_10_professional_x64_2022.iso
System Volume Information
```

#### 访问数据

**复制文件到设备**

```bash
cp /customer/usb/crx/libsqlite3.so.0.8.6 /customer/lib/
```

#### 卸载U盘

```bash
mount /customer/usb
sync
```

### 编译sqllite3

#### 获取源文件

首先要获取要编译的sqlite版本。经过查看之前库的`sqlite3.h`

```C
#define SQLITE_VERSION        "3.28.0"
#define SQLITE_VERSION_NUMBER 3028000
#define SQLITE_SOURCE_ID      "2019-04-16 19:49:53 884b4b7e502b4e991677b53971277adfaf0a04a284f8e483e2553d0f83156b50"
```

可以看出版本为`3.28.0`，下载此版本源码

```bash
wget https://www.sqlite.org/2019/sqlite-autoconf-3280000.tar.gz
```

将其放在了目录

```
/home/crx/Downloads
```

解压缩

```bash
tar zxvf sqlite-autoconf-*.tar.gz
crx@crxVMstation:~/Downloads/sqlite-autoconf-3280000$ pwd
/home/crx/Downloads/sqlite-autoconf-3280000
```

接下来就需要对源码，进行交叉编译了。编译工具为`armgcc`

```bash
alias armgcc='arm-sigmastar-linux-uclibcgnueabihf-12.4.0-gcc'
```

#### 运行配置脚本

进入解压后的 SQLite 源码目录，运行 `configure` 脚本，指定交叉编译工具和相关选项以生成动态链接库。以下是一个示例配置命令

```bash
./configure --host=arm-sigmastar-linux-uclibcgnueabihf --prefix=/home/crx/work/2351/arm_lib --enable-shared CC=${CROSS_COMPILE}gcc AR=${CROSS_COMPILE}ar RANLIB=${CROSS_COMPILE}ranlib
```

- `--host`：指定目标平台的交叉编译工具链前缀，这里是 `arm-sigmastar-linux-uclibcgnueabihf`。
- `--prefix`：指定编译后的库和头文件的安装路径。
- `--enable-shared`：启用共享库（动态链接库）的编译。
- `CC`：指定使用的 C 编译器，使用交叉编译工具链中的 `gcc`。
- `AR`：指定使用的归档工具，使用交叉编译工具链中的 `ar`。
- `RANLIB`：指定使用的索引生成工具，使用交叉编译工具链中的 `ranlib`。

#### 编译源代码

运行 `make` 命令开始编译源代码：

```bash
make
```

安装编译后的库和头文件：使用 `make install` 命令将编译好的动态链接库和头文件安装到之前指定的 `--prefix` 路径下

```bash
make install
```

#### 检查编译结果

检查下编译的动态链接库的属性

头文件跟之前一致：

```C
#define SQLITE_VERSION        "3.28.0"
#define SQLITE_VERSION_NUMBER 3028000
#define SQLITE_SOURCE_ID      "2019-04-16 19:49:53 884b4b7e502b4e991677b53971277adfaf0a04a284f8e483e2553d0f83156b50"
```

文件属性OK

```bash
crx@crxVMstation:~/work/2351/arm_lib/lib$ file libsqlite3.so.0.8.6
libsqlite3.so.0.8.6: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (SYSV), dynamically linked, with debug_info, not stripped
```

### 编译2351程序

#### 编译

设置完毕makefile进行编译，链接器报错

```bash
arm-sigmastar-linux-uclibcgnueabihf-12.4.0-gcc  ./uart/uart_x.o  ./i2c/user_i2c.o  ./app/app.o  ./app/arp.o  ./app/calc.o  ./app/cfg.o  ./app/db.o  ./app/packet_sni_fwd.o  ./app/storage.o  ./dev/adc.o  ./dev/depth.o  ./dev/fpga.o  ./dev/gain.o  ./dev/gyro_hcm360b.o  ../three_src/cJSON.o  ../three_src/dictionary.o  ../three_src/filelock.o  ../three_src/iniparser.o  ../ad7768/ad7768.o -lm -L../arm_lib -lpthread -lrt -lsqlite3 ../arm_lib/libfftw3.a -o collecter -lm
ld: warning: libm.so.6, needed by ../arm_lib/libsqlite3.so, not found (try using -rpath or -rpath-link)
ld: warning: libdl.so.2, needed by ../arm_lib/libsqlite3.so, not found (try using -rpath or -rpath-link)
ld: warning: libpthread.so.0, needed by ../arm_lib/libsqlite3.so, not found (try using -rpath or -rpath-link)
ld: warning: libc.so.6, needed by ../arm_lib/libsqlite3.so, not found (try using -rpath or -rpath-link)
ld: warning: ld-linux-armhf.so.3, needed by ../arm_lib/libsqlite3.so, not found (try using -rpath or -rpath-link)
```

报错问题找不到 `libsqlite3.so` 所依赖的几个系统库文件。`libsqlite3.so`存放的位置在

```bash
/home/crx/work/2351/app/arm_lib
```

makefile的目录在

```bash
/home/crx/work/2351/app/collecter
```

现在怀疑`libsqlite3.so`的源文件，编译的时候并没有使用相同的交叉编译工具。所以我想尝试一下，用`armgcc`将动态链接库重新编译后，再将其放入到目录

```
/home/crx/work/2351/app/arm_lib
```

从而替换之前的编译版本。

替换完毕后，重新编译2351程序发现已经编译通过。

#### 运行

将打包好的目标文件`collector`传输到开发设备后，运行报错：

```bash
/customer/new # ./collecter 
/customer/new/collecter: can't load library 'libsqlite3.so.0'
```

缺失动态链接库`libsqlite3.so.0`，查看sqlite3目录

```C
crx@crxVMstation:~/work/2351/arm_lib/lib$ ll
total 11836
drwxrwxr-x 3 crx crx    4096 Apr  2 13:35 ./
drwxr-xr-x 6 crx crx    4096 Apr  2 13:35 ../
-rw-r--r-- 1 crx crx 6859060 Apr  2 13:35 libsqlite3.a
-rwxr-xr-x 1 crx crx     969 Apr  2 13:35 libsqlite3.la*
lrwxrwxrwx 1 crx crx      19 Apr  2 13:35 libsqlite3.so -> libsqlite3.so.0.8.6*
lrwxrwxrwx 1 crx crx      19 Apr  2 13:35 libsqlite3.so.0 -> libsqlite3.so.0.8.6*
-rwxr-xr-x 1 crx crx 5241068 Apr  2 13:35 libsqlite3.so.0.8.6*
drwxrwxr-x 2 crx crx    4096 Apr  2 13:35 pkgconfig/
```

可以看出`libsqlite3.so.0`符号，软链接到`libsqlite3.so.0.8.6`。在将动态链接库通过串口传输的时候，发现速度很慢，每秒几KB，现在寻求快速将数据传输的方式。

网络传输：在ubuntu的arm_lib下，将文件传输到嵌入式设备

```bash
scp file.txt root@192.168.1.100:/path/to/dest
```

发现ssh并不能连接服务器，应该是设备并没有启动ssh。想偷懒用telnet来访问设备，但是传输速度仍然很慢，原因是：Telnet 是纯文本交互协议（RFC 854），**并非为文件传输设计**

现在只能硬着头皮启动设备的ssh服务了。但是ssh服务也是缺失动态链接库：

```bash
/customer # sshd
/customer/ssh/sbin/sshd: can't load library 'libselinux.so.1'
```

所以尝试用U盘拷贝文件，通过U盘传输给设备。经过操作后已经将文件存放在了`/customer/lib`中。那么接下来怎么才能让程序`collector`运行的时候链接到动态链接库`libselinux.so`呢？

**创建软连接**

将符号`libsqlite3.so.0`软链接到`libsqlite3.so.0.8.6`

```bash
ln -s libsqlite3.so.0.8.6 libsqlite3.so.0
```

**配置动态库加载路径**

临时将新的动态链接路径添加到原有链接路径上

```bash
export LD_LIBRARY_PATH=/customer/lib:$LD_LIBRARY_PATH
```

此时运行程序就成功了

```bash
/customer/new # ./collecter 
Version: 1.3.1-build20231125 
Usage: ./collecter [options]

Options:
 -h | --help                 Print this message
 -s | --start                Start app|collect|forword|agent 
 -t | --stop                 Stop  app|collect|forword|agent
 -u | --status               print share memory info(config conctrl status errorCode)
 -c | --collect              -s or -t setted , start or stop collect 
 -f | --forword              -s or -t setted , start or stop forword 
 -g | --storge               -s or -t setted , start or stop storge 
 -a | --agent                [agent port] -s or -t setted , start or stop agent 
 -i | --fwd_ip               [forword ip]-f setted , set forword dest-ip 
 -p | --fwd_port             [forword port]-f setted , set forword dest-ports 
 -C | --current              printf current value 
 -r | --reset                reset fpga pkg info 
 -V | --version              version 
 -b | --Beat_en              collecter Beat
```

## 4.3

### 重定向

**重定向符号 `>`**：用于将命令的输出重定向到指定的文件或设备。例如，`command > output.txt` 会将 `command` 命令的标准输出重定向到 `output.txt` 文件中。

- **`2>`**：表示将标准错误（文件描述符为 2）进行重定向。
- **`/dev/null`**：是一个特殊的设备文件，也被称为 “黑洞”。任何写入 `/dev/null` 的数据都会被丢弃。因此，`2>/dev/null` 的作用是将 `find` 命令在搜索过程中产生的所有错误信息重定向到 `/dev/null`，从而避免这些错误信息显示在终端上，使输出结果更加简洁，只显示找到的符合条件的文件路径。

所以使用命令

```bash
find / -name "evp.h" 2>/dev/null
```

效果为从根目录开始，在整个文件系统中搜索名为 `evp.h` 的文件，并将搜索过程中产生的错误信息丢弃，只显示找到的文件的路径。

------

### 缺失fuse的交叉编译

报错问题出现在编译镜像的时候：

```bash
tar: /home/crx/ssd2351/source/project/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-12.4.0.tar.gz: Cannot open: No such file or directory
```

经过测试，makefile中并没有对于这个文件的打包。也就是推测这个交叉编译的`fuse`文件是不存在的，现在我们尝试下载其源码，并用交叉编译的方式，编译打包为

```bash
fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-12.4.0.tar.gz
```

#### 下载源码

在目录`Download`下，下载

```bash
wget https://github.com/libfuse/libfuse/releases/download/fuse-2.9.9/fuse-2.9.9.tar.gz
```

#### 解压源码包

```bash
tar -xzvf fuse-2.9.9.tar.gz
```

#### 配置环境

```bash
cd fuse-2.9.9/
./configure --host=arm-sigmastar-linux-uclibcgnueabihf --prefix=/home/crx/work/2351/arm_lib CC=${CROSS_COMPILE}gcc AR=${CROSS_COMPILE}ar RANLIB=${CROSS_COMPILE}ranlib
```

- `export CROSS_COMPILE=arm-sigmastar-linux-uclibcgnueabihf-12.4.0-`：设置交叉编译工具链的前缀。
- `--host=arm-sigmastar-linux-uclibcgnueabihf`：指定目标平台。
- `--prefix=/home/crx/work/2351/arm_lib`：指定安装路径，你可以根据实际情况进行修改。
- `CC=${CROSS_COMPILE}gcc AR=${CROSS_COMPILE}ar RANLIB=${CROSS_COMPILE}ranlib`：指定使用的编译器、归档工具和索引工具。

#### 编译并安装源码

```bash
make
make install
```

今天试着编译2351的uboot和kernel🐱‍👓

### U-Boot 和 Linux 内核

首先理解下两个抽象概念。🐱‍👤

Uboot是板子通电后的第一个运行的程序，负责初始化最基础的硬件（时钟、串口、内存等）。可以实现搬运的功能：将操作系统（例如kernel）从存储设备（SD、flash）搬运到内存中。

Kernel就是操作系统的核心，直接管理所有硬件和软件资源。

U-Boot就是开机助手，Kernel就是系统管家。

### 编译

按照教程将所需的Uboot、Kernel、Project和sdk解压缩至

```bash
~/ssd2351/source
```

在编译之前，检查下makefile是否正确使用了环境变量中的交叉编译工具

```bash
alias armgcc='arm-sigmastar-linux-uclibcgnueabihf-12.4.0-gcc'
```

按照手册的全局编译流程进行编译

```bash
cd ~/ssd2351/source/project/
make dispcam_pcupid.spinand.uclibc-12.4.0-arm-squashfs.ssm001c.128.voip.qfn128_ddr3_defconfig
make clean;make image -j8
```

报错1

```bash
/bin/sh: line 1: flex: command not found
make[4]: *** [scripts/Makefile.lib:214: scripts/kconfig/zconf.lex.c] Error 127
```

安装缺失的`flex`

```bash
sudo apt-get update
sudo apt-get install flex
```

继续执行，报错2

```bash
In file included from tools/aisimage.c:9:
include/image.h:1184:12: fatal error: openssl/evp.h: No such file or directory
 1184 | #  include <openssl/evp.h>
      |            ^~~~~~~~~~~~~~~
compilation terminated.
make[4]: *** [scripts/Makefile.host:112: tools/aisimage.o] Error 1
make[4]: *** Waiting for unfinished jobs....
In file included from tools/atmelimage.c:10:
include/image.h:1184:12: fatal error: openssl/evp.h: No such file or directory
 1184 | #  include <openssl/evp.h>
      |            ^~~~~~~~~~~~~~~
compilation terminated.
```

报错信息为：未能找到 `openssl/evp.h` 文件。`openssl/evp.h` 是 OpenSSL 库的一部分，它包含了很多加密和哈希函数的定义。尝试安装 OpenSSL 开发库

```bash
sudo apt-get update
sudo apt-get install libssl-dev
```

安装完毕再次执行，报错3

```bash
make[7]: Leaving directory '/home/crx/ssd2351/source/project/kbuild/6.1'
/bin/sh: line 1: rename: command not found
```

缺失`rename`，安装（期间又发现了其他的缺失命令，补全即可）

```bash
sudo apt-get update
sudo apt-get install rename
```

再次执行，报错4

```bash
# mount block
echo mount -t tmpfs mdev /dev >> /home/crx/ssd2351/source/project/image/output/rootfs/etc/init.d/rcS
###
###	省略无关代码.....
###
if [ "arm" = "arm" ] && [ "uclibc" = "uclibc" ] && [ "12.4.0" != "" ]; then \
                tar -vxf /home/crx/ssd2351/source/project/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-12.4.0.tar.gz -C /home/crx/ssd2351/source/project/image/output/rootfs/;     \
                tar -vxf /home/crx/ssd2351/source/project/image/firmwarefs-fuse/firmwarefs-fuse-2.2.0-arm-sigmastar-linux-uclibcgnueabihf-12.4.0.tar.gz -C /home/crx/ssd2351/source/project/image/output/rootfs/;       \
        fi;     \
        mkdir -p /home/crx/ssd2351/source/project/image/output/rootfs/misc;\
         python3 /home/crx/ssd2351/source/project/image/makefiletools/script/fwfs_mount.py --flash_type=spinand --block_size=0x20000 --page_size=0x800 --part_size=0x100000 --rcs_dir=/home/crx/ssd2351/source/project/image/output/rootfs/etc/init.d/rcS /dev/mtd9 /misc;\
fi;
tar: /home/crx/ssd2351/source/project/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-12.4.0.tar.gz: Cannot open: No such file or directory
tar: Error is not recoverable: exiting now
tar: /home/crx/ssd2351/source/project/image/firmwarefs-fuse/firmwarefs-fuse-2.2.0-arm-sigmastar-linux-uclibcgnueabihf-12.4.0.tar.gz: Cannot open: No such file or directory
tar: Error is not recoverable: exiting now
```

缺失文件报错。但是这个文件可能是早已存在在文件中的，也有可能是之前的操作步骤中，根据交叉工具链编译打包生成的。我想确认下这个文件怎么缺失的。

我们检查下，在哪个makefile中涉及到了这个解压缩命令。因为这个命令中的交叉编译工具（`arm-sigmastar-linux-uclibcgnueabihf-12.4.0`）很有可能是makefile从环境变量中获取定义的，所以不能通过特定版本的压缩包搜索命令，我转而搜索了此处模块的关键词

```bash
crx@crxVMstation:~/ssd2351/source$ grep -r "echo mount -t tmpfs mdev /dev" .
./project/build_process.log:echo mount -t tmpfs mdev /dev >> /home/crx/ssd2351/source/project/image/output/rootfs/etc/init.d/rcS
./project/image/packaging/common/rootfs_fastboot_nonpm.mk:      echo mount -t tmpfs mdev /dev >> $(OUTPUTDIR)/rootfs/etc/init.d/rcS
./project/image/packaging/common/rootfs.mk:     echo mount -t tmpfs mdev /dev >> ${OUTPUTDIR}/rootfs/etc/init.d/rcS
./project/image/packaging/common/rootfs_fastboot.mk:    echo mount -t tmpfs mdev /dev >> $(OUTPUTDIR)/rootfs/etc/init.d/rcS
./project/image/configs/customize/cardv/rootfs.mk:      echo mount -t tmpfs mdev /dev >> ${OUTPUTDIR}/rootfs/etc/init.d/rcS
```

打开

```bash
vim ./project/image/packaging/common/rootfs.mk
```

查看内容：

```mekefile
# 	........
                if [ "$(ARCH)" = "arm" ] && [ "$(TOOLCHAIN)" = "uclibc" ] && [ "$(TOOLCHAIN_VERSION)" != "" ]; then \
                        tar -vxf $(PROJ_ROOT)/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz -C $(OUTPUTDIR)/rootfs/;    \
                        tar -vxf $(PROJ_ROOT)/image/firmwarefs-fuse/firmwarefs-fuse-2.2.0-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz -C $(OUTPUTDIR)/rootfs/;      \
                fi;     \
                mkdir -p $(OUTPUTDIR)/rootfs/misc;\
                $(foreach block, $(FWFS_MOUNT_BLK), $(PYTHON) $(PROJ_ROOT)/image/makefiletools/script/fwfs_mount.py --flash_type=$(FLASH_TYPE) --block_size=$(FLASH_BLK_SIZE) --page_size=$(FLASH_PG_SIZE) --part_size=$($(block)$(PATSIZE)) --rcs_dir=$(OUTPUTDIR)/rootfs/etc/init.d/rcS $($(block)$(MOUNTPT)) $($(block)$(MOUNTTG));)\
        fi;
```

可以看出解压缩的真实命令为

```makefile
tar -vxf $(PROJ_ROOT)/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz -C $(OUTPUTDIR)/rootfs/; 
tar -vxf $(PROJ_ROOT)/image/firmwarefs-fuse/firmwarefs-fuse-2.2.0-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz -C $(OUTPUTDIR)/rootfs/;
```

所以是以下两个文件缺失

```makefile
$(PROJ_ROOT)/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz
$(PROJ_ROOT)/image/firmwarefs-fuse/firmwarefs-fuse-2.2.0-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz
```

更具体

```makefile
fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz
firmwarefs-fuse-2.2.0-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz
```

接下来就检查是否某个makefile生成过这两个文件：

```bash
crx@crxVMstation:~/ssd2351/source$ grep -r "fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-\$(TOOLCHAIN_VERSION).tar.gz" .
./project/image/definitions.mk:         tar -vxf $(PROJ_ROOT)/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz -C $(1); \
./project/image/packaging/common/rootfs_fastboot_nonpm.mk:                      tar -vxf $(PROJ_ROOT)/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz -C $(OUTPUTDIR)/rootfs/;       \
./project/image/packaging/common/rootfs.mk:                     tar -vxf $(PROJ_ROOT)/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz -C $(OUTPUTDIR)/rootfs/;    \
./project/image/packaging/common/rootfs_fastboot.mk:                    tar -vxf $(PROJ_ROOT)/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz -C $(OUTPUTDIR)/rootfs/;       \
./project/image/configs/customize/cardv/rootfs.mk:                      tar -vxf $(PROJ_ROOT)/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-$(TOOLCHAIN_VERSION).tar.gz -C $(OUTPUTDIR)/rootfs/;       \
```

应该是没有的。然后推测，应该是没有`fuse-2.9.9`当前交叉编译工具链的版本，试着用交叉工具链编译此源码。

编译`fuse-2.9.9`完毕后，我们看下文件的目录结构

```bash
fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-12.4.0.tar.gz
```

其目录结构为

```bash
crx@crxVMstation:~/work/2351/arm_lib/lib$ tar -zxvf /home/crx/ssd2351/source/project/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-11.1.0.tar.gz -C ~/fuse_test/
lib/
lib/libfuse.so.2
lib/libfuse.so.2.9.9
lib/libfuse.so

crx@crxVMstation:~/fuse_test/lib$ ll
total 680
drwxr-xr-x 2 crx crx   4096 Sep  2  2024 ./
drwxrwxr-x 3 crx crx   4096 Apr  3 15:31 ../
lrwxrwxrwx 1 crx crx     16 Sep  2  2024 libfuse.so -> libfuse.so.2.9.9*
lrwxrwxrwx 1 crx crx     16 Sep  2  2024 libfuse.so.2 -> libfuse.so.2.9.9*
-rwxr-xr-x 1 crx crx 684760 Sep  2  2024 libfuse.so.2.9.9*
```

可以看出其目录`lib`下存放的是动态链接库及其软连接。

然后我们将编译好的`fuse`的`lib`下的文件打包好。

```bash
crx@crxVMstation:~/work/2351/arm_lib/lib$ cp -d libfuse.so libfuse.so.2 libfuse.so.2.9.9 ./lib
```

`-d`选项会保存之前的软连接。查看无误：

```bash
crx@crxVMstation:~/work/2351/arm_lib/lib/lib$ ll
total 712
drwxrwxr-x 2 crx crx   4096 Apr  3 15:40 ./
drwxrwxr-x 4 crx crx   4096 Apr  3 15:37 ../
lrwxrwxrwx 1 crx crx     16 Apr  3 15:38 libfuse.so -> libfuse.so.2.9.9*
lrwxrwxrwx 1 crx crx     16 Apr  3 15:38 libfuse.so.2 -> libfuse.so.2.9.9*
-rwxr-xr-x 1 crx crx 720576 Apr  3 15:38 libfuse.so.2.9.9*
```

将`lib/`打包到指定位置

```bash
tar -zcvf /home/crx/ssd2351/source/project/image/fuse/fuse-2.9.9-arm-sigmastar-linux-uclibcgnueabihf-12.4.0.tar.gz lib/
```

同理缺失的文件`firmwarefs-fuse-2.2.0`也是相同的源码交叉编译流程，存放到指定位置。但是由于网络上并没有此文件的源码，所以直接终止。

------

## 4.7

今天开始做原子钟的相关开发，阅读手册的定义，今天目标就是搞清楚源码中的定义是从哪里来的。

阅读《Microchip_CSAC_UserGuide》的记录

### Chapter 2. Functional Description

- 本书不会讲解原理，只讲应用

#### 启动顺序

- 通电（电源连接至7号口时）时，执⾏⼀个采集序列状态从 8（烤箱预热）开始。状态值在采集过程中逐渐减⼩，直到实现正常运⾏（状态 = 0）。在极少数情况 下，状态倒计时将在采集期间重置。如果它不⼲扰预热规范时间，这是正常⾏
- csac没有反向电压保护，注意将电源连接至正确的端口VCC接口-7号
- 通电后，BITE 立刻会有输出信号，但是不会稳定（在振荡器锁定之前）。3分钟锁定后，稳定输出BITE = 0
- BITE = 0 后，要保持开机102s以上。

### Chapter 3. Programmer’s Reference

- 接口：波特率：57600、8bits、没有奇偶校验

- 输入命令格式：以`!`开头，以`\r\n`（ASCII 0X0D 0x0A）结尾的ASCII码

  ```C
  !$(command)\r\n
  ```

- 响应格式：`response[CRLF]`

- 可靠性：当模式寄存器的第 6 位（`0x0040`）被设置时，启用 NMEA 风格的校验和。此时输入的命令格式必须为`!$(command)$(*checksum)[CRTL]`

  输入的`command`要以每个字符的十六进制进行抑或处理（不包括开头的`!`和末尾`\r\n`），最终成为一个包含 2 字节的校验和

  校验和`checksum`以 `*` 字符开头，紧跟在命令后面，在 `[CRLF]` 之前。

  举例：

  ```bash
  Example (enable analog tuning through mode register):
  Command: !MA*0C[CRLF]
  Unit response: 0x0041*4D[CRLF]
  ```

  输入命令`MA`，两个字符的ASCII码为`0x4D`和`0x41`。其抑或结果为`0x4d ^ 0x41 = 0x0C`，所以命令就以`!MA*0C[CRLF]`传输。

  设备返回的结果为`0x0041`，其所有字符，即 `0`、`x`、`0`、`0`、`4`、`1`。运算结果为`0x4D`

  ```txt
  0x30 ^ 0x78 ^ 0x30 ^ 0x30 ^ 0x34 ^ 0x31
  = (0x30 ^ 0x78) ^ 0x30 ^ 0x30 ^ 0x34 ^ 0x31
  = 0x48 ^ 0x30 ^ 0x30 ^ 0x34 ^ 0x31
  = 0x78 ^ 0x30 ^ 0x34 ^ 0x31
  = 0x48 ^ 0x34 ^ 0x31
  = 0x7C ^ 0x31
  = 0x4D
  ```

  如果输入的校验和错误或者不存在，则命令`command`不会被执行，并且会返回`*[CRLF]`。举例：

  ```txt
  Example (malformed checksum):
  Command: !Mc*2D[CRLF]
  Unit response: *[CRLF]
  ```

### makefile解析

拿runclock的makefile举例，学点有意思的

```bash
TARGET_NAME=collecter
PKG_VERSION:=1.3.1
PKG_BUILD_TIME=$(shell date "+%Y%m%d")
# CC      = /home/ctool/zlg_gcc/gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux/bin/arm-linux-gnueabihf-gcc
CROSS_COMPILE ?= arm-sigmastar-linux-uclibcgnueabihf-12.4.0-
CC = $(CROSS_COMPILE)gcc
CFLAGS  = -Wall -std=gnu99 -fPIC -g -I. -I../collecter/uart -I../collecter/app -I../collecter/i2c -I../collecter/dev -I../common -I../arm_include -I../three_src -I../ad7768

files = main.c ruclock.c
files += $(wildcard ../collecter/uart/*.c)


THIS_OBJS = $(patsubst %.c, %.o,$(wildcard $(files)))

LIBADDS  = -L../arm_lib -lpthread -lrt -lsqlite3

default:$(TARGET_NAME)
	echo "#define COLLECT_VERSION \"$(PKG_VERSION)-build$(PKG_BUILD_TIME)\"" > ./version.h
	echo $(PKG_VERSION)-build$(PKG_BUILD_TIME) > collecter_ver

$(TARGET_NAME):$(THIS_OBJS)
	$(CC) $(LIBADDS) $(THIS_OBJS) -o $(TARGET_NAME)

clean:
	rm $(THIS_OBJS) $(TARGET_NAME)

.PHONY: clean install
```

- `files += $(wildcard ../collecter/uart/*.c)`：给`files`变量附加上`../collector/uart`目录下的所有`.c`文件。`wildcard` 函数，能够自动获取符合特定模式的文件列表
- `THIS_OBJS = $(patsubst %.c, %.o,$(wildcard $(files)))`：这行代码使用 `patsubst` 函数将 `files` 中的所有 `.c` 文件替换为 `.o` 文件

### Ubuntu网络连接设备

当前Ubuntu的ip配置如下

```bash
crx@crxVMstation:~/work/2351/app/ruclock$ ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.1.13  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 240e:3a2:1371:4420:a46b:e51c:d12e:7b1d  prefixlen 64  scopeid 0x0<global>
        inet6 fe80::20c:29ff:fef0:2922  prefixlen 64  scopeid 0x20<link>
        inet6 240e:3a2:1371:4420:20c:29ff:fef0:2922  prefixlen 64  scopeid 0x0<global>
        ether 00:0c:29:f0:29:22  txqueuelen 1000  (Ethernet)
        RX packets 570590  bytes 327626756 (327.6 MB)
        RX errors 0  dropped 9963  overruns 0  frame 0
        TX packets 253439  bytes 70137083 (70.1 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

而现在我需要连接上的硬件设备的网络配置为

```bash
eth1      Link encap:Ethernet  HWaddr 00:14:97:60:E0:81
          inet addr:10.1.2.140  Bcast:10.255.255.255  Mask:255.0.0.0
          inet6 addr: fe80::214:97ff:fe60:e081/64 Scope:Link
          inet6 addr: 240e:3a2:1371:4420:214:97ff:fe60:e081/64 Scope:Global
          UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1500  Metric:1
          RX packets:132553 errors:0 dropped:1 overruns:0 frame:0
          TX packets:1729 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:10980663 (10.4 MiB)  TX bytes:217414 (212.3 KiB)
```

我该怎么配置自己的Ubuntu网络才能连接上此设备呢？TODO

### ruclock代码编译

#### clean删除头头文件

首先，执行

```bash
crx@crxVMstation:~/work/2351/app/ruclock$ make clean
rm  main.o  ruclock.o ruclock.h  ../collecter/uart/uart_x.o collecter
rm: cannot remove 'collecter': No such file or directory
make: *** [Makefile:24: clean] Error 1
```

执行完清理命令后，它居然将我的`ruclock.h`清理了，检查makefile关于清理的命令

```makefile
files = main.c ruclock.c ruclock.h
THIS_OBJS = $(patsubst %.c, %.o,$(wildcard $(files)))

default:$(TARGET_NAME)
	echo "#define COLLECT_VERSION \"$(PKG_VERSION)-build$(PKG_BUILD_TIME)\"" > ./version.h
	echo $(PKG_VERSION)-build$(PKG_BUILD_TIME) > collecter_ver

$(TARGET_NAME):$(THIS_OBJS)
	$(CC) $(LIBADDS) $(THIS_OBJS) -o $(TARGET_NAME)
	
clean:
	rm $(THIS_OBJS) $(TARGET_NAME)
```

从 `Makefile` 代码来看，`$(THIS_OBJS)` 是通过 `$(patsubst %.c, %.o,$(wildcard $(files)))` 生成的，它应该只包含 `.o` 文件，`$(TARGET_NAME)` 通常是可执行文件，所以理论上不会包含 `ruclock.h`。问题可能出在 `$(files)` 变量的定义上。

查看`$(file)`的定义

```makefile
files = main.c ruclock.c ruclock.h
```

问题就出在 `files` 变量的定义上， `ruclock.h` 也包含进去了。`THIS_OBJS` 是通过 `$(patsubst %.c, %.o,$(wildcard $(files)))` 来生成目标文件列表的，由于 `ruclock.h` 不是 `.c` 文件，所以在模式替换时它不会被转换为 `.o` 文件，而是保持原样。这样在执行 `clean` 规则时，`rm` 命令就会尝试删除 `ruclock.h`。

将`files`变量中的`ruclock.h`参数删除就OK了。

#### 链接

链接报错

```bash
arm-sigmastar-linux-uclibcgnueabihf-12.4.0-gcc -L../arm_lib -lpthread -lrt -lsqlite3  main.o  ruclock.o  ../collecter/uart/uart_x.o -o collecter
/home/crx/ssd2351/tool/toolchain/arm-sigmastar-linux-gcc-12.4.0-uclibc-1.0.46-gnueabihf/bin/../lib/gcc/arm-unknown-linux-uclibcgnueabihf/12.4.0/../../../../arm-unknown-linux-uclibcgnueabihf/bin/ld: ../collecter/uart/uart_x.o: in function `set_error_code':
/home/crx/work/2351/app/ruclock/../collecter/app/commondef.h:83: undefined reference to `g_error_group'
```

链接器在处理 `../collecter/uart/uart_x.o` 文件时，在 `set_error_code` 函数里找不到对 `g_error_group` 的定义。

此函数定义在`../collecter/app/commondef.h`中

```C
static inline void set_error_code(int errid, int errcode)
{
	if(g_error_group){
		if(errid==e_err_group_app){
            g_error_group->app_err_curr_id++;
			g_error_group->app_err_curr_id %= MAX_APP_ERR_QUEUE;
			g_error_group->errcode[e_err_group_app+g_error_group->app_err_curr_id] = errcode;
		}else{
			g_error_group->errcode[errid%e_err_group_app] = errcode;
		}
	}
}
```

找不到对于变量`g_error_group`的定义。这是由于变量`g_error_group`定义在文件`../collecter/app/app.c`中

```c
T_error_group *g_error_group = NULL;
```

但是编译文件的时候，并没有将定义`g_error_group`变量的`app.c`编译，导致了找不到变量的定义。尝试在makefile中加入`app.c`的编译

```makefile
files = main.c ruclock.c
files += $(wildcard ../collecter/uart/*.c)
```

但是加入后继续报错

```bash
arm-sigmastar-linux-uclibcgnueabihf-12.4.0-gcc -L../arm_lib -lpthread -lrt -lsqlite3  main.o  ruclock.o  ../collecter/uart/uart_x.o  ../collecter/app/app.o -o collec
ter
/home/crx/ssd2351/tool/toolchain/arm-sigmastar-linux-gcc-12.4.0-uclibc-1.0.46-gnueabihf/bin/../lib/gcc/arm-unknown-linux-uclibcgnueabihf/12.4.0/../../../../arm-unkno
wn-linux-uclibcgnueabihf/bin/ld: ../collecter/app/app.o: in function `main':
/home/crx/work/2351/app/ruclock/../collecter/app/app.c:1320: multiple definition of `main'; main.o:/home/crx/work/2351/app/ruclock/main.c:22: first defined here
/home/crx/ssd2351/tool/toolchain/arm-sigmastar-linux-gcc-12.4.0-uclibc-1.0.46-gnueabihf/bin/../lib/gcc/arm-unknown-linux-uclibcgnueabihf/12.4.0/../../../../arm-unkno
wn-linux-uclibcgnueabihf/bin/ld: ../collecter/app/app.o: in function `led_set':
```

重复定义了`main`函数。`app.c`中也有`main`函数。那就现在暂时将所需的变量声明在`ruclock/main.c`中（TODO：优化代码逻辑）

```C
/**
 * TODO:临时存放 commondef.h所需要的变量
 */
T_error_group *g_error_group = NULL;
T_stat_group *g_stat_group = NULL; 
T_app_cfgctrl *g_app_cfgctrl = NULL;
uint8_t * g_log_f_blk_buff = NULL;
char * g_log_s_blk_buff = NULL;
uint8_t *g_adjust_rcv_buf = NULL;
struct time_collect_tab *head;
struct time_collect_tab *prev, *current;
sqlite3 *db;
```

此时编译即可通过。

#### 执行

在设备上执行

```bash
[root@VUSR tmp]# pwd
/tmp/tmp
[root@VUSR tmp]# ./collecter
-sh: ./collecter: not found
```

经过测试，发现是缺少动态链接库。随后将makefile设置为静态编译和链接，再次运行

```bash
[root@VUSR tmp]# ./collecter
[root@VUSR tmp]#
```

为什么什么都没做呢？此时要分析main函数的功能了。

### 代码分析

#### 阻塞串口设备

在 uartx_init 函数中，有一条将文件设置为阻塞模式的代码

```C
/* set blocking mode */
ret = fcntl(s_uart_dev[id].fd, F_SETFL, 0);
```

此代码的作用是将串口I/O操作变为同步阻塞，适合简单场景。在对文件进行写入操作时，阻塞模式会确保数据被完整地写入文件系统。阻塞模式的特点可以通过观察`read()`和`write()`在阻塞模式下的行为来理解。

- `read()`：如果缓冲区有数据，立即返回数据。如果无数据，则程序挂起，直到数据到达（串口收到数据）、发生错误、超时
- `write()`：缓冲区可写，立即写入；如果缓冲区已满，则挂起程序直到缓冲区有空间。

阻塞后，线程挂起，不占用 CPU。这样程序简单可靠。

## 4.8

今天继续代码分析和文档阅读。要学习的函数：

- `getopt_long()`：解决`strcpy(wr_buf, *(argv+2))`在解析`-r2`的时候报错`Segmentation fault`
- `open()`：以只读模式打开文件并读取内容；以读写模式打开文件，若文件不存在则创建

### Linux权限表示方法

- **数字表示法**：如 `0644`，将每种用户的权限用数字表示，然后组合在一起。`r` 对应 `4`，`w` 对应 `2`，`x` 对应 `1`，将每种用户的权限相加得到对应的数字。例如，`rwx` 权限对应的数字是 `7`（`4 + 2 + 1`）。
- **符号表示法**：例如 `rw-r--r--`，用 `r`、`w`、`x` 分别表示读、写、执行权限，`-` 表示没有相应权限，依次表示文件所有者、所属组和其他用户的权限。

### sizeof运算符

`sizeof`是C语言中的一个重要运算符（不是函数），用于计算数据类型或对象在内存中所占的字节数。用途：

- 计算基本数据类型大小

  ```C
  printf("int size: %zu bytes\n", sizeof(int));
  printf("double size: %zu bytes\n", sizeof(double));
  ```

- 计算变量的大小

  ```C
  int num;
  printf("num size: %zu bytes\n", sizeof(num));
  ```

- 计算数组大小

  ```C
  int arr[10];
  printf("arr size: %zu bytes\n", sizeof(arr));  // 返回整个数组的大小
  printf("arr element count: %zu\n", sizeof(arr)/sizeof(arr[0]));  // 计算数组元素个数
  ```

- 计算指针本身的大小而不是指向数据的大小

  ```C
  int *ptr;
  printf("%zu\n", sizeof(ptr));  // 返回指针大小（通常4或8字节），不是int大小
  ```

- 计算包含终止符的字符串长度

  ```C
  printf("%zu\n", sizeof("hello"));  // 返回6（包括'\0'）
  printf("strlen(\"hello\") = %zu\n", strlen("hello"));   // 返回 5(不包括'\0')
  ```

- 字符数组

  ```C
  char arr[] = "Hello World";
  printf("数组大小: %zu\n", sizeof(arr));  // 输出12（包括'\0'）
  ```

### write函数

在使用`write`函数向文件中写入字符串时，写入的长度通常是字符串的实际长度，不包括字符串结束符`'\0'`。例如

```C
const char *data = "这是写入的测试数据。";
bytes_written = Write(fd, buf, strlen(data));
```

### getopt_long获取多个参数

函数原型是

```C
#include <getopt.h>

int getopt_long(int argc, char * const argv[], const char *optstring,
                const struct option *longopts, int *longindex);
```

其中 `optarg` 和 `optind` 是两个非常重要的外部变量，用于获取参数信息和控制解析过程。

#### optarg

- 基本作用：指向当前选项的参数值，是一个`char *`类型的全局变量。例如`-w 123`，如果`-w`为选项，则参数值`optarg = "123"`

- 使用场景：当选项需要参数时（在选项字符串中用 `:` 或 `::` 指定）

  - 对于短选项

    ```bash
    ./program -f filename
    ```

    解析选项`-f`时，`optarg` 指向 `"filename"`

  - 对于长选项：

    ```bash
    ./program --file=filename
    ```

    解析 `--file` 时，`optarg` 指向 `"filename"`

#### optind

- 基本作用：`optind` 是一个 `int` 类型的全局变量，表示 `argv` 数组中下一个要处理的元素的索引

- 特性：

  - **初始值**：默认为 1（跳过程序名）
  - **自动更新**：`getopt_long` 会自动更新它
  - **解析完成后**：指向第一个非选项参数的位置

- 示例场景

  对于命令

  ```bash
  ./program -f file.txt input1 input2
  ```

  解析完成后：

  - `optind` 将指向 `input1` 的位置（假设是索引 3）
  - `argv[optind]` 是 `"input1"`
  - `argv[optind + 1]` 是 `"input2"`

如果想获取两个参数：

```bash
./program -f file1.txt file2.txt
```

里面的`file1.txt`和 `file2.txt`，可以使用如下方法

```C
case 'f':
	if (optind < argc) {
		strncpy(file1, argv[optind - 1], sizeof(wr_buf) - 1);
		strncpy(file2, argv[optind], sizeof(value) - 1);
        optind++;
	} else {
		printf("error: please write 2 params!\n");
		return -1;
	}
```

但是长命令就需要单独处理了。(todo)

### 宏定义

```C
#define CRLF  "\n\n"
#define STRING_CONCAT(x, y) x y
#define   TELEMETRY_HEAD 		  STRING_CONCAT("!6", CRLF)
```

这样就实现了`CRLF`字符串的复用，降低了代码的耦合度。

### strncpy和memcpy

```C
void testCpy() {
    char str[] = "abcdef";

    char dest[100] = "0123456789";
    memcpy(dest, str, 3);

    char dest2[100] = "0123456789";
    strncpy(dest2, str, 3);
    printf("dest = %s, strlen(dest) = %d\n", dest, strlen(dest));
    printf("dest2 = %s, strlen(dest2) = %d\n", dest2, strlen(dest2));
}
```

输出为：

```BASH
dest = abc3456789, strlen(dest) = 10
dest2 = abc3456789, strlen(dest2) = 10
```

- **`strncpy`**：主要用于复制字符串，它会从源字符串 `src` 复制最多 `n` 个字符到目标字符串 `dest` 中。常用于处理字符串的部分复制，或者在需要控制复制字符数量的场景中使用。
- **`memcpy`**：用于在内存之间进行数据的复制，它可以复制任意类型的数据，不仅仅局限于字符串。常用于复制数组、结构体等数据结构。

### 复制规则

- **`strncpy`**：
  - 当源字符串 `src` 的长度小于 `n` 时，`strncpy` 会将 `src` 中的字符复制到 `dest` 中，然后在 `dest` 后面填充 `'\0'` 直到复制满 `n` 个字符。
  - 当源字符串 `src` 的长度大于等于 `n` 时，`strncpy` 只会复制 `n` 个字符到 `dest` 中，不会自动添加字符串结束符 `'\0'`。这意味着如果需要将 `dest` 作为字符串使用，可能需要手动添加 `'\0'`。
- **`memcpy`**：会精确地复制 `n` 个字节的数据从源内存区域 `src` 到目标内存区域 `dest`，不考虑数据的类型和内容。它不会对数据进行额外的处理，如添加字符串结束符等。

### Ubuntu配置SVN1（失败版本）

要将`/home/crx/work/2351/app`的所有文件提交到

```txt
https://NJ-LINGYUN/svn/4CHs_MYZR/sources/apps
```

安装完毕后，在`app/`目录下执行检出命令，不指定本地目录路径，代码会被检出到当前目录下以仓库名命名的文件夹中。

```bash
svn co https://NJ-LINGYUN/svn/4CHs_MYZR/sources/apps
```

报错

```bash
crx@crxVMstation:~/work/2351/app$ svn co https://NJ-LINGYUN/svn/4CHs_MYZR/sources/apps
svn: E170013: Unable to connect to a repository at URL 'https://NJ-LINGYUN/svn/4CHs_MYZR/sources/apps'
svn: E000104: Error running context: Connection reset by peer
```

经过调查，发现在Ubuntu上

```bash
ping NJ-LINGYUN
```

不通，但是在windows主机上就能ping通。经过实践，在`/etc/hosts`中加入

```txt
192.168.1.35 NJ-LINGYUN
```

就可以访问了。这是什么原理？看看豆包的回答：

> 在 `hosts` 文件中配置了 `192.168.1.35 NJ - LINGYUN` 后就能连接上，是因为 `hosts` 文件起到了域名解析的作用。
>
> 在计算机网络中，当你使用一个域名（如 `NJ - LINGYUN`）来访问网络资源时，计算机需要将这个域名转换为对应的 IP 地址（如 `192.168.1.35`），这个过程称为域名解析。通常情况下，计算机首先会查询本地的 `hosts` 文件来进行域名解析，如果在 `hosts` 文件中找到了对应的域名和 IP 地址映射关系，就会直接使用该 IP 地址来建立连接，而不会再去查询其他的域名解析服务器。
>
> 在你配置 `hosts` 文件之前，计算机无法将 `NJ - LINGYUN` 解析为正确的 IP 地址，导致无法连接到目标服务器。而通过在 `hosts` 文件中手动添加了 `NJ - LINGYUN` 与 `192.168.1.35` 的映射关系后，计算机就能够正确地将域名解析为服务器的 IP 地址，从而成功建立连接，访问到相应的 SVN 资源。

那么为啥在windows主机上就能ping通呢？我也没配置啊。豆包回答

> - Windows 系统通过网络邻居来发现和识别局域网中的其他设备。当计算机接入局域网后，会通过广播消息来宣告自己的存在，其他计算机接收到这些广播信息后，就可以在网络邻居中看到该计算机。在这个过程中，Windows 会自动记录这些设备的名称和 IP 地址对应关系，所以当你 ping 一个局域网内的计算机名时，Windows 可能已经通过这种广播机制获取了目标计算机的 IP 地址，从而能够成功 ping 通。

然后提交代码

```bash
svn add . --force
```

提交远程

```bash
svn commit -m "提交说明，简要描述此次提交的内容"
```

## 4.9

任务todo：

- 将svn忽略的`.so`文件提交到远程端，并且加入对于vscode配置文件`.vscode/`的屏蔽

### 修改SVN的忽略规则

将svn忽略的`.so`文件提交到远程端，并且加入对于vscode配置文件`.vscode/`的屏蔽

#### 检查全局忽略规则

SVN 的全局忽略规则，这些规则通常在 `~/.subversion/config` 文件中设置。你可以按以下步骤操作：

```bash
crx@crxVMstation:~$ cat ~/.subversion/config | grep global-ignores
### Set global-ignores to a set of whitespace-delimited globs
# global-ignores = *.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a *.pyc *.pyo __pycache__
```

输出包含 `.so` 或者类似 `*.so` 的规则，就表示全局忽略规则中设置了忽略 `.so` 文件。

**移除全局忽略规则中的 `.so` 规则**：

使用文本编辑器打开 `~/.subversion/config` 文件。找到 `global-ignores` 这一行，删除其中包含 `.so` 的部分。加入忽略规则`.vscode`。

```bash
global-ignores = *.o *.lo *.la *.al *.pyc *.pyo __pycache__ .vscode
```

设置完成后，之后在使用 SVN 进行操作时，`.vscode` 目录就会被自动忽略。

#### 上传忽略的`.so`文件

进入工作目录，检查工作副本的状态

```BASH
crx@crxVMstation:~/work/2351/app$ pwd
/home/crx/work/2351/app
crx@crxVMstation:~/work/2351/app$ svn status
?       apps
?       arm_lib/libev.a
?       arm_lib/libev.so
?       arm_lib/libev.so.4
?       arm_lib/libev.so.4.0.0
?       arm_lib/libfftw3.a
?       arm_lib/libpcap.so
?       arm_lib/libsqlite3.a
?       arm_lib/libsqlite3.so
?       arm_lib/libsqlite3.so.0.8.6
?       arm_lib/libsqlite3.so.0.8.6_backup
?       arm_lib/libuhttpd.so
?       arm_lib/libuhttpd.so.3.12.1
?       arm_lib/uhttpd/test_plugin.so
```

可以看出这些文件和目录未被 SVN 管理。那我们现在将`.so`先加入到 SVN 管理

```bash
crx@crxVMstation:~/work/2351/app$ svn add . --force
A  (bin)  arm_lib/libev.so.4
A  (bin)  arm_lib/libsqlite3.so.0.8.6_backup
A  (bin)  arm_lib/libpcap.so
A  (bin)  arm_lib/libsqlite3.a
A  (bin)  arm_lib/libsqlite3.so
A  (bin)  arm_lib/libfftw3.a
A  (bin)  arm_lib/libuhttpd.so.3.12.1
A  (bin)  arm_lib/libsqlite3.so.0.8.6
A  (bin)  arm_lib/uhttpd/test_plugin.so
A  (bin)  arm_lib/libuhttpd.so
A  (bin)  arm_lib/libev.so.4.0.0
A  (bin)  arm_lib/libev.a
A  (bin)  arm_lib/libev.so
```

#### 删除对于`.vscode`的管理

然后删除app和ruclock目录下的`.vscode`

```bash
crx@crxVMstation:~/work/2351/app$ svn delete .vscode
D         .vscode
D         .vscode/c_cpp_properties.json
D         .vscode/settings.json
D         .vscode/tasks.json
crx@crxVMstation:~/work/2351/app$ cd ruclock/
crx@crxVMstation:~/work/2351/app/ruclock$ svn delete .vscode/
D         .vscode
D         .vscode/c_cpp_properties.json
D         .vscode/settings.json
```

此时查看 SVN 项目管管理情况

```bash
crx@crxVMstation:~/work/2351/app$ svn status
D       .vscode
?       apps
A       arm_lib/libev.a
A       arm_lib/libev.so
A       arm_lib/libev.so.4
A       arm_lib/libev.so.4.0.0
A       arm_lib/libfftw3.a
A       arm_lib/libpcap.so
A       arm_lib/libsqlite3.a
A       arm_lib/libsqlite3.so
A       arm_lib/libsqlite3.so.0.8.6
A       arm_lib/libsqlite3.so.0.8.6_backup
A       arm_lib/libuhttpd.so
A       arm_lib/libuhttpd.so.3.12.1
A       arm_lib/uhttpd/test_plugin.so
D       ruclock/.vscode
```

发现已经可以了。

那么对于单独项目，如何单独配置忽略文件呢？现在重新写一篇关于 Ubuntu 环境下的 SVN 设置

### Ubuntu配置 SVN（True版本）

记录下如何配置 SVN

#### 概览

👻看完后你能实现什么：

- Ubuntu 零环境配置 SVN（网上一搜一大把）
- 如何连接局域网内的 SVN 服务器
- 如何配置全局和局部的忽略规则

#### 安装 SVN 客户端

```bash
sudo apt update
sudo apt install subversion
```

####  检出代码

把存储在远程 SVN 服务器上的项目代码完整地复制一份到本地计算机的指定目录中。不指定本地目录路径，代码会被检出到当前目录下以仓库名命名的文件夹中。

```C
svn co https://NJ-LINGYUN/svn/test/
```

##### 域名解析

但是这里会报错

```bash
crx@crxVMstation:~/work/2351/app$ svn co https://NJ-LINGYUN/svn/test/
svn: E170013: Unable to connect to a repository at URL 'https://NJ-LINGYUN/svn/test/'
svn: E000104: Error running context: Connection reset by peer
```

具体原因是由于linux上并没有域名`NJ-LINGYUN`的域名解析规则。从而导致解析不了域名对应的IP地址。

解决办法就是在`/etc/hosts`中加入

```txt
192.168.1.35 NJ-LINGYUN
```

这样就可以测试通过了。

```bash
crx@crxVMstation:~/work/2351/test/testCheckout$ svn co https://NJ-LINGYUN/svn/test/
Authentication realm: <https://nj-lingyun:443> VisualSVN Server
Password for 'crx': ******

A    test/a.so
A    test/b.txt
 U   test
Checked out revision 2.

crx@crxVMstation:~/work/2351/test/testCheckout$ ll
total 12
drwxrwxr-x 3 crx crx 4096 Apr  9 11:40 ./
drwxrwxr-x 7 crx crx 4096 Apr  9 11:40 ../
drwxrwxr-x 3 crx crx 4096 Apr  9 11:40 test/
```

这样在`testCheckout\`目录下就下载了服务器上的`test\`下的文件。

下面是上传文件前要配置的内容（**重要**）

#### 全局忽略规则

SVN 会全局自动屏蔽一些文件的上传，例如重要的动态链接库和静态库（`.so`和`.a`）。这些规则通常在 `~/.subversion/config` 文件中设置

我们需要配置 SVN 的全局忽略文件来 **解除/加入** 对某种文件的屏蔽。

```bash
crx@crxVMstation:~/work/2351/test/testCheckout/test$ cat ~/.subversion/config | grep global-ignores
### Set global-ignores to a set of whitespace-delimited globs
# global-ignores = *.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a *.pyc *.pyo __pycache__
```

可以看到此时全局忽略规则默认的会忽略所有的动态链接库和静态链接库文件，我们将其修改为

```bash
crx@crxVMstation:~/work/2351/test/testCheckout/test$ cat ~/.subversion/config | grep global-ignores
### Set global-ignores to a set of whitespace-delimited globs
# global-ignores = *.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a *.pyc *.pyo __pycache__
global-ignores = *.o *.lo *.la *.al *.pyc *.pyo __pycache__ .vscode
```

将前面的注释拿掉后，删除对于目标类型文件（`*.so *.so.[0-9]* *.a `）的忽略规则，加入屏蔽的类型文件规则（`.vscode`）。

配置完全局变量后，在`test/`测试目录下，新建`.vscode/`目录，测试是否屏蔽成功

```bash
crx@crxVMstation:~/work/2351/test/testCheckout/test$ mkdir .vscode
crx@crxVMstation:~/work/2351/test/testCheckout/test$ svn status
crx@crxVMstation:~/work/2351/test/testCheckout/test$ mkdir mmk
crx@crxVMstation:~/work/2351/test/testCheckout/test$ svn status
?       mmk
```

可以看到已经屏蔽了`.vscode`的目录，而对于其他目录并不会屏蔽。同理新增`b.so`，新增后查看svn状态

```bash
crx@crxVMstation:~/work/2351/test/testCheckout/test$ svn status
?       b.so
?       mmk
```

也可以正确提交`b.so`了。下面是单独配置某个项目下的忽略规则

#### 局部忽略规则

例如此时我在项目下创建了一个`test.log`日志文件，不想上传的话，可以通过配置项目的局部忽略规则。

首先在项目的根目录下，创建一个`.svnignore`文件，加入此项目对于生成的`*.log`文件进行屏蔽

```bash
crx@crxVMstation:~/work/2351/test/testCheckout/test$ cat .svnignore
*.log
```

随后将配置文件的规则加入 SVN 的忽略规则上

```bash
svn propset svn:ignore -F .svnignore .
```

此时应用就成功了。此项目不会将`*.log`文件提交到svn服务器了。

### 调试`!6[CRLF]`

根据手册，向嵌入式外设输入`!6[CRLF]`的时候，会输出

```bash
Unit response: Status,Alarm,SN,Mode,Contrast,LaserI,
TCXO,HeatP,Sig,Temp,Steer,ATune,Phase,DiscOK, 
TOD,LTime,Ver[CRLF]
```

但是现在函数的逻辑，输入命令后只会读取到

```bash
[root@VUSR tmp]# ./collecter  -r 6
WRITE_READ_RUCLOCK: recv_n = 16, recv_n = Status,Alarm,SN,
WRITE_READ_RUCLOCK: recv_n = 16, recv_n = Status,Alarm,SN,Mode,Contrast,La
WRITE_READ_RUCLOCK: recv_n = 16, recv_n = Status,Alarm,SN,Mode,Contrast,LaserI,T                                                                                CXO,HeatP,
WRITE_READ_RUCLOCK: recv_n = 16, recv_n = Status,Alarm,SN,Mode,Contrast,LaserI,T                                                                                CXO,HeatP,Sig,Temp,Steer,A
timeout: didn't receive \r\n
```

可以推断的是，当前读取嵌入式外设的逻辑有问题。文字尚未读取完毕，就已经停止了读写。我们看下代码，分析如何解决这个问题

```C
int times = 3;
// 获取响应
  do {
        recv_n = uartx_recv(UART2, (uint8_t *)(recv_buf + len), sizeof(recv_buf) - len);
        printf("WRITE_READ_RUCLOCK: recv_n = %d, recv_n = %s\n", recv_n, recv_buf);

        // 校验输出结果是否合法
        if (recv_n > 0 && is_last_two_chars_crlf(recv_buf + len, recv_n)) {
          printf("valid response!\n");
          remove_end_crlf_in_string(recv_buf + len, recv_n, response);
          
          printf("recv_buf = %s[CTRL]\n", response);
          return recv_n;
        }
        if (times-- <= 0) {
            printf("timeout: didn't receive \\r\\n\n");
            return -2;
        }
        len += recv_n;
  } while (1);
```

可以看出，代码的`while`循环首先会分3次获取响应数据，并且将响应结果补充到`recv_buf`后面。并且当外设输出完毕，即最后两个字符为`[CTRL]`的时候，就会将`recv_buf`的响应数据复制到`response`中。

## 4.10

现在何总带着铷钟的开发板跑了，铷钟的开发中断了。

### 开发板缺失

现在存在的问题：开发的铷钟交互程序ruclock，是通过嵌入式设备读取/写入铷钟设备的数据来交互的。但是现在开发板不存在，无法与铷钟设备进行交互。

现在已知的是有一个相同的开发板2351运行相同的OS（相同的编译环境），运行环境正常，那我是否应该写一个铷钟外设的模拟器，通过模拟器来与ruclock交互查看问题？而且我还有铷钟外设的API手册，可以准确模拟设备的接口和行为。

如果要开发铷钟外设模拟器，我是要通过程序间的通信进行测试；还是将模拟器放在ruclock目录下，作为编译的一部分跟ruclock一起编译进行测试呢？

现在基本可以确定，不需要这样修改。

原因是开发周期太久，没法做到跟web后端及时调试的效果。所以现在优先解决其他问题。

### WRITE_READ_RUCLOCK问题

当前存在的问题：

- `uartx_init(UART2)`函数存在阻塞风险
- 获取响应时，如果铷钟阻塞会导致`read()`时阻塞
- 获取响应时，如果铷钟无数据会导致进程卡死

### `uartx_init()`函数优化

#### 业务逻辑分离

优化几个包装函数，将函数及其错误处理包含到一个函数中，抽象逻辑。设想是类似

```C
void collector_error(char *msg) /* Unix-style error */
{
	ERR_LOG("open %s failed!\n", s_uart_dev[id].dev);
	set_error_code(e_err_group_uart+id ,e_ec_uart_open_dev_failed);
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    exit(0);
}

int Open(const char *pathname, int flags, mode_t mode) {
    int rc;
    if ((rc = (open(pathname, flags, mode))) < 0) {
        collector_error("Open error");
    }
    return rc;
}

    s_uart_dev[id].fd = open(s_uart_dev[id].dev, O_RDWR|O_NOCTTY|O_NDELAY);
    if (s_uart_dev[id].fd == -1) {
        printf("open %s failed!\n", s_uart_dev[id].dev);
		ERR_LOG("open %s failed!\n", s_uart_dev[id].dev);
		set_error_code(e_err_group_uart+id ,e_ec_uart_open_dev_failed);
        return -1;
    }
```

但是问题在于，我该将这个包装后的Open放在哪个目录下？

创建独立的系统调用包装模块来实现。

1. 在`collecter`下新增目录`libsys`

   ```bash
   .
   ├── libsys/              # 新增目录
   │   ├── syscall_wrap.c   # 系统调用包装实现
   │   └── syscall_wrap.h   # 包装函数声明
   ├── uart/
   │   ├── uart_x.c         # 修改使用新的Open包装
   │   └── uart_x.h
   └── ...其他现有目录...
   ```

2. 文件内容实现

   **syscall_wrap.h** (位于`libsys/`目录)

   ```C
   #ifndef SYSCALL_WRAP_H
   #define SYSCALL_WRAP_H
   
   #include <fcntl.h>
   #include <sys/types.h>
   
   /* 统一错误处理函数 */
   void collector_error(const char *msg, int error_group, int error_code);
   
   /* 系统调用包装 */
   int Sys_Open(const char *pathname, int flags, mode_t mode);
   int Sys_Close(int fd);
   // 可扩展其他系统调用包装...
   
   #endif
   ```

   **syscall_wrap.c** (位于`libsys/`目录)

   ```C
   #include "syscall_wrap.h"
   #include <stdio.h>
   #include <string.h>
   #include <errno.h>
   #include "commondef.h"  // 假设错误码定义在这里
   
   void collector_error(const char *msg, int error_group, int error_code) 
   {
       fprintf(stderr, "%s: %s\n", msg, strerror(errno));
       ERR_LOG("%s: %s\n", msg, strerror(errno));
       set_error_code(error_group, error_code);
       exit(EXIT_FAILURE);  // 修改为EXIT_FAILURE更标准
   }
   
   int Sys_Open(const char *pathname, int flags, mode_t mode) 
   {
       int fd;
       if ((fd = open(pathname, flags, mode)) < 0) {
           collector_error("Sys_Open error", e_err_group_syscall, e_ec_sys_open_failed);
       }
       return fd;
   }
   ```

3. `uart_x.c`的修改

   ```C
   // 原代码修改为：
   #include "syscall_wrap.h"
   
   int uartx_init(const int id)
   {
       // 修改后的open调用
       s_uart_dev[id].fd = Sys_Open(s_uart_dev[id].dev, O_RDWR|O_NOCTTY|O_NDELAY, 0);
       // ...其余代码不变
   }
   ```

4. Makefile对应修改

   ```makefile
   # 添加libsys到编译路径
   INCLUDES += -I./libsys
   
   # 添加syscall_wrap.c到编译源文件
   SRCS += libsys/syscall_wrap.c
   ```

这样就实现了系统调用包装与硬件操作分离。然后错误处理集中管理。

但是理想往往是很美好的，现在存在的问题是

```C
set_error_code(e_err_group_uart+id ,e_ec_uart_open_dev_failed);
```

会用到这个函数`uartx_init()`的id参数，所以导致的问题是，无法单独将collector_error独立到syslibs

现在还做不到根本的逻辑分离，只能做基础的分离操作，所以直接结束这部分探索。

#### 阻塞问题解决

在`uartx_init()`函数中，以非阻塞的属性打开设备文件后，随后将打开的文件属性设置为了阻塞

```C
s_uart_dev[id].fd = open(s_uart_dev[id].dev, O_RDWR|O_NOCTTY|O_NDELAY);
ret = fcntl(s_uart_dev[id].fd, F_SETFL, 0);
```

这样在后续的操作时，一旦设备阻塞了，后续可能卡死或者阻塞。所以这里需要将文件描述符设置为非阻塞的特性。

```C
// 设置非阻塞模式
fcntl(fd, F_SETFL, O_NONBLOCK);
```

#### 空响应导致的死循环

获取响应的部分代码如下

```C
  // 获取响应
  do {
        recv_n = uartx_recv(UART2, (uint8_t *)(recv_buf + len), sizeof(recv_buf) - len);
        RU_LOG("WRITE_READ_RUCLOCK: recv_n = %d, len = %d, recv_buf = %s\n", recv_n, len, recv_buf);

        // 校验响应合法性
        if (is_last_two_chars_crlf(recv_buf, len)) {
          RU_LOG("valid response!\n");
          remove_end_crlf_in_string(recv_buf, len, response);
          
          RU_LOG("recv_buf = %s[CTRL]\n", response);
          return len;
        }
        len += recv_n;
  } while (1);
```

在 `uartx_recv` 没有收到任何数据时陷入死循环，解决方案如下

1. **引入超时机制**：
   - 使用 `time.h` 库中的 `time` 函数来记录开始时间 `start_time`。
   - 在每次循环中，通过 `time(NULL) - start_time > TIMEOUT_SECONDS` 来检查是否已经超过了预设的超时时间（`TIMEOUT_SECONDS`）。
   - 如果超时，则输出超时信息并返回 `-1` 表示操作失败。
2. **循环逻辑**：
   - 若未超时，则继续调用 `uartx_recv` 函数接收数据，并检查响应的合法性。
   - 如果响应合法，则处理响应并返回接收到的数据长度。

通过这种方式，即使 `uartx_recv` 没有收到任何数据，程序也不会陷入死循环，而是在超时后跳出循环并进行错误处理。

```C
// 获取响应
  do {
    // 检查是否超时
    if (time(NULL) - start_time > TIMEOUT_SECONDS) {
      RU_LOG("Timeout occurred while waiting for response!\n");
      return -1;
    }

    recv_n = uartx_recv(UART2, (uint8_t *)(recv_buf + len), sizeof(recv_buf) - len);
    RU_LOG("WRITE_READ_RUCLOCK: recv_n = %d, len = %d, recv_buf = %s\n", recv_n, len, recv_buf);
    // 检查响应的合法性
    if (is_last_two_chars_crlf(recv_buf, len)) {
      break;
    }
  } while(1);

  remove_end_crlf_in_string(recv_buf, len, response);

  return len - 2;
```

### 测试接口

要定义好测试的接口，即输入命令后，能够给出相应的合法输出。

现在要实现的是，输入查询命令后，可以将字符串的数据转换为json数据。例如获取遥测头信息接口`get-telemetry-headers`命令，就会返回一个json类型的字符串。用的辅助文件就是`cJSON.c`。

现在工程的目录结构为

```bash
crx@ubuntu:~/work/4CHs_MYZR/sources/apps/ruclock$ tree -L 1
.
├── build.log
├── collecter_ver
├── main
├── main.c		# 主函数，获取命令输出字符串
├── Makefile
├── ruclock.c	# 定义获取参数信息的函数
├── ruclock.h
└── version.h
```

其中`main`函数的话，就是一个根据命令做相应操作的文件，例如以下命令：

```c
static struct option long_options[] = {
    {"read",    required_argument, 0, 'r'},
    {"write",   required_argument, 0, 'w'},
    {"help",    no_argument,       0, 'h'},
    {"get-telemetry-headers", no_argument, 0, 0},
    {"get-telemetry-data"   , no_argument, 0, 0},
    {0, 0, 0, 0},
};
```

而`main`函数会用`getopt_long`函数获取命令，执行相应的操作函数来获取json字符串。例如`get-telemetry-headers`代表的函数

```C
void get_telemetry_headers() {
    // 获取参数信息
    T_ruclock_telemetry telemetry_param;
    get_telemetry(&telemetry_param);
    
    // 获取 json 信息
    cJSON *telemetry_headers_json_object = NULL;
    cJSON *telemetry_headers_json_object = convert_telemetry_headers_struct_to_json_string(&telemetry_param);
    
    /* 打印JSON对象(整条链表)的所有数据 */
    str = cJSON_Print(telemetry_headers_json_object);
    printf("%s\n", str);
    cJSON_Delete(telemetry_headers_json_object);
}
```

这样一个基本的模板就定义出来了。现在已知的是，获取参数信息的函数

```C
int get_telemetry(T_ruclock_telemetry *telemetry);
```

定义在`ruclock.c`中，其作用是获取一个`T_ruclock_telemetry`类型的结构体；那我想问下，为了结构体系的解耦性，我该将函数`convert_telemetry_headers_struct_to_json_string`放在那里？解决方案是新增两个文件

```C
crx@ubuntu:~/work/4CHs_MYZR/sources/apps/ruclock$ tree -L 1
.
├── build.log
├── cJSON.c           # 新增cJSON实现文件
├── cJSON.h           # 新增cJSON头文件
├── collecter_ver
├── json_converter.c  # 新增JSON转换模块
├── json_converter.h  # 新增转换模块头文件
├── main
├── main.c
├── Makefile
├── ruclock.c
├── ruclock.h
└── version.h
```

## 4.11

接口测试：

- void get_telemetry_headers()
- void get_telemetry_data();

走了弯路，其实跟web交互的代码只需要用到`ruclock.h`中提供的函数即可。

### 优化uart部分代码

## 4.12

今天周六，准备将ruclock的代码重构一下。需求是什么，需要认真梳理下。

### ruclock优化记录

迁移uart.c和uart.h，使之符合ruclock项目使用

### 头文件修改策略

保证只提供抽象，其他无用的数据结构均对外屏蔽

### Ubuntu连接嵌入式板

1. 查看网卡名称

   ```bash
   crx@ubuntu:~/work/apps/ruclock$ ip addr
   1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
       link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
       inet 127.0.0.1/8 scope host lo
          valid_lft forever preferred_lft forever
       inet6 ::1/128 scope host
          valid_lft forever preferred_lft forever
   2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
       link/ether 00:0c:29:3a:f4:32 brd ff:ff:ff:ff:ff:ff
       altname enp2s1
       inet 192.168.1.11/24 brd 192.168.1.255 scope global dynamic noprefixroute ens33
          valid_lft 49218sec preferred_lft 49218sec
   ```

   其中`ens33`就是网卡名称

2. 添加IP地址

   使用以下命令添加新的 IP 地址到 `ens33` 网卡，并创建一个别名 `ens33:0`

   ```bash
   sudo ip addr add 10.1.2.xxx/8 dev ens33 label ens33:0
   ```

3. 再次查看ip配置

   ```bash
   crx@ubuntu:~/work/apps/ruclock$ ip addr
   .....
   2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
       link/ether 00:0c:29:3a:f4:32 brd ff:ff:ff:ff:ff:ff
       altname enp2s1
       inet 192.168.1.11/24 brd 192.168.1.255 scope global dynamic noprefixroute ens33
          valid_lft 49218sec preferred_lft 49218sec
       inet 10.1.2.11/8 scope global ens33:0
          valid_lft forever preferred_lft forever
   
   ```

   可以看到现在就配置好了跟嵌入式板（ip为`10.1.2.140`，网关是`255.0.0.0`）的交互的接口。随后ping通，能够进行测试了。

### 快速调试

现在的调试路径为

1. 在ubuntu上利用`make`编译程序`ruclock`
2. 通过`scp`命令，将其传递到嵌入式开发板上。并且每次都要输入ssh的密码
3. 在嵌入式开发板上执行`./ruclock`命令

现在想编译完成后，通过一个脚本就能实现传递的命令，我该怎么做？

直接使用别名

```bash
alias mkr='make clean&&make DEBUG=1&&scp ruclock root@10.1.2.140:/tmp/tmp/ruclock'
```

### VSCODE配置C语言注释模板

1. 在ctrl+shift+p下搜索snippets，选择`Configure User Snippets`

2. 选择`c.json`进行配置

   ```json
   {
           "Print to console": {
   		"prefix": "/**",
   		"body": [
   			"/**",
   			" @Function description:",
   			" @param:",
   			" @return value:",
   			"*/"
   		],
   		"description": "函数注释模板"
   	}
    }
   ```

这样子就可以通过`/**`来快速生成函数注释模板了

### 新增接口

需要新增的接口

#### 1PPS

- 同步1PPS接口

  返回值：-1接口调用失败；0同步失败，1同步成功

  ```C
  int synchronize_1pps_interface();
  ```

- 设置 1PPS 校准时间常数

  输入：The time constant can range between 10 to 10000 seconds

  返回值：-1调用接口失败；其余情况返回校准后的时间常数

  ```C
  int set_1pps_disciplining_time_constant(unsigned int seconds);
  ```

- 查询 1PPS 的校准时间常数

  返回值：-1调用接口失败；其余情况返回当前的时间常数

  ```C
  int query_1pps_disciplining_time_constant();
  ```

- 设置 1PPS 校准电缆长度补偿

  输入：输入的补偿值以 100 ps 为单位，最大绝对值为 1000（对应 100 ns）

  输出：-1调用接口失败；其余情况返回设置后的补偿值

  ```C
  int set_1pps_cable_length_compensation(int compensation_in_100ps);
  ```

- 查询当前1pps的校准电缆长度补偿

  输出：-1调用接口失败；其余情况返回设置后的补偿值

  ```C
  int query_1pps_cable_length_compensation();
  ```

- 将当前的补偿值锁定为上电默认值

  输出：1设置成功，0失败

  ```C
  int latch_1pps_compensation_to_powerup_default();
  ```


## 4.14

### Telemetry_Modes_type转换

现在有一个枚举变量`Telemetry_Modes_type`（在`ruclock.h`中定义），其定义为

```C
typedef enum {
	Enable_Analog					= 'A',    	//Enable Analog tuning
	Enable_Phase_Measure			= 'M',		//1PPS phase measurement (only available on firmware versions 1.08 and later).
	Enable_Sync						= 'S',		//1PPS auto-sync.
	Enable_Discipline				= 'D',		//Discipline
	Enable_U_LOW_POWER				= 'U',		//Ultra-Low Power mode
	Enable_Checksum					= 'C',	  	//Require checksum on ! command.

	DisEnable_Analog				= 'a',
	DisEnable_Phase_Measure			= 'm',
	DisEnable_Sync					= 's',
	DisEnable_Discipline			= 'd',
	DisEnable_U_LOW_POWER			= 'u',
	DisEnable_Checksum				= 'c',

	Report_current_settings			= '?'
} Telemetry_Modes_type;
```

其作用是作为函数`int set_operating_modes(Telemetry_Modes_type type)`（在`ruclock.c`中实现）的参数，来设置不同的操作模式。

需求是，前端需要知道每个枚举值意义是什么，可能需后台提供一个键值对的结构，提供给前端所需要的`Telemetry_Modes_type`枚举信息。我该怎么设计这个数据结构？以及对应的将枚举转换为键值对的方法？（from deepseek）

---

> ### 加入交互的工程结构
>
> ```bash
> .
> ├── ruclock.h          # 核心定义
> ├── ruclock.c          # 硬件操作实现
> ├── mode_meta.h        # 新增模式元数据接口
> ├── mode_meta.c        # 新增元数据实现
> └── (其他原有文件保持不变)
> ```
>
> ---
>
> ### 关键实现步骤
>
> 1. **定义元数据结构体**（在`ruclock.h`中新增）
>
> ```c
> // ruclock.h
> typedef struct {
>     Telemetry_Modes_type mode;  // 原始枚举值
>     char code;                  // 字符标识（如'A'）
>     const char* description;    // 完整描述
>     uint8_t is_enable;          // 是否为启用操作（1/0）
> } Telemetry_ModeMeta;
> ```
>
> 2. **创建元数据查询接口**（新建`mode_meta.h/c`）
>
> ```c
> // mode_meta.h
> #pragma once
> #include "ruclock.h"
> 
> // 获取所有模式元数据的指针
> const Telemetry_ModeMeta* get_mode_metadatas(void);
> 
> // 获取元数据数组长度
> size_t get_mode_metadata_count(void);
> 
> // 通过枚举值查找元数据
> const Telemetry_ModeMeta* find_mode_metadata(Telemetry_Modes_type target);
> ```
>
> ```c
> // mode_meta.c
> #include "mode_meta.h"
> 
> static const Telemetry_ModeMeta MODE_METAS[] = {
>     {Enable_Analog,             'A', "Enable Analog tuning", 1},
>     {Enable_Phase_Measure,      'M', "1PPS phase measurement", 1},
>     {Enable_Sync,               'S', "1PPS auto-sync", 1},
>     {Enable_Discipline,         'D', "Discipline mode", 1},
>     {Enable_U_LOW_POWER,        'U', "Ultra-Low Power mode", 1},
>     {Enable_Checksum,           'C', "Require checksum", 1},
>     
>     {DisEnable_Analog,          'a', "Disable Analog tuning", 0},
>     {DisEnable_Phase_Measure,   'm', "Disable phase measurement", 0},
>     {DisEnable_Sync,            's', "Disable auto-sync", 0},
>     {DisEnable_Discipline,      'd', "Disable discipline", 0},
>     {DisEnable_U_LOW_POWER,     'u', "Disable Ultra-Low Power", 0},
>     {DisEnable_Checksum,        'c', "Disable checksum", 0},
>     
>     {Report_current_settings,   '?', "Query settings", 0}
> };
> 
> const Telemetry_ModeMeta* get_mode_metadatas(void) {
>     return MODE_METAS;
> }
> 
> size_t get_mode_metadata_count(void) {
>     return sizeof(MODE_METAS) / sizeof(Telemetry_ModeMeta);
> }
> 
> const Telemetry_ModeMeta* find_mode_metadata(Telemetry_Modes_type target) {
>     const size_t count = get_mode_metadata_count();
>     for(size_t i=0; i<count; i++){
>         if(MODE_METAS[i].mode == target) {
>             return &MODE_METAS[i];
>         }
>     }
>     return NULL;
> }
> ```
>
> ---
>
> ### 架构优势
>
> 1. **核心模块零依赖**
>
>    ```mermaid
>    graph LR
>    ruclock.c -->|仅依赖| ruclock.h
>    mode_meta.c -->|依赖| ruclock.h
>    外部调用者 -->|可选依赖| mode_meta.h
>    ```
>
> 2. **数据访问模式**
>
>    - **直接访问**：通过`get_mode_metadatas()`获取原始结构体数组
>    - **精确查询**：使用`find_mode_metadata()`按枚举值检索
>    - **元数据自描述**：每个条目包含完整解释信息
>
> ---
>
> ### 使用示例
>
> #### 场景1：获取全部元数据
>
> ```c
> const Telemetry_ModeMeta* metas = get_mode_metadatas();
> const size_t count = get_mode_metadata_count();
> 
> for(size_t i=0; i<count; i++){
>     printf("Code: %c => %s\n", 
>            metas[i].code, 
>            metas[i].description);
> }
> ```
>
> #### 场景2：查询特定模式
>
> ```c
> const Telemetry_ModeMeta* meta = find_mode_metadata(Enable_Sync);
> if(meta) {
>     printf("Sync模式状态: %s\n", 
>            meta->is_enable ? "启用" : "禁用");
> }
> ```
>
> #### 场景3：与JSON模块的对接（在json_converter.c中）
>
> ```c
> cJSON* convert_modes_to_json() {
>     cJSON *root = cJSON_CreateArray();
>     const Telemetry_ModeMeta* metas = get_mode_metadatas();
>     const size_t count = get_mode_metadata_count();
> 
>     for(size_t i=0; i<count; i++){
>         // 过滤查询操作的特殊项
>         if(metas[i].mode == Report_current_settings) continue;
> 
>         cJSON *item = cJSON_CreateObject();
>         cJSON_AddStringToObject(item, "code", (char[]){metas[i].code, 0});
>         cJSON_AddStringToObject(item, "desc", metas[i].description);
>         cJSON_AddBoolToObject(item, "enable", metas[i].is_enable);
>         cJSON_AddItemToArray(root, item);
>     }
>     return root;
> }
> ```
>
> ------

由于业务调整，现在暂时放下后面接口的开发，先专注于伺服电机的开发。

### 伺服电机

熟悉下材料吧先。

黄绿双色线：（PE线）**在电工行业中是代表接地线（protecting earthing）**。 也可以称为安全回路线，危险时它就把高压直接转嫁给地球，是一根生命线。 

## 4.15

### Status改造

现在要理解界面上`Status`的意思。看文档，Status是负责哪里的信息显示的。

- **4.6.2 Establishing Communications**：通电时候反应解锁条件（BITE = 1）。

- 4.6.4观察采集：CSACDemo右下角的设备状态字段将通过与状态寄存器 Status 的值相对应的阶段进行处理（获取Status的解释信息）。直到3分钟后（温度低的时候5分钟），Status = 0，意味着获取的数据已经锁定（稳定）。

  此时前端有两个状态：Status图标从红色未锁定状态转换为绿色锁定状态，代指csac状态已经稳定，可以进行生产活动。

- **当`status = 0`时**（频率锁定正常）：

  - **BITE引脚输出低电平（逻辑0）**，表示系统处于健康状态。

- **当`status ≠ 0`时**（频率未锁定或存在异常）：

  - **BITE引脚输出高电平（逻辑1）**，表示系统存在问题。

- **初始上电时**（未稳定或未完成锁定）：

  - BITE引脚默认输出高电平（逻辑1），直到状态稳定且`status`变为0。

#### BITE接口

- 1.2.4：Built-In Test Equipment: 0 = Normal operation, 1 = Unlock condition.

- 2.3：pin4接口对应 BITE 输出信号，展示的信息为CSAC的状态健康度（Status）。通电三分钟后，CSAC状态会被锁定，此时BITE = 0
- 通电时，在采集序列

#### Lock的意思

通电时，首先进入采集数据阶段。CSAC在这个阶段会获取采集序列（物理封装参数等）。采集数据阶段的监控信息，就是遥测接口 `Status` 字段。`Status`的枚举值为

```C
typedef enum {
	Asleep = 9,               // ULP mode only
	Warmup = 8,               // Initial warm-up
	HeaterEquilibration = 7,  // Heater equilibration
	MicrowaveAcquisition = 6, // Microwave power acquisition
	LaserCurrentAcquisition = 5, // Laser current acquisition
	LaserPowerAcquisition = 4,   // Laser power acquisition
	MicrowaveFrequencyAcquisition = 3, // Microwave frequency acquisition
	MicrowaveFrequencyStabilization = 2, // Microwave frequency stabilization
	MicrowaveFrequencySteering = 1,   // Microwave frequency steering
	Locked = 0                // Locked
} E_telemetry_status;
```

通电时，`Status`会从状态8开始，在采集过程中**依次递减**为状态0的正常操作状态。

### 修改enums

已经实现将ruclock无关的枚举变量描述独立出来。

### 下阶段目标

- 伺服电机驱动
- 单板开发

### 精准控制转动角度的基础

电子齿轮比用于对电机的转速和位置进行精确调整。需要这个参数来帮助精准控制转动角度。

就是理解下要想精准控制转动角度，我需要理解哪些关键术语。

#### 编码器

![v2-5e79612dade75ce0123b49b96ebe9224_1440w](C:\Users\Administrator\Pictures\Saved Pictures\v2-5e79612dade75ce0123b49b96ebe9224_1440w.jpg)

将机械信号转换为电信号的传感器。是用来采集和控制电机的转速、位置等信息的装备

- 结构：码盘、光源和光敏元件组成

- [采集原理](https://zhuanlan.zhihu.com/p/502853687)：当电机转动的时候，会带着有特定镂空标志的码盘转动。编码器内部的光源会不断照射码盘上的孔洞，每照射过一个孔洞就会产生一次脉冲输出进行计数。从而实现了转速、角度的控制采集

  方向：编码器输出上会有A、B两路信号，这两路信号可以用于判断编码器的正反转。

#### 分辨率

电机旋转一圈，编码器会产生的脉冲数。

- 示例
  -  分辨率 `1000 PPR` → 每转输出 `1000` 个脉冲。
  - 转 `90°`（即 `1/4` 圈）→ 输出 `1000 × 1/4 = 250` 个脉冲。
- **重要性**：分辨率越高，控制精度越高（如 `17位编码器=131072 PPR`）。

#### 电子齿轮比

> 在实际的运动控制系统中，控制器输出的脉冲当量（每个脉冲对应的实际位移或角度）与编码器分辨率所代表的脉冲当量往往不同。例如，控制器可能是按照每毫米对应一定数量的脉冲来发送指令，而电机编码器的分辨率是按照每转多少脉冲来设计的。如果不通过电子齿轮比进行转换，就无法将控制器的指令准确地转化为电机的实际运动，导致运动控制不准确。

- **定义**：将编码器脉冲数转换为实际控制脉冲数的比例。

- **公式**：

  实际移动量 = 输入的脉冲数 X （电子齿轮分子 / 电子齿轮分母）

- **示例**：

  - 编码器分辨率 `131072 PPR`，想让 `1000` 个输入脉冲转 `1` 圈 →`电子齿轮比 = 131072:1000`（分子=`131072`，分母=`1000`）
  

#### 闭环控制

- **定义**：通过编码器反馈实时调整电机运动，确保实际位置与目标一致。
- **核心环节**：
  - **位置环**：控制最终停止位置（如精确转 `90°`）。
  - **速度环**：调节转速均匀性（如恒速 `1000 RPM`）。
  - **电流环**：控制输出扭矩（如拧螺丝时恒定力矩）。

### 控制转动角度的实践

#### 1. **配置位置控制模式**

- **参数设置**：`H02_00 = 1`（位置控制模式）

#### 2. **设置电子齿轮比**

- **公式**：`电子齿轮比 = 编码器分辨率 / 每圈所需脉冲数`
  - 文档中编码器分辨率默认 `131072` 脉冲/圈
  - 想实现目标精确度1°。所以每圈所需要的脉冲数为360。
- **计算电子齿轮比**：
  - 电子齿轮比 = 131072 / 360 = 32768 / 90
- **分子（H05_07）**：`32768`
- **分母（H05_09）**：`90`
- **位置指令来源（H05_00）**:`2` 内部多段位指令

#### 3.**点动功能关联位置指令**

- JOG+/- 信号配置为多段位置运行指令使能（H03_08=28）

#### 4.多段位置参数

- **多段位置运行方式（H11_00）**：`0`单次运行结束停机
- **位移指令终点段数（H11_01）**：`1`。只运行1段
- **第一段移动位移（H11_12）**：`1`度。

## 4.16

写一个QT命令行程序，通过 Modbus RTU 通信协议来操作电机转圈，转角度。行车控制管理系统密码

### 创建QT工程

首先建立一个QT工程，用命令行单独测试电机的各项指标。[参考](https://juejin.cn/post/7166984645064540197)

### ModBus

在 Modbus 通信协议中，主站和从站是两个重要的概念

- 主站
  - **功能**：主站是通信的发起者和控制者。它负责向从站发送请求消息，以读取或写入从站的数据。主站可以同时与多个从站进行通信，并按照一定的顺序和规则依次向各个从站发送请求。
  - **特点**：在一个 Modbus 网络中，通常只有一个主站。主站具有较高的控制权和主动性，它决定了何时进行通信以及与哪个从站进行通信。例如，在工业自动化控制系统中，主站可能是 PLC（可编程逻辑控制器）或上位机（如监控计算机），用于收集现场设备的数据或向现场设备发送控制指令。
- 从站
  - **功能**：从站是接收主站请求并做出响应的设备。从站根据主站发送的请求消息，执行相应的操作，如读取自身的寄存器数据并返回给主站，或根据主站的指令写入数据到指定的寄存器。
  - **特点**：一个 Modbus 网络中可以有多个从站，每个从站都有唯一的地址，以便主站能够准确地识别和与之通信。从站只能在接收到主站的请求后才发送响应消息，不能主动向主站发送数据。例如，在一个智能建筑的监控系统中，各种传感器（如温度传感器、湿度传感器）和执行器（如阀门、电机驱动器）等设备可以作为从站，通过 Modbus 通信协议与主站进行数据交互，实现对整个建筑环境的监测和控制。

现在制作的运行有QT程序的PC，就是主站；要通讯的电机驱动是从站。

### Motor概念

现在由于对电机的主要寄存器不理解，所以需要做点实际的工作来辅助理解。所以请给我一些实际操作需求，让我在实践中学习驱动电机的参数功能。

- **点动控制**：点动控制指的是通过短暂操作控制按钮或指令，让电机按照预定方向转动一定角度或距离，当操作结束，电机立即停止运行的控制方式。操作人员对电机的启动和停止拥有即时控制权，每次操作的持续时间较短。

- **DI**：DI 接口可以连接外部的按钮、开关、传感器等设备。在电机控制系统里，DI 就像是驱动器的 “耳朵”，负责接收外部的各种 “命令”，让驱动器知道用户想要电机做什么，是启动、停止，还是进行其他特定动作

- **端子**：是电机驱动器上用于连接外部设备的物理接口。输入端子如 DI_COM、DI1 - DI9 等，用于接收外部设备的信号，像按钮、传感器的信号；输出端子如 DO1 - DO5 等，用来向外部设备发送驱动器的状态信号。从硬件层面看，它们是实实在在的接口，有的是螺丝端子，有的是插拔式端子，通过导线连接外部设备与驱动器，实现系统内外的信息交互与控制指令传递。

  本手册中每个端子都有两个配置：功能和逻辑。功能就是要实现的具体操作（伺服使能），逻辑就是如何实现具体的操作（高电平有效等）。

- **伺服使能（SON）**：伺服使能（Servo ON）” 的缩写，用于控制电机的启动和停止等运行状态。只有当电机处于启动状态的时候，才可能让电机转起来。

- **rpm**： “Revolutions Per Minute” 的缩写，意为 “每分钟转数”，是用于衡量旋转物体转速的单位。

### 需求

现在需要在已有的QT工程中，加入servo电机的驱动。最终效果是：

- 界面：调整电机`左右`移动的栏目中，加入与`上下`栏目相似的电机选项`Y2`
- 逻辑：加入与当前电机操作逻辑（点动控制、点动距离控制等）相同的适用于servo电机的驱动逻辑

现在首先我对QT语法并不是很理解，并且对于其中的软件架构也不理解，所以稍微会觉得压力较大。🤨

### ps命令

- `ps`：这是 `process status` 的缩写，是用于报告当前系统进程状态的基本命令。
- `-e`：该选项表示显示所有进程，无论进程的所有者是谁，也不管进程是否与终端相关联。也就是说，它会列出系统中正在运行的所有进程。
- `-f`：此选项表示以完整格式显示进程信息，提供更详细的进程描述。

## 4.17

### 项目需求学习

现在需求是学习在QT生成的界面中，`上下`栏中如何选择电机`Z1`和`Z2`。随后应用到栏目`左右`，加入新电机`Y2`，并将之前的`Y`电机改为`Y1`。

问题：

- 不知道在哪里找`上下`栏目对应的代码
- 不知道`上下`栏对应的代码如何执行的
- 在哪里找`左右`的代码
- 怎么加入类似功能的`Y2`电机

需要先学习下如何使用[信号和槽机制](https://qtguide.ustclug.org/)

### QT信号槽

按按钮（信号）-----（connect）-------- > 灯泡亮（槽函数）

### motorCtrl.h

现在从电机控制的头文件开始，看下`上下`栏目对应的定义是什么。

#### 定位现有电机控件（上下栏 Z1/Z2）

```cpp
// 上下栏控件
QButtonGroup *m_upDown_btgrp;   // 按钮组
QRadioButton *m_z1_rdb;         // Z1 单选框
QRadioButton *m_z2_rdb;         // Z2 单选框
```

这些控件对应上下栏的 Z1/Z2 选择。其语法为：

- `QButtonGroup *m_upDown_btgrp;`：声明了一个指向 `QButtonGroup` 类型对象的指针 `m_upDown_btgrp`。`QButtonGroup` 在 Qt 中用于管理一组按钮（如单选按钮或复选按钮），可以实现一些统一的行为，比如确保同一组内的单选按钮只有一个被选中等。这里只是声明了指针，还没有创建实际的 `QButtonGroup` 对象。
- `QRadioButton *m_z1_rdb;`：声明了一个指向 `QRadioButton` 类型对象的指针 `m_z1_rdb`。`QRadioButton` 是 Qt 中的单选按钮控件，用户可以通过点击来选择它，并且同一组内的单选按钮具有排他性（即只能有一个被选中）。
- `QRadioButton *m_z2_rdb;`：同样声明了一个指向 `QRadioButton` 类型对象的指针 `m_z2_rdb`，用于表示另一个单选按钮。

`m_` 表示成员变量，`z1` 对应着控制上下方向的电机 `Z1`，`rdb` 是 `RadioButton` 的缩写。

### motorCtrl.cpp

#### 创建对象

在`MotorCtrl`的类中，首先创建关于`m_upDown_btgrp`以及z1/2的对象

```Cpp
MotorCtrl::MotorCtrl(QWidget *parent) : QWidget(parent) {
    // ..... 
    // [上下] 按钮的创建以及功能连接
    m_upDown_bt = new QPushButton(this);
    m_upDown_bt->setObjectName("upDown_bt");
    m_upDown_bt->setCheckable(true);
    connect(m_upDown_bt, &QPushButton::clicked, this, &MotorCtrl::on_funSl_changed);

    // [上下] 按钮组的创建 -- 只能有一个按钮被选中
    m_upDown_btgrp = new QButtonGroup(this);

    //单选按钮 `m_z1_rdb` 的创建与设置
    m_z1_rdb = new QRadioButton("电机Z1", this);
    m_z1_rdb->setObjectName("Z1_rdb");
    m_z1_rdb->setChecked(true); // 单选按钮设置为选中状态
    m_z1_rdb->setVisible(false);

    // 单选按钮 `m_z2_rdb` 的创建与设置
    m_z2_rdb = new QRadioButton("电机Z2", this);
    m_z2_rdb->setObjectName("Z2_rdb");
    m_z2_rdb->setVisible(false);

    // 信号和槽的连接
    connect(m_upDown_btgrp, SIGNAL(buttonClicked(int)), this, SLOT(on_z1z2_changed(int)));
    m_upDown_btgrp->addButton(m_z1_rdb, MoveEableMotors);
    m_upDown_btgrp->addButton(m_z2_rdb, FixedMotor);

    // 将 [上下] 按钮组，放到 [槽函数功能栏目组] 组里面，并且设置id为 UpDown
    m_funSl_btgrp = new QButtonGroup(this);
    m_funSl_btgrp->addButton(m_upDown_bt, UpDown);
}
```

#### `on_funSl_changed` 函数

`on_funSl_changed` 函数是 `MotorCtrl` 类的一个槽函数，其主要功能是根据 `m_funSl_btgrp` 按钮组中被选中按钮的 ID 来更新界面上的一些控件状态、显示文本以及图片。可以在函数中下断点，以此获取当点击`[上下]`按钮的时候，到底发生了什么

当按钮选中`[上下]`栏目（按钮`m_upDown_btgrp`）的时候，就会跳转到之前绑定的槽函数`on_z1z2_changed(int)`

```C
void MotorCtrl::on_z1z2_changed(int id)
{
    Q_UNUSED(id);
    on_funSl_changed();
}
```

函数首先销毁传入的参数，随后跳转到按钮槽函数` on_funSl_changed()`。

函数进行完一些初始化后，会首先判断这个按钮的`ID`。而`[上下]`按钮的 ID 为上面已经设置好的枚举值`UpDown`

```C
switch (m_funSl_btgrp->checkedId()) {
         case UpDown:{
            int mid = M_Z1;
            m_z1_rdb->setVisible(true);
            m_z2_rdb->setVisible(true);
            UpdateZ1Z2Titil();
            if(m_upDown_btgrp->checkedId() == FixedMotor){
                mid = M_Z2;
                png = ":/images/skin/images/motorZ2";
            }else{
                png = ":/images/skin/images/motorZ1";
            }
            m_curr_lb->setText("当前位置(mm):");
            m_currVal_lb->setText(getDistShowVal(mid));
            m_speed_bt->setText(QString("速度: %1mm/s").arg(getSpeedShowVal(mid)));
            m_distance_bt->setText(QString("点动距离: %1mm").arg(getClickDist(mid)));
            //m_action_upRightFront_bt->setStyleSheet("QPushButton#action_upRightFront_bt{border-image: url(:/images/skin/svg/up.svg)}");
            //m_action_downLeftBack_bt->setStyleSheet("QPushButton#action_downLeftBack_bt{border-image: url(:/images/skin/svg/down.svg)}");
        }break;
}
```

其行为是：

- 设置`Z1`为操作电机

- 将`Z1`和`Z2`的按钮设置为可见。并更新与这两个电机相关的文字框

  ```C
  void MotorCtrl::UpdateZ1Z2Titil()
  {
      m_title_lb->setText("可旋转轴垂直上下运动控制");
      if(m_upDown_btgrp->checkedId() == FixedMotor){
          m_title_lb->setText("固定轴垂直上下运动控制");
      }
  }
  ```

- 根据当前`[上下]` 按钮组中选中的按钮，展示不同的图片

  ```C
  m_upDown_btgrp->addButton(m_z1_rdb, MoveEableMotors);
  m_upDown_btgrp->addButton(m_z2_rdb, FixedMotor);
  ```

- 展示当前按钮所表示电机的信息

至此，一个完整的按钮展示和控制流程就完毕了。

```bash
clicked -> [上下]按钮（m_upDown_btgrp） -> on_funSl_changed()按钮初始化 -> [电机Z2]（m_upDown_btgrp->checkedId() == FixedMotor）-> on_funSl_changed()设置 电机Z2 所在的逻辑
```

### 按钮展示的实践

好的，现在你已经是一个成熟的开发人员了，下面写点有意思的。😑

仿照`m_upDown_btgrp`组关于`电机Z1`和`电机Z2`的相关操作，写一个[左右]的电机Y1和电机Y2的界面。

#### 获取左右按钮的对象

断点`switch (m_funSl_btgrp->checkedId())`处代码，点击`左右`按钮，可以发现其按钮的ID为`LeftRight`。根据其注册ID获取其注册对象为`m_leftRight_bt`。

#### 创建Y1、Y2按钮

```C
    // 创建 [左右] 按钮以及功能连接
    m_leftRight_bt = new QPushButton(this);
    m_leftRight_bt->setObjectName("leftRight_bt");
    m_leftRight_bt->setCheckable(true);
    connect(m_leftRight_bt, &QPushButton::clicked, this, &MotorCtrl::on_funSl_changed);

    // [左右] 按钮组创建
    m_leftRight_btgrp = new QButtonGroup(this);

    // 单选按钮 Y1 创建与设置
    moter_y1_radio_button = new QRadioButton("电机Y1", this);
    moter_y1_radio_button->setObjectName("Y1_radio_button");
    moter_y1_radio_button->setChecked(true); // 单选按钮设置为选中状态
    moter_y1_radio_button->setVisible(false);

    // 单选按钮 Y2 创建与设置
    moter_y2_radio_button = new QRadioButton("电机Y2", this);
    moter_y2_radio_button->setObjectName("Y2_radio_button");
    moter_y2_radio_button->setVisible(false);

    // 信号和槽的连接
    connect(m_leftRight_btgrp, SIGNAL(buttonClicked(int)), this, SLOT(on_y1y2_changed(int)));
    m_leftRight_btgrp->addButton(moter_y1_radio_button, HorizontalUpperMoter);  // Y1 电机在上方
    m_leftRight_btgrp->addButton(moter_y2_radio_button, HorizontalLowerMoter);  // Y2 电机在下方
```

#### 辅助函数

```C
        int mid = M_Y1;
        moter_y1_radio_button->setVisible(true);
        moter_y2_radio_button->setVisible(true);
        UpdateY1Y2Titil();

        if(m_upDown_btgrp->checkedId() == HorizontalUpperMoter){
            mid = M_Y1;
//            png = ":/images/skin/images/motorY1";
        }else{
            mid = M_Y2;
//            png = ":/images/skin/images/motorY2";
        }
        m_curr_lb->setText("当前位置(mm):");
        m_currVal_lb->setText(getDistShowVal(mid));
        m_speed_bt->setText(QString("速度: %1mm/s").arg(getSpeedShowVal(mid)));
        m_distance_bt->setText(QString("点动距离: %1mm").arg(getClickDist(mid)));
        m_title_lb->setText("水平左右运动控制");
```

#### 问题

现在存在的问题是：不展示左侧的两个按钮信息，明天继续吧。

## 4.18

今天首先试着将Y1和Y2按钮在左侧栏展示出来。

### Z1/Z2展示异常

现在在[上下]栏目中点击`电机Z2`的时候，会报错：发生了快速异常检测失败。

debug断点，查看报错时执行的代码为

```C
540 m_currVal_lb->setText(getDistShowVal(mid));
```

执行函数`getDistShowVal()`报错

```C
QString MotorCtrl::getDistShowVal(qint32 motorID)
{
    float val = getLocation(motorID)*DbCtrl::m_servoMotor_tb.at(motorID).dir;
    if(M_Angle == motorID){
        return QString::number(val,'f', 3);
    }else{
        return QString::number(val,'f', 0);
    }
}
```

发现是获取当前电机的位置的函数`getLocation()`报错。

```C
float MotorCtrl::getLocation(int motorID)
{
    quint64 p=0;
    m_motorRegs->readReg64(motorID, MotorRegs::S24_27, p);
    qint64 pulse = (qint64)p;

    float tmp = 0;
    if(M_Angle == motorID){
        tmp = motor_pulse2angle(motorID, pulse);
    }else{
        tmp = motor_pulse2mm(motorID, pulse);
    }
    return tmp;
}
```

最后在函数`motor_pulse2mm()`报错

```C
qint32 MotorCtrl::motor_pulse2mm(int motorID, qint64 pulse)
{
    qint32 ret = 0;
    if(DbCtrl::m_servoMotor_tb.at(motorID).screwPitch != 0){
        ret = (qint32)(pulse*1.0/MOTOR_PULSE_ONEC/DbCtrl::m_servoMotor_tb.at(motorID).gearRatio
                        *DbCtrl::m_servoMotor_tb.at(motorID).screwPitch);
    }else if(DbCtrl::m_servoMotor_tb.at(motorID).outsideDiameter != 0){
        ret = (qint32)(pulse*1.0/MOTOR_PULSE_ONEC/DbCtrl::m_servoMotor_tb.at(motorID).gearRatio
                        *(DbCtrl::m_servoMotor_tb.at(motorID).outsideDiameter * M_PI));
    }else{
        SMessageBox::sQdialogBoxOk(this, QMessageBox::Critical, QString("电机%1齿轮外径或者丝杆螺距需选配1种。").arg(DbCtrl::s_motorNameList.at(motorID)));
    }
    return ret;
}
```

在判断电机的丝杆螺距 `screwPitch` 是否不为 0的时候，因为数据库没有此ID的电机信息，所以会报错处理。解决办法就是将`Y2`枚举值添加到末尾，不影响之前的保存记录。

### 重构 `MotorCtrl` 类的UI

感觉要来大的了。现在已经大体理解了代码中关于UI界面的逻辑，现在先做个小实验，将`MotorCtrl`类中的UI部分逻辑独立开。编写规则就是按照 **测试驱动开发(TDD)** 的模式

## 4.21

今天的任务就是仿照之前电机Y的业务，写一个相同的Y2电机业务逻辑。

首先是获取电机信息。

### 负载齿轮比

#### 齿轮传动原理

- 两个相互啮合的齿轮，在传动过程中，它们在相同时间内转过的齿数是相同的。
- 设主动齿轮（与电机轴相连）的齿数为*Z*1，从动齿轮（与负载轴相连）的齿数为*Z*2。当主动齿轮转过一圈时，它所转过的齿数为*Z*1，此时从动齿轮也必须转过*Z*1个齿才能与主动齿轮保持啮合传动。
- 那么从动齿轮转过的圈数就是 Z1/ Z2 圈，因为从动齿轮每转一圈是*Z*2个齿。

#### 电机与负载旋转圈数关系

- 电机带动主动齿轮旋转，负载连接在从动齿轮上，所以电机的旋转圈数`Nmotor`与主动齿轮的旋转圈数相同，负载的旋转圈数`Nload`与从动齿轮的旋转圈数相同

- 由前面分析可知，当电机（主动齿轮）转一圈时，负载（从动齿轮）转 `Z1 / Z2`圈。那么当电机旋转`Nmotor`圈的时候，负载旋转的圈数为

  ```tex
  Nload = Nmotor * Z1 / Z2
  ```

  所以

  ```tex
  Nmotor / Nload = Z2 / Z1
  ```

- 而我们前面定义负载齿轮比`G=Z2 / Z1`，所以就得到

  ```tex
  Nmotor / Nload = G
  ```

负载齿轮比 = 负载的齿轮数 / 驱动的齿轮数

从自行车的变速效果来看负载齿轮比大小的影响。

1. 平坡加速：大齿轮驱动小齿轮。此时驱动齿轮可能在52齿，负载齿轮仅有13齿数。所以此时蹬一圈，负载旋转4圈。G = 13 / 52 = 1/4
2. 上坡省力：小齿轮驱动大齿轮。此时驱动齿轮放在28齿，负载齿轮28齿轮，蹬一圈，负载轮旋转1圈，省力。

负载齿轮比 *G*>1 时，意味着驱动的转速比负载的转速快，也就是驱动转多圈，负载才转一圈；反之，当 *G*<1 时，负载转速比驱动转速快。

### 获取电机信息

#### 获取当前电机的位置

```C++
QString MotorCtrl::getDistShowVal(qint32 motorID)
{
    // 获取电机的当前位置 * 当前电机的运动方向
    float val = getLocation(motorID)*DbCtrl::m_servoMotor_tb.at(motorID).dir;
    if(M_Angle == motorID){
        return QString::number(val,'f', 3);
    }else{
        return QString::number(val,'f', 0);
    }
}
```

从寄存器中读取绝对位置

```C++
float MotorCtrl::getLocation(int motorID)
{
    quint64 p=0;
    m_motorRegs->readReg64(motorID, MotorRegs::S24_27, p);
    qint64 pulse = (qint64)p;

    float tmp = 0;
    if(M_Angle == motorID){
        tmp = motor_pulse2angle(motorID, pulse);
    }else{
        tmp = motor_pulse2mm(motorID, pulse);
    }
    return tmp;
}
```

根据当前电机的位置脉冲数，获取电机当前位置的旋转角度

```C++
float MotorCtrl::motor_pulse2angle(qint32 motorID, qint64 pulse)
{
    float loadGearRatio = (float) DbCtrl::m_servoMotor_tb.at(motorID).gearRatio;

     // 计算负载实际对应的脉冲数
    float actualPulseCount  = pulse*1.0 / loadGearRatio;

    // 计算旋转圈数
    float rotationCycles = actualPulseCount / (MOTOR_PULSE_ONEC * 1.0);

    // 计算旋转角度
    float rotationAngle = rotationCycles * 360.0;
    return rotationAngle;
}
```

- 问题：这个`pulse`代指的是什么脉冲数？为什么后面要除以~~电子~~齿轮比？

  - `pulse`指的是电机旋转产生的脉冲数

  - `gearRatio`：齿轮比描述了电机与负载之间的传动关系。这里并不是电子齿轮比。

    负载的旋转圈数（脉冲数） = 电机的旋转圈数（脉冲数） / G（负载齿轮比）

根据当前电机的脉冲数，获取电机当前位置的移动距离

```c++
qint32 MotorCtrl::motor_pulse2mm(int motorID, qint64 pulse)
{
    qint32 ret = 0;
    if(DbCtrl::m_servoMotor_tb.at(motorID).screwPitch != 0){
        ret = (qint32)(pulse*1.0/MOTOR_PULSE_ONEC/DbCtrl::m_servoMotor_tb.at(motorID).gearRatio
                        *DbCtrl::m_servoMotor_tb.at(motorID).screwPitch);
    }else if(DbCtrl::m_servoMotor_tb.at(motorID).outsideDiameter != 0){
        ret = (qint32)(pulse*1.0/MOTOR_PULSE_ONEC/DbCtrl::m_servoMotor_tb.at(motorID).gearRatio
                        *(DbCtrl::m_servoMotor_tb.at(motorID).outsideDiameter * M_PI));
    }else{
        SMessageBox::sQdialogBoxOk(this, QMessageBox::Critical, QString("电机%1齿轮外径或者丝杆螺距需选配1种。").arg(DbCtrl::s_motorNameList.at(motorID)));
    }
    return ret;
}
```

#### 获取伺服电机驱动速度

```C
QString MotorCtrl::getSpeedShowVal(qint32 motorID)
{
    if(M_Angle == motorID){
        float val = BaseConfig::getServoSpeedRpm(motorID);
        val = val*360/60/DbCtrl::m_servoMotor_tb.at(motorID).gearRatio;
        return QString::number(val,'f', 1);
    }else{
        float val = BaseConfig::getServoSpeed(motorID);
        return QString::number(val,'f', 0);
    }
}
```

### 获取此信息的难点

现在存在两种不同的电机，其寄存器位置和作用均不相同。例如电机型号`p100s`获取当前绝对位置的脉冲值，就是通过对应的协议去读64位的寄存器`S24_27`（ 0x1018）的值。看现在已经实现的逻辑

```C++
bool BaseConfig::getServoCurrentAbsolutePositionPulseCount(int motorID, quint64 &absPositionPulse) {
    return MotorRegs::get_instance()->readReg64(motorID, MotorRegs::S24_27, absPositionPulse);
}
```

但是`aimtor`就需要从32位的地址`0x0b07`处读取数据（尚未实现）。

但是它们又有很多相同的功能描述：获取当前绝对位置的脉冲值、获取当前电机旋转速度、以点动前进等。

所以如果我想开发QT项目，通过操作电机的功能（移动、获取信息等）来实现各种业务，我该怎么设计项目结构，以此实现更好地拓展性和低耦合性？已知现在存在的逻辑模块有

```txt
motorregs	// 读/写寄存器（16/32/64位）
// baseconfig(已经摒弃)	// 通过调用 motorregs 方法，实现基本电机逻辑
motorCtrl	// 通过调用 baseconfig 的基本电机逻辑，实现复杂业务逻辑
```

## 4.22

### 急停逻辑

现在实现的是将`紧急停止位`设置为1。这样做的效果是暂停当前的所有操作。但是如果取消停止，之前所有的动作（可能以某种速度运行等）都会继续执行。而我现在的需求是，按下急停按钮后，将会清空电机的速度或者旋转等运动状态为初始化状态。

但是什么又是初始化状态？AIMtor中在使用通讯功能（Modbus）来操控电机的时候，会先让在上位机调试软件中配置好基本参数（固定参数），然后根据需求再调整某些可动参数即可。最后电机导通，就会按照初始状态运动。

（我看下具体的运动逻辑，就是点动和位移操作）

### 设为原点

#### 原逻辑

之前的设置原点逻辑是

```C
enum {
    P4_2 = 0x202,   //第一段内部位置圈数
	P4_3 = 0x203,   //第一段内部位置圈内脉冲数
	P3_34 = 0x122,  //1 复位归零编码器多圈数据
};
m_motorRegs->writeReg16(motorID, MotorRegs::P4_2, 0);
m_motorRegs->writeReg16(motorID, MotorRegs::P4_3, 0);
m_motorRegs->writeReg16(motorID, MotorRegs::P3_34, 1);
```

- 电机只能设置一段位移去移动（设定第 1 段内部位置的位置圈数为0）

## 4.23

任务：

- 实现AIMtor的逻辑平稳停止
- 实现AIMtor的点动移动
- 实现AIMtor的位置移动

### 逻辑平稳停止

#### **1. 确定当前控制模式**

读取 `H02_00` 参数，确认电机当前的控制模式：

- `0`：速度控制模式
- `1`：位置控制模式

#### **2. 根据控制模式调整参数实现停止**

##### **2.1 位置控制模式（H02_00 = 1）**

1. **停止发送脉冲指令**

   - 若通过外部控制器发送脉冲，停止脉冲输出。
   - 若使用内部多段位置指令（`H05_00 = 2`），禁用多段位使能信号（`DI28`）。

2. **设置目标位置为当前位置**

   ```c++
   // 读取当前绝对位置（H0B_07）
   quint64 currentPos;
   MotorRegs::readReg32(motorID, 0x0B07, currentPos);
   
   // 设置目标位置为当前位置（H11_12）
   MotorRegs::writeReg32(motorID, 0x110C, currentPos);
   ```

3. **确保定位完成阈值生效**

   - 设置 `H05_21`（定位完成阈值）为一个较小值（如10），当位置偏差小于该值时触发 `COIN` 信号。

##### **2.2 速度控制模式（H02_00 = 0）**

1. **将目标速度设为0**

   ```cpp
   // 设置H06_03（目标速度）为0
   MotorRegs::writeReg16(motorID, 0x0603, 0);
   ```

2. **调整加减速时间**

   - 设置 `H06_05`（加速时间）和 `H06_06`（减速时间）为较大值（如1000ms），实现平滑停止。

##### **2.3 转矩控制模式（H02_00 = 2）**

1. **将目标转矩设为0**

   ```cpp
   // 设置H07_03（目标转矩）为0
   MotorRegs::writeReg16(motorID, 0x0703, 0);
   ```

#### **3. 配置停机方式（H02_05**)

设置 `H02_05 = 2`，使伺服使能（SON）断开后进入 **阻尼制动状态**，避免自由滑行：

```cpp
// 设置停机方式为阻尼制动
MotorRegs::writeReg16(motorID, 0x0205, 2);
```

#### **4. 可选：软复位伺服（H0D_00）**

通过软复位重启驱动器，复位后自动进入停止状态：

```cpp
// 触发软复位（H0D_00 = 1）
MotorRegs::writeReg16(motorID, 0x0D00, 1);
```

------

#### **5. 验证停止状态**

1. **监控实际转速（H0B_00）**

   ```cpp
   quint16 speed;
   MotorRegs::readReg16(motorID, 0x0B00, speed);
   if (speed == 0) {
       qDebug() << "电机已停止";
   }
   ```

2. **检查定位完成信号（COIN）**

   - 若 `H05_21` 阈值生效，`COIN` 信号（DO2）会变为有效。

------

#### **6. 注意事项**

- **避免急停**：不要触发 `H0D_05`（紧急停机），以免造成机械冲击。
- **电子齿轮比校准**：确保 `H05_07`（电子齿轮分子）和 `H05_09`（分母）设置正确，否则实际停止位置可能有偏差。
- **故障处理**：若触发 `ER.B00`（位置超差），适当增大 `H0A_10`（位置超差阈值）。

### 点动控制

现在发现servo项目对于电机的驱动方式就只有两种：

- 点动控制
- 单段位置控制（位置数量 = 1）

所以针对点动控制，需要3个寄存器的操作

- H06_04（JOG 点动速度设置值）

  ```c++
  bool MotorCtrl::setJOGSpeed(int motorID, qint16 JOG_speed)
  {
      return m_motorRegs->writeReg16(motorID, MotorRegs::H06_04, JOG_speed);
  }
  
  bool MotorCtrl::getJOGSpeed(int motorID, qint16 &JOG_speed)
  {
      return m_motorRegs->readRegInt16(motorID, MotorRegs::H06_04, JOG_speed);    // 单位 rpm
  }
  ```

- H03_08（InFun18 速度正向点动）

- H03_10（InFun19 速度负向点动）

### 逻辑平稳停止2

现在的问题是，在三个模式下，均能单独使用点动执行。所以需要在三个模式中将点动使能均停止掉。

## 4.24

- 复原按钮是包括将第一段位移设置为0
- 位置移动`actionDir`完善逻辑

### 设置位置问题

在位置移动的时，在按键松开时，调用槽函数`on_actionUpRightFrontBt_clicked`，槽函数会检测是否已有任务正在执行。如果没有任务，则执行位置移动函数

```Cpp
void MotorCtrl::actionDir(int dir);
```

在位置函数中的逻辑如下

#### 1.获取当前设置的移动的距离

```C++
qint32 mm = (qint32)DbCtrl::m_servoMotor_tb.at(motorID).clickDistance*dir;
float curr_dist = getLocation(motorID)*DbCtrl::m_servoMotor_tb.at(motorID).dir;
```

- 读取设置的位置移动距离`clickDistance`与方向`dir`(当前函数内dir = 1)的乘积
- 获取电机已经移动的距离`curr_dist`（会调用函数`motor_pulse2mm()`获取）

```Cpp
qint64 pulse = servo_mm2pulse(motorID, mm)*DbCtrl::m_servoMotor_tb.at(motorID).dir;
```

### 当前位置2

虽然之前做过获取当前位置，但是对于当前位置代表的意义，这里有了较为深入的理解。😏

#### 观察

在测试AIMtor电机的位置控制的时候，不可避免地要设置单段位移长度。而这个位移长度是什么呢？首先看下相关寄存器的解释

| 寄存器 | 描述                    | 单位     |
| ------ | ----------------------- | -------- |
| H11_12 | 第 1 段移动位移指令单位 | 指令单位 |

单位是指令单位。因为驱动电机的时候，**伺服**需要**电机**向发送指令脉冲，所以我们推测这里的指令单位就是伺服发送给电机的指令数量。

而涉及到伺服和电机的交互，就不可避免地用到了“电子齿轮比”这个概念。

- AIMotor 电机编码器分辨率为 131072；意思就是电机旋转一圈产生的脉冲数为`131072`。
- 当前默认伺服需要发送1000个指令脉冲才能让电机旋转一圈

电子齿轮比 = 电机编码器分辨率 / 电机旋转一圈所需要的脉冲指令数量

所以当前的齿轮比就是`131072 / 1000`。

#### 测试

当前设置为位置移动模式，并将当前位置（也是指令单位）清0，设置默认电子齿轮比为`131072 / 1000`。

然后配置寄存器`H11_12`的值为`1000`个指令脉冲的数量，如果假设正确的话，那么当多段位置移动的时候，移动完毕后，电机应该旋转了1圈。并且当前位置为`1000`指令数量。

经过测试，发现确实是这样的逻辑。验证通过。😊

那么就得把当前电机的位置函数修改一下。

### 齿轮箱GearRatio

设置10，则电机旋转10圈，齿轮箱旋转1圈。

## 4.25

今天基本将主要逻辑都实现了，现在想开始进行逻辑抽象，重构一个servo项目，并将Y2的逻辑加入进来。先将基本逻辑写一下。

### 电机项目的逻辑

## 4.27

开始阅读`parseMsg`部分代码逻辑。

现在基本理解了代码的逻辑，看逻辑其实需要将`parseMsg`部分的逻辑抽象并且集中一下。

这就不可避免地用到了`QtTest`，以下就是此项目配置单元测试框架，并且进行测试的记录

### QtTest

#### 功能与用途

- **支持单元测试**：`QtTest` 库为 Qt 项目提供了单元测试框架，借助 `QT += testlib` 这一配置，项目就能使用 `QtTest` 库的功能，编写和运行单元测试代码。
- **提供测试工具**：`QtTest` 库涵盖了众多用于测试的类和宏，例如 `QTest` 类、`QVERIFY`、`QCOMPARE` 等宏，这些工具能够帮助开发者高效地编写测试用例，验证代码的正确性。

#### 配置servo.pro

现在新建了一个目录`/test`，并且新建文件`servotest.cpp`，这样配置下`servo.pro`的参数

```make

QT       += testlib
SOURCES += test/servoTest.cpp
```

但是此时有一个问题🤔，就是

- `src/main.cpp` 是**正常程序入口**
- `test/servoTest.cpp` 里面的 `QTEST_MAIN(TestFoo)` 也会生成一个**main函数**

这样就会导致重复定义`main`，链接的时候就会报错。

#### 解决重定义main

这里用了一个用宏来控制编译的方法来解决💡

在 `test/servoTest.cpp` 里，加条件编译：

```Cpp
// servotest.cpp
#ifdef UNIT_TEST
#include <QtTest>
#include "../ServoAgent.h"

class ServoAgentTest : public QObject {
    Q_OBJECT
private slots:
    void testParseJson_validData();
    void testParseJson_invalidData();
};

void ServoAgentTest::testParseJson_validData() {
    ServoAgent* agent = ServoAgent::get_instance();
    QByteArray validJson = R"({"cmd": 1, "motor": 2})";
    QVERIFY(agent->parseJson(validJson));  // 应返回true
    QVERIFY(!agent->m_lastObj.isEmpty());  // 检查解析结果
}

void ServoAgentTest::testParseJson_invalidData() {
    ServoAgent* agent = ServoAgent::get_instance();
    QByteArray invalidJson = "{bad json}";
    QVERIFY(!agent->parseJson(invalidJson)); // 应返回false
    QVERIFY(agent->m_lastObj.isEmpty());    // 结果应为空
}
QTEST_APPLESS_MAIN(ServoAgentTest)
#include "servotest.moc"
#endif
```

这样，只有当 `UNIT_TEST` 宏定义时，`test/servoTest.cpp` 才会真正参与编译。但是这样还需要配置其他参数，才能让测试变得方便快捷。

```make
QT += core testlib

TARGET = servo_project
TEMPLATE = app

HEADERS += \
    src/foo.h

SOURCES += \
    src/foo.cpp

# 区分测试模式
contains(CONFIG, unit_test) {
    message("Unit Test Mode Enabled")
    DEFINES += UNIT_TEST
    SOURCES += test/servoTest.cpp
} else {
    SOURCES += src/main.cpp
}
```

然后点击`项目`（针对qt creator4.11），Clone一份debug的构建设置，然后修改。

在构建栏中，点开qmake的选项，加入额外的参数`"CONFIG+=unit_test"`。这样下面的`有效的qmake调用`会展示

```bash
D:\develop\Qt\Qt5.14.2\5.14.2\mingw73_64\bin\qmake.exe E:\code_life\work\2025\servo\servo.pro -spec win32-g++ "CONFIG+=debug" "CONFIG+=qml_debug" "CONFIG+=unit_test" && D:/develop/Qt/Qt5.14.2/Tools/mingw730_64/bin/mingw32-make.exe qmake_all
```

这样的结果就是

- 加了 `CONFIG+=unit_test` ➔ `.pro` 文件里的 `contains(CONFIG, unit_test)` 成立
- `.pro` 文件就走测试路径 ➔ 编译测试
-  不加 `CONFIG+=unit_test` ➔ 默认跑 `src/main.cpp`，是正常程序

### 单例问题

单例实例的状态可能会被前一个测试方法修改，导致后续测试方法出现不可预测的行为。

### 🎯 单例模式导致的问题

1. **单例实例共享状态**： 在单例模式中，类的实例通常是全局唯一的，所有调用 `get_instance()` 的地方都会返回相同的实例。如果这个实例的状态（如 `m_lastObj`）在一个测试方法中发生了变化，它可能会影响到其他测试方法，因为这些测试方法共享相同的单例对象。
2. **测试间状态污染**： 由于单例对象的状态会在多个测试方法间共享，当一个测试修改了该状态时，其他测试可能会受到影响，导致测试结果不准确。这种情况通常被称为“状态污染”。
3. **测试不可重入性**： 由于单例模式的实例是唯一的，可能会导致测试代码在多个测试方法中不一致，特别是在不同的测试方法期望不同的初始状态时。

为了解决单例导致的问题，你可以在每个测试方法执行之前，手动重置单例对象的状态。通常，可以在单例类中添加一个 `reset` 或 `clear` 方法，用于清除单例状态。例如：

```Cpp
// ServoAgent.h
class ServoAgent : public QObject {
    Q_OBJECT
public:
    static ServoAgent* get_instance() {
        if (instance == nullptr) {
            instance = new ServoAgent();
        }
        return instance;
    }

    // Reset the singleton state (to be called in tests)
    static void reset_instance() {
        delete instance;
        instance = nullptr;
    }

    bool parseJson(const QByteArray& jsonData);

private:
    ServoAgent() {}
    static ServoAgent* instance;
    QJsonObject m_lastObj;
};

// ServoAgent.cpp
ServoAgent* ServoAgent::instance = nullptr;

void ServoAgent::reset_instance() {
    delete instance;
    instance = nullptr;
}

```

## 4.30

今天任务

- 研究如何通过添加使能字段，能够让servo项目配置某个电机是否使能。
- motor-control

### 电机配置使能

#### 需求描述

现在想加入电机使能配置字段`isEnable`。

- `isEnable`设置为1：电机使能。该电机的所有操作均可进行，UI按钮均可交互
- `isEnable`设置为0：电机不使用。UI交互屏蔽，并且所有操作均停止

#### 实现步骤

- 数据库操作，加入对于`isEnable`的支持
- UI按钮，加入对于`isEnable`的支持
- motor控制逻辑，加入对于`isEnable`的支持

#### 数据库支持

##### `DbCtrl`添加字段`isEnable`

涉及到数据库表`servoMotor_tb`的添加字段，所以需要在操作数据库表的`DbCtrl`中进行对应字段的支持

- 在结构体`T_servoMotor_tb`中，加入字段`int isEnable`
- 在函数`DbIint`中，
  - 在初始化创建表`servoMotor_tb`的逻辑中，加入字段`isEnable`的初始化。并且指定Y2电机使能断开。
  - 在获取`servoMotor_tb`的逻辑中，加入查询字段`isEnable`的支持。

这样第一步就完成了。检测是否字段添加成功，步骤如下：

- 删除`debug`下的数据库，重新构建项目，让代码执行sql语句，将`servoMotor_tb`创建并初始化。检测是否添加字段。
- 检查Y2电机的`isEnable`字段是否为0

如果两步均没问题，那么可以接下来加入对于该字段的查询和设置了。

##### 查询和设置字段

现在字段`isEnable`已经添加成功了，接下来就需要让`DbCtrl`支持查询和配置这个字段的功能。

- 查询是否使能：如果使能，返回为真；不使能，返回为假

  ```CPP
  static bool checkIfEnabled(qint32 motorID);
  ```

- 设置使能与屏蔽

  ```CPP
  static bool enableMotor(qint32 motorID);
  static bool blockMotorEnable(qint32 motorID);
  ```

添加代码完毕后，测试方法就是通过`QTest`进行校验。测试案例如下：

```cPP
void tst_DbCtrl::testDb_motorEnable()
{
    QVERIFY(DbCtrl::enableMotor(M_Y2));
    QVERIFY(DbCtrl::checkIfEnabled(M_Y2));
    QVERIFY(DbCtrl::blockMotorEnable(M_Y2));
    QVERIFY(!DbCtrl::checkIfEnabled(M_Y2));
}
```

至此数据库支持字段`isEnable`测试通过，可以进行下一步的UI按钮逻辑处理

#### UI支持

