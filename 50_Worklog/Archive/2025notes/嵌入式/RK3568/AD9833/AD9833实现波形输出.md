> ç›®æ ‡ï¼šç°åœ¨ AD9833 èŠ¯ç‰‡åœ¨ SPI æ§åˆ¶å™¨ 0ã€ç‰‡é€‰ä¿¡å· 0 çš„ä½ç½®ï¼Œè®©å®ƒç”Ÿæˆä¸€ä¸ª 1kHz çš„æ­£å¼¦æ³¢ã€‚

## 1.SPI é…ç½®

### æ¨¡å¼

SPI é€šä¿¡ä¾èµ–ä¸»è®¾å¤‡äº§ç”Ÿçš„åŒæ­¥æ—¶é’Ÿï¼ˆSCLKï¼‰ï¼Œä¸»ä»è®¾å¤‡é€šè¿‡ SCLK åŒæ­¥æ•°æ®ä¼ è¾“ã€‚åœ¨æ­¤é€šä¿¡æ¡ˆä¾‹ä¸­ï¼Œä¸»ä¸º CPU ï¼Œä»ä¸º AD9833ã€‚CPU å‘æ¥çš„æ•°æ®ä¼šåœ¨ SCLK çš„â€œè¾¹æ²¿â€è¢« AD9833 é‡‡æ ·ã€‚

å…·ä½“å†³å®šæ•°æ®é‡‡æ ·çš„ SPI å‚æ•°ä¸º CPOL å’Œ CPHAã€‚

- **CPOLï¼ˆClock Polarityï¼Œæ—¶é’Ÿææ€§ï¼‰**ï¼šç©ºé—²æ—¶çš„ç”µå¹³
- **CPHAï¼ˆClock Phaseï¼Œæ—¶é’Ÿç›¸ä½ï¼‰**ï¼šæ•°æ®é‡‡æ ·çš„è¾¹æ²¿ã€‚å–å€¼`0` æˆ– `1`ï¼Œå†³å®šä¸»ä»è®¾å¤‡åœ¨ SCLK çš„ â€œç¬¬å‡ ä¸ªè·³å˜æ²¿â€ é‡‡æ ·æ•°æ®ï¼š
  - **CPHA=0**ï¼šæ•°æ®åœ¨ SCLK çš„ â€œç¬¬ä¸€ä¸ªè¾¹æ²¿â€ï¼ˆç©ºé—²ç”µå¹³â†’æ¿€æ´»ç”µå¹³çš„è·³å˜æ²¿ï¼‰è¢«é‡‡æ ·ã€‚
  - **CPHA=1**ï¼šæ•°æ®åœ¨ SCLK çš„ â€œç¬¬äºŒä¸ªè¾¹æ²¿â€ï¼ˆæ¿€æ´»ç”µå¹³â†’ç©ºé—²ç”µå¹³çš„è·³å˜æ²¿ï¼‰è¢«é‡‡æ ·ã€‚

AD9833 æ˜ç¡®è¯´æ˜æ˜¯åœ¨ SCLK çš„ä¸‹é™æ²¿è·å–æ•°æ®ï¼Œå¹¶ä¸” SCLK ç©ºé—²æ—¶å€™æ—¢å¯ä»¥é«˜ä¹Ÿå¯ä»¥ä½ã€‚

æ ¹æ®â€œå›¾4 ä¸²è¡Œæ—¶åºâ€çŸ¥é“ï¼Œåœ¨ FSYNC å˜ä½å‰åï¼ŒSCLK ä¸ºé«˜ç”µå¹³ï¼Œç„¶å SCLK çš„ç¬¬ä¸€ä¸ªè¾¹æ²¿ä¸ºä¸‹é™æ²¿ã€‚æ‰€ä»¥æˆ‘ä»¬é€‰æ‹© `SPI_MODE_2`ã€‚

### ä½æ•°

AD9833 æ¯æ¬¡ä¼ è¾“æ˜¯ **16 ä½æ•°æ®å­—**ã€‚å¯„å­˜å™¨å†™å…¥ï¼ˆé¢‘ç‡å¯„å­˜å™¨æ˜¯ 28 ä½ï¼Œè¦åˆ†ä¸¤æ¬¡å†™ 16 ä½ï¼‰

æœ‰çš„ MCUï¼ˆæ¯”å¦‚ 8051ï¼Œ68HC11ï¼‰SPI å¤–è®¾ **åªèƒ½æŒ‰ 8 ä½å­—èŠ‚å‘é€**ï¼Œä¸èƒ½ç›´æ¥ 16 ä½ã€‚

æ‰‹å†Œé‡Œä¹Ÿç»™å‡ºäº† 8051/68HC11 çš„ä¾‹å­AD9833_CNï¼š

- åšæ³•æ˜¯ï¼š
  - **è¿ç»­å†™ä¸¤ä¸ª 8 ä½å­—èŠ‚**ï¼ŒFSYNC åœ¨æ•´ä¸ª 16 ä½ä¼ è¾“è¿‡ç¨‹ä¸­ä¿æŒä½ç”µå¹³ã€‚
  - è¿™æ · AD9833 å°±èƒ½æ­£ç¡®åœ°æŠŠè¿™ä¸¤ä¸ªå­—èŠ‚æ‹¼æˆä¸€ä¸ª 16 ä½å­—ã€‚

### é¡ºåº

åœ¨æ‰‹å†Œ **ç¬¬ 20 é¡µã€Šä¸å¾®å¤„ç†å™¨æ¥å£ã€‹**ï¼ˆ80C51 ä¾‹å­ï¼‰ä¸­å®šä¹‰äº†é¡ºåºï¼š

> â€œ80C51/80L51 ä»¥ **LSB ä¼˜å…ˆ** æ ¼å¼è¾“å‡ºä¸²è¡Œæ•°æ®ã€‚
>  AD9833 é¦–å…ˆæ¥æ”¶ **MSB**ï¼ˆå†™å…¥ç›®æ ‡å¯„å­˜å™¨æ—¶ï¼Œ4 ä¸ª MSB ä¸ºæ§åˆ¶ä¿¡æ¯ â€¦ï¼‰ã€‚
>  å› æ­¤ï¼Œ80C51 çš„å‘é€ç¨‹åºå¿…é¡»é‡æ–°æ’åˆ—ä½é¡ºåºï¼Œä½¿å¾—é¦–å…ˆè¾“å‡º **MSB**ã€‚â€

- **AD9833 è¦æ±‚å…ˆä¼ è¾“ MSB**ï¼Œå†ä¼ è¾“ LSBï¼ˆå³ **MSB first**ï¼‰AD9833_CNã€‚
- ä¾‹å¦‚ï¼šå†™ `0x2100`ï¼Œè¦å…ˆå‘ `0x21`ï¼Œå†å‘ `0x00`ã€‚

æ‰‹å†Œæ˜ç¡®è¯´äº† 8051 é»˜è®¤æ˜¯ LSB firstï¼Œä½† AD9833 è¦æ±‚ MSB firstï¼Œå› æ­¤éœ€è¦è½¯ä»¶é‡æ–°æ’å­—èŠ‚é¡ºåº

âœ… æ‰€ä»¥ï¼Œæœ€æ˜ç¡®çš„åœ°æ–¹å°±æ˜¯æ‰‹å†Œ **ç¬¬ 20â€“21 é¡µ**ï¼Œå‚å®¶ç›´æ¥å‘Šè¯‰ä½ ï¼š

- **AD9833 æ¥å£å¿…é¡» MSB first**ã€‚
- å¦‚æœ MCU é»˜è®¤ LSB firstï¼ˆæ¯”å¦‚ 8051ï¼‰ï¼Œå¿…é¡»è½¯ä»¶å€’åºã€‚

æ­¤æ—¶ï¼Œè¦è¾“å‡ºæ­£å¼¦æ³¢ï¼Œè¿˜æ¶‰åŠä¸¤ä¸ªéƒ¨åˆ†ï¼šæ§åˆ¶å¯„å­˜å™¨å’Œé¢‘ç‡å¯„å­˜å™¨ã€‚æˆ‘ä»¬ä¾æ¬¡æ¥çœ‹ã€‚

## 2.æ§åˆ¶å¯„å­˜å™¨

ä¸‹è¡¨æ˜¯æ‰‹å†Œé‡Œçš„å®šä¹‰ï¼ˆæ•´ç†ç®€åŒ–ç‰ˆï¼‰ï¼š

| ä½ (D15â€¦D0)       | åç§°               | åŠŸèƒ½è¯´æ˜                                                     |
| ----------------- | ------------------ | ------------------------------------------------------------ |
| **D15:D14**       | å¿…é¡»=00            | è¡¨ç¤ºè¿™æ˜¯æ§åˆ¶å¯„å­˜å™¨å†™æ“ä½œï¼ˆåŒºåˆ†å’Œé¢‘ç‡/ç›¸ä½å¯„å­˜å™¨å†™å…¥ï¼‰        |
| **D13 (B28)**     | é¢‘ç‡å¯„å­˜å™¨å†™å…¥æ–¹å¼ | 1=è¿ç»­å†™å…¥å®Œæ•´ 28 ä½é¢‘ç‡å­—ï¼ˆæ¨èï¼‰ï¼Œ0=åªå†™ 14 ä½ï¼ˆMSB æˆ– LSBï¼‰ã€‚ |
| **D12 (HLB)**     | åŠå­—é€‰æ‹©           | å½“ B28=0 æ—¶æœ‰æ•ˆï¼›1=å†™é«˜ 14 ä½ï¼Œ0=å†™ä½ 14 ä½ã€‚                |
| **D11 (FSELECT)** | é¢‘ç‡å¯„å­˜å™¨é€‰æ‹©     | 0=FREQ0ï¼Œ1=FREQ1ã€‚å†³å®šå½“å‰è¾“å‡ºç”¨å“ªä¸ªé¢‘ç‡å¯„å­˜å™¨ã€‚             |
| **D10 (PSELECT)** | ç›¸ä½å¯„å­˜å™¨é€‰æ‹©     | 0=PHASE0ï¼Œ1=PHASE1ã€‚                                         |
| **D9**            | ä¿ç•™               | å¿…é¡»å†™ 0ã€‚                                                   |
| **D8 (RESET)**    | å¤ä½æ§åˆ¶           | 1=è¾“å‡ºå›ºå®šåœ¨ä¸­ç‚¹ç”µå¹³ï¼ˆæ³¢å½¢åœæ­¢ï¼‰ï¼Œ0=æ­£å¸¸è¾“å‡ºã€‚               |
| **D7 (SLEEP1)**   | æ—¶é’Ÿä¼‘çœ            | 1=å…³é—­ MCLKï¼ˆèŠ‚èƒ½ï¼ŒDAC è¾“å‡ºä¿æŒï¼‰ï¼Œ0=æ­£å¸¸ã€‚                  |
| **D6 (SLEEP12)**  | DAC ä¼‘çœ            | 1=å…³é—­ DACï¼ˆçœç”µï¼‰ï¼Œ0=æ­£å¸¸ã€‚                                 |
| **D5 (OPBITEN)**  | è¾“å‡ºé€‰æ‹©å¼€å…³       | 0=æ­£å¸¸æ³¢å½¢ï¼ˆæ­£å¼¦/ä¸‰è§’ï¼‰ï¼Œ1=è¾“å‡ºæ–¹æ³¢ï¼ˆDAC æ•°æ® MSB æˆ– MSB/2ï¼‰ã€‚ |
| **D4**            | ä¿ç•™               | å¿…é¡»å†™ 0ã€‚                                                   |
| **D3 (DIV2)**     | æ–¹æ³¢åˆ†é¢‘           | å½“ OPBITEN=1 æ—¶æœ‰æ•ˆï¼›0=è¾“å‡º MSBï¼Œ1=è¾“å‡º MSB/2ã€‚              |
| **D2**            | ä¿ç•™               | å¿…é¡»å†™ 0ã€‚                                                   |
| **D1 (MODE)**     | æ³¢å½¢æ¨¡å¼           | 0=æ­£å¼¦æ³¢ï¼Œ1=ä¸‰è§’æ³¢ï¼ˆæ³¨æ„ï¼šOPBITEN=1 æ—¶æ— æ•ˆï¼‰ã€‚               |
| **D0**            | ä¿ç•™               | å¿…é¡»å†™ 0ã€‚                                                   |

------

### æ§åˆ¶åˆ¶å¯„å­˜å™¨è®¾ç½®

ç›®æ ‡ï¼šæ­£å¼¦æ³¢è¾“å‡ºã€DAC æ­£å¸¸å·¥ä½œã€ä½¿ç”¨ FREQ0ã€‚
 æ ¹æ®è¡¨æ ¼ï¼š

- D15:D14 = `00` ï¼ˆæ§åˆ¶å¯„å­˜å™¨å†™æ“ä½œï¼‰
- B28 (D13) = `1` â†’ å…è®¸ä¸€æ¬¡å†™å®Œæ•´ 28 ä½é¢‘ç‡å­—ï¼ˆæ¨èæ–¹å¼ï¼‰
- HLB (D12) = `X` ï¼ˆB28=1 æ—¶å¿½ç•¥ï¼‰
- FSELECT (D11) = `0` â†’ ä½¿ç”¨ FREQ0
- PSELECT (D10) = `0` â†’ ä½¿ç”¨ PHASE0ï¼ˆé»˜è®¤ç›¸ä½ï¼‰
- RESET (D8) = `0` â†’ å…è®¸è¾“å‡ºï¼ˆåˆå§‹åŒ–æ—¶å¯ä»¥å…ˆç½® 1ï¼Œç„¶åæ¸… 0ï¼‰
- SLEEP1/SLEEP12 (D7/D6) = `0` â†’ ä¸ä¼‘çœ 
- OPBITEN (D5) = `0` â†’ è¾“å‡º DAC æ³¢å½¢ï¼ˆè€Œä¸æ˜¯æ–¹æ³¢ï¼‰
- DIV2 (D3) = `0`
- MODE (D1) = `0` â†’ æ­£å¼¦æ³¢
- å…¶ä»–ä¿ç•™ä½ = `0`

ğŸ‘‰ è¿™ä¸ªæ§åˆ¶å­—æœ€ç»ˆå°±æ˜¯ï¼š

```C
D15:D0 = 0b0010000000000000 = 0x2000
```

## 3.é¢‘ç‡å¯„å­˜å™¨

è¾“å‡ºé¢‘ç‡ç”±å…¬å¼å†³å®š:
$$
f_{OUT} = \frac{FREQREG \times f_{MCLK}}{2^{28}}
$$
å·²çŸ¥ï¼š

- f_OUT = 1 kHz
- f_MCLK = 25 MHzï¼ˆå¸¸ç”¨æ¿è½½æ™¶æŒ¯ï¼‰

è§£å¾—ï¼š
$$
FREQREG = \frac{f_{OUT} \times 2^{28}}{f_{MCLK}}
= \frac{1000 \times 268435456}{25\,000\,000} \approx 10737 \; (0x29E1)
$$
å³ FREQ0 = `0x29E1`ï¼ˆ28 ä½å¯„å­˜å™¨ï¼‰ã€‚

å› ä¸ºæ˜¯ 28 ä½å¯„å­˜å™¨ï¼Œè¦åˆ†ä¸¤æ¬¡å†™å…¥ï¼š

* å…ˆå†™ **ä½ 14 ä½**ï¼ˆ0x29E1 & 0x3FFF = 0x29E1ï¼‰
* å†å†™ **é«˜ 14 ä½**ï¼ˆ0x29E1 >> 14 = 0x0ï¼‰

å†™å…¥æ—¶ï¼Œæ¯ä¸ªå­—è¦åŠ ä¸Šå¯„å­˜å™¨é€‰æ‹©ä½ï¼ˆD15\:D14ï¼‰ï¼š

* å†™ä½ 14 ä½ â†’ å‰ç¼€ `01`ï¼Œå³ 0x2000 | (0x29E1 & 0x3FFF) = **0x29E1**
* å†™é«˜ 14 ä½ â†’ å‰ç¼€ `01`ï¼Œæ•°æ®=0 â†’ **0x2000**

## 4. å®Œæ•´é…ç½®æ­¥éª¤

1. **å¤ä½ AD9833**
   - å†™æ§åˆ¶å¯„å­˜å™¨ï¼ŒRESET=1ï¼ˆ0x2100ï¼‰ã€‚
2. **å†™é¢‘ç‡å¯„å­˜å™¨ FREQ0**
   - å†™ä½å­—ï¼š0x29E1
   - å†™é«˜å­—ï¼š0x2000
3. **å†™æ§åˆ¶å¯„å­˜å™¨ï¼Œæ­£å¸¸è¾“å‡ºæ­£å¼¦æ³¢**
   - 0x2000ï¼ˆRESET=0, æ­£å¼¦æ³¢, FREQ0, æ­£å¸¸å·¥ä½œï¼‰ã€‚

## 5.C ä»£ç ç¤ºä¾‹

```C
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/spi/spidev.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <getopt.h>

// AD9833 å¯„å­˜å™¨åœ°å€å®šä¹‰
#define AD9833_REG_CMD     0x0000
#define AD9833_REG_FREQ0   0x4000
#define AD9833_REG_FREQ1   0x8000
#define AD9833_REG_PHASE0  0xC000
#define AD9833_REG_PHASE1  0xE000

// AD9833 æ§åˆ¶ä½å®šä¹‰
#define AD9833_B28         0x2000
#define AD9833_HLB         0x1000
#define AD9833_FSELECT     0x0800
#define AD9833_PSELECT     0x0400
#define AD9833_RESET       0x0100
#define AD9833_SLEEP1      0x0080
#define AD9833_SLEEP12     0x0040
#define AD9833_OPBITEN     0x0020
#define AD9833_DIV2        0x0008
#define AD9833_MODE        0x0002

// SPI è®¾å¤‡è·¯å¾„
#define SPI_DEVICE "/dev/spidev0.0"

// AD9833 ä¸»æ—¶é’Ÿé¢‘ç‡ (æ ¹æ®å®é™…ç¡¬ä»¶é…ç½®)
#define MCLK_FREQUENCY 25000000.0

// å…¨å±€å˜é‡
static int spi_fd = -1;

/**
 * @brief åˆå§‹åŒ– SPI æ¥å£
 * @return æˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1
 */
int spi_init(void) {
  uint8_t mode = SPI_MODE_2;
  uint8_t bits = 8;
  uint32_t speed = 1000000;
  
  spi_fd = open(SPI_DEVICE, O_RDWR);
  if (spi_fd < 0) {
    perror("æ— æ³•æ‰“å¼€SPIè®¾å¤‡");
    return -1;
  }
  
  if (ioctl(spi_fd, SPI_IOC_WR_MODE, &mode) < 0) {
    perror("æ— æ³•è®¾ç½®SPIæ¨¡å¼");
    close(spi_fd);
    return -1;
  }
  
  if (ioctl(spi_fd, SPI_IOC_WR_BITS_PER_WORD, &bits) < 0) {
    perror("æ— æ³•è®¾ç½®SPIå­—é•¿");
    close(spi_fd);
    return -1;
  }
  
  if (ioctl(spi_fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed) < 0) {
    perror("æ— æ³•è®¾ç½®SPIé€Ÿåº¦");
    close(spi_fd);
    return -1;
  }
  
  return 0;
}

/**
 * @brief å‘AD9833å†™å…¥16ä½æ•°æ®
 * @param data è¦å†™å…¥çš„16ä½æ•°æ®
 * @return æˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1
 */
int ad9833_write(uint16_t data) {
  uint8_t tx_buf[2];
  uint8_t rx_buf[2];
  struct spi_ioc_transfer tr;
  
  tx_buf[0] = (data >> 8) & 0xFF;
  tx_buf[1] = data & 0xFF;
  
  memset(&tr, 0, sizeof(tr));
  tr.tx_buf = (unsigned long)tx_buf;
  tr.rx_buf = (unsigned long)rx_buf;
  tr.len = 2;
  tr.delay_usecs = 0;
  tr.speed_hz = 1000000;
  tr.bits_per_word = 8;
  tr.cs_change = 0;
  
  if (ioctl(spi_fd, SPI_IOC_MESSAGE(1), &tr) < 0) {
    perror("SPIä¼ è¾“å¤±è´¥");
    return -1;
  }
  
  usleep(10);
  
  return 0;
}

/**
 * @brief é‡ç½®AD9833
 */
void ad9833_reset(void) {
  ad9833_write(AD9833_REG_CMD | AD9833_RESET);
  usleep(10000);
  
  ad9833_write(AD9833_REG_CMD | AD9833_B28);
  usleep(10000);
}

/**
 * @brief è®¾ç½®AD9833è¾“å‡ºé¢‘ç‡
 * @param freq æ‰€éœ€è¾“å‡ºé¢‘ç‡(Hz)
 * @param reg é¢‘ç‡å¯„å­˜å™¨(0æˆ–1)
 */
void ad9833_set_frequency(double freq, int reg) {
  uint32_t freq_word;
  uint16_t reg_addr;
  
  freq_word = (uint32_t)((freq * 268435456.0) / MCLK_FREQUENCY);
  
  reg_addr = (reg == 0) ? AD9833_REG_FREQ0 : AD9833_REG_FREQ1;
  
  ad9833_write(reg_addr | (freq_word & 0x3FFF));
  ad9833_write(reg_addr | ((freq_word >> 14) & 0x3FFF));
}

/**
 * @brief è®¾ç½®AD9833è¾“å‡ºç›¸ä½
 * @param phase_deg ç›¸ä½è§’åº¦(åº¦)
 * @param reg ç›¸ä½å¯„å­˜å™¨(0æˆ–1)
 */
void ad9833_set_phase(double phase_deg, int reg) {
  uint16_t phase_word;
  uint16_t reg_addr;
  
  phase_word = (uint16_t)((phase_deg * 4096.0) / 360.0) & 0x0FFF;
  
  reg_addr = (reg == 0) ? AD9833_REG_PHASE0 : AD9833_REG_PHASE1;
  
  ad9833_write(reg_addr | phase_word);
}

/**
 * @brief é…ç½®AD9833è¾“å‡ºæ¨¡å¼
 * @param mode è¾“å‡ºæ¨¡å¼(0=æ­£å¼¦æ³¢, 1=ä¸‰è§’æ³¢, 2=æ–¹æ³¢)
 */
void ad9833_set_output_mode(int mode) {
  uint16_t config = AD9833_REG_CMD | AD9833_B28;
  
  if (mode == 1) {
    // ä¸‰è§’æ³¢è¾“å‡º
    config |= AD9833_MODE;
  } else if (mode == 2) {
    // æ–¹æ³¢è¾“å‡º (ç¬¦å·ä½è¾“å‡º)
    config |= AD9833_OPBITEN;
  }
  
  ad9833_write(config);
}

void print_usage(const char *prog_name) {
  printf("ç”¨æ³•: %s [é€‰é¡¹]\n", prog_name);
  printf("é€‰é¡¹:\n");
  printf("  -f, --frequency <é¢‘ç‡>   è®¾ç½®è¾“å‡ºé¢‘ç‡ (Hz), é»˜è®¤: 1000.0\n");
  printf("  -w, --waveform <æ³¢å½¢>  è®¾ç½®è¾“å‡ºæ³¢å½¢, å¯é€‰: sine, triangle, square, é»˜è®¤: sine\n");
  printf("  -h, --help         æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯\n");
}

int main(int argc, char *argv[]) {
  double output_freq = 1000.0;
  char *waveform_str = "sine";
  int waveform_mode = 0; // 0=sine, 1=triangle, 2=square
  int c;

  // å®šä¹‰é•¿é€‰é¡¹
  static struct option long_options[] = {
    {"frequency", required_argument, 0, 'f'},
    {"waveform",  required_argument, 0, 'w'},
    {"help",    no_argument,     0, 'h'},
    {0, 0, 0, 0}
  };

  // è§£æå‘½ä»¤è¡Œå‚æ•°
  while ((c = getopt_long(argc, argv, "f:w:h", long_options, NULL)) != -1) {
    switch (c) {
      case 'f':
        output_freq = atof(optarg);
        break;
      case 'w':
        waveform_str = optarg;
        if (strcmp(waveform_str, "sine") == 0) {
          waveform_mode = 0;
        } else if (strcmp(waveform_str, "triangle") == 0) {
          waveform_mode = 1;
        } else if (strcmp(waveform_str, "square") == 0) {
          waveform_mode = 2;
        } else {
          fprintf(stderr, "é”™è¯¯: æ— æ•ˆçš„æ³¢å½¢ç±»å‹ '%s'. é»˜è®¤ä½¿ç”¨æ­£å¼¦æ³¢.\n", waveform_str);
          waveform_mode = 0;
        }
        break;
      case 'h':
        print_usage(argv[0]);
        return EXIT_SUCCESS;
      case '?':
        // getopt_long å·²ç»æ‰“å°äº†é”™è¯¯ä¿¡æ¯
        print_usage(argv[0]);
        return EXIT_FAILURE;
      default:
        break;
    }
  }

  printf("AD9833 ä»»æ„æ³¢å½¢å‘ç”Ÿå™¨\n");
  printf("é…ç½®å‚æ•°: é¢‘ç‡=%.2f Hz, æ³¢å½¢=%s\n", output_freq, waveform_str);

  if (spi_init() != 0) {
    fprintf(stderr, "SPIåˆå§‹åŒ–å¤±è´¥\n");
    return EXIT_FAILURE;
  }
  
  printf("SPIæ¥å£åˆå§‹åŒ–æˆåŠŸ\n");
  
  ad9833_reset();
  printf("AD9833å¤ä½å®Œæˆ\n");
  
  ad9833_set_frequency(output_freq, 0);
  printf("è®¾ç½®é¢‘ç‡: %.2f Hz\n", output_freq);
  
  ad9833_set_phase(0.0, 0);
  printf("è®¾ç½®ç›¸ä½: 0åº¦\n");
  
  ad9833_set_output_mode(waveform_mode);
  printf("è®¾ç½®ä¸º %s è¾“å‡ºæ¨¡å¼\n", waveform_str);
  
  // ad9833_write(AD9833_REG_CMD | AD9833_B28);
  // printf("å¯ç”¨è¾“å‡º\n");
  
  printf("æŒ‰ Enter é”®é€€å‡º...\n");
  getchar();
  
  close(spi_fd);
  printf("ç¨‹åºç»“æŸ\n");
  
  return EXIT_SUCCESS;
}
```

