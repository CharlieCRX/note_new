这部分内容是以开发板`RK3568`配置网络时候所总结。

# 判断网线对应的接口

> [!NOTE] 问题场景
> 当我把网线插在了开发板的`RJ45`网口后，如何查看网线是否连接上了？

省流，解决办法只需要：

1. **在插入网线前**，用 `ip link` 命令记录下所有接口的状态。
2. **插入网线后**，再次运行 `ip link`。
3. **对比两次输出**，唯一发生变化的那个接口，就是您插入网线的物理接口。

下面讲解下，关于其中命令的解释，请看[[网络命令]]。

## 1. 插入网线前的接口状态

### 查看接口信息

使用`ip link`查看所有接口的状态。现在我们以当前开发板`RK3568`的输出为例：

```bash
root@RK356X:/# ip link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: dummy0: <BROADCAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/ether 0e:bc:d9:ab:d8:e7 brd ff:ff:ff:ff:ff:ff
3: eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether be:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
4: eth1: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN mode DEFAULT group default qlen 1000
    link/ether ba:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
```

其中每个网络接口的功能：

- `lo` (Loopback 接口)：Linux 默认的回环接口。`<LOOPBACK,UP,LOWER_UP>`标志明确说明这是回环接口并且已经启用。
  - 其特征：`LOOPBACK, MTU 65536, 00:00:00:00:00:00`
- `dummy0` (Dummy 接口)：Linux 中常用 `dummy` 设备作为测试或虚拟接口。`<BROADCAST,NOARP,UP,LOWER_UP>`：
  - `NOARP`：不会发送 ARP 请求，典型虚拟接口特征。
  - `BROADCAST`：支持广播，但这不意味着是物理网口。
- `eth0` (以太网接口 0)
- `eth1` (以太网接口 1)

那么到底是`eth0`还是`eth1`接口对应的网口呢？

### 驱动信息

这里首先提供一个简单思路就是查看两个接口的驱动信息，物理网口通常会显示 `driver`、`firmware-version`。

其执行命令为：

```bash
ethtool -i <接口名>
```

我们执行下：

```bash
root@RK356X:/# ethtool -i eth0  
Cannot get driver information: Device or resource busy

root@RK356X:/# ethtool -i eth1
driver: st_gmac
version: Jan_2016
firmware-version: 
expansion-rom-version: 
bus-info: 
supports-statistics: yes
supports-test: no
supports-eeprom-access: no
supports-register-dump: yes
supports-priv-flags: no
```

可以看出：

- `eth0`

  - 系统无法获取驱动信息，可能是驱动被占用或接口未初始化完全。

  - 结合其他信息（比如 `/sys/class/net/eth0/device` 是否存在）才能判断是否是物理网口。

- `eth1`

  ```bash
  driver: st_gmac
  supports-statistics: yes
  supports-register-dump: yes
  ```

  - 有真实驱动 `st_gmac`。
  - 支持统计和寄存器访问。
  - ✅ 明显 **物理网口**。

## 2. 插入网线

### 接口灯闪烁

- 将网线插入您的设备上的**网线接口**。
- 等待几秒钟，给系统一点时间来检测物理连接。
- 观察网口灯：
  - 亮 → 物理层检测到链路
  - 闪烁 → 有数据传输
  - 灭 → 没有链路或者接口关闭

如果观察到亮且闪烁，代表网线已经插好，物理层链路正常。这时候就可以再次执行 `ip link`检查状态了。

### 查看接口信息

再次执行 `ip link`，仔细观察输出的变化。如果 `eth0` 或者`eth1`是插入网线的接口，它的状态应该会从 `DOWN` 变为 `UP,LOWER_UP` 或 `UP,CARRIER`。

```bash
root@RK356X:/# ip link    
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: dummy0: <BROADCAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/ether 0e:bc:d9:ab:d8:e7 brd ff:ff:ff:ff:ff:ff
3: eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether be:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
4: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether ba:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
```

可以观察到，`eth1`接口在插入网线后的状态变为了

```bash
<BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP
```

- `state UP` → 表示接口的整体状态（逻辑+物理层综合）已启用
- `LOWER_UP` → PHY 层链路有效
- `UP` → 软件层已经启用

这就可以判断`eth1`是与网线接口关联的了。

# IP 地址与子网掩码

了解了`eth1`关联了网口后，下一步就是需要配置`eth1`接口的 IP 地址和子网掩码了。这里简单讲解下IP和子网掩码的一些知识：

------

## 1️⃣ 子网掩码的作用

子网掩码（netmask）决定了 **IP 地址哪一部分是“网络号”**，哪一部分是“主机号”：

- `/24` → 255.255.255.0 → 前 24 位是网络号，最后 8 位是主机号
- `/8`  → 255.0.0.0   → 前 8 位是网络号，后 24 位是主机号

网络号相同的主机被认为在同一个子网内，可以直接通信（不用路由）。

------

## 2️⃣ 举例对比

### (a) `10.1.2.55/24`

- 子网掩码 `/24` → 网络号是 `10.1.2.0`
- 可用 IP 范围：`10.1.2.1 ~ 10.1.2.254`
- PC 的 IP 是 `10.1.2.9/8` → 网络号是 `10.0.0.0`
- **结果**：RK3568 认为 PC 不在同一子网，需要走默认路由，而默认路由可能指向 169.254.x.x（APIPA），因此通信失败。

### (b) `10.1.2.55/8`

- 子网掩码 `/8` → 网络号是 `10.0.0.0`
- 可用 IP 范围：`10.0.0.1 ~ 10.255.255.254`
- PC 的 IP `10.1.2.9/8` → 网络号也是 `10.0.0.0`
- **结果**：RK3568 认为 PC 在同一子网，可以直接通信。

------

## 3️⃣ 总结

| 配置         | RK3568 网络号 | PC 网络号 | 是否同一子网 |
| ------------ | ------------- | --------- | ------------ |
| 10.1.2.55/24 | 10.1.2.0      | 10.0.0.0  | ❌ 否         |
| 10.1.2.55/8  | 10.0.0.0      | 10.0.0.0  | ✅ 是         |

> **核心原因**：通信是否成功不是看 IP 是否一样，而是**两台设备是否在同一个网络号内**。子网掩码决定了这个“网络号”。

# 网线直连

## 理由

- 排除中间设备干扰：确保链路层（L2）报文直接到对方网口，不会被其他设备拦截

- 确保 ARP 广播可达：直连等于保证 **ARP request** 一定能到对方网卡，并收到 **ARP reply**

- 排查问题简单：

  ```bash
  PC网卡 <——网线——> RK3568网卡
  ```

  - 任何 ping 不通的问题，几乎只可能是：
    1. IP/掩码配置错误
    2. 网线问题（或网口坏）
    3. 双方网卡驱动/状态不正常

## 排查步骤

### 1. 设置Windows PC网络

设置为`192.168.137.xx/24`网段来直连。

设置完毕后，能在 `CMD` 中通过

```cmd
ipconfig
```

看到

```cmd
以太网适配器 以太网:
   IPv4 地址  . . . . . . . . . . : 192.168.137.99
   子网掩码  . . . . . . . . . . : 255.255.255.0
```

### 2. RK3568 配置 IP

之前我们排查出 RK3568 的 eth1 网口是跟网线连接的。所以给 eth1 配置与 Windows PC 相同的网段不同 IP。

在 RK3568 上

```bash
ifconfig eth1 192.168.137.22 netmask 255.255.255.0 up
```

或者（推荐用 ip 命令）：

```bash
ip addr flush dev eth1
ip addr add 192.168.137.22/24 dev eth1
ip link set eth1 up
```

验证

```bash
root@RK356X:/# ip addr show eth1
4: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether ba:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
    inet 192.168.137.22/24 scope global eth1
       valid_lft forever preferred_lft forever
    inet6 fe80::9563:4c46:7d91:3623/64 scope link 
       valid_lft forever preferred_lft forever
```

应看到

```bash
inet addr:192.168.137.22  Mask:255.255.255.0
```

### 3. 互相 Ping 测试

在 **RK3568** 上：

```bash
root@RK356X:/# ping 192.168.137.99 -c 3
PING 192.168.137.99 (192.168.137.99) 56(84) bytes of data.
From 192.168.137.22 icmp_seq=1 Destination Host Unreachable
From 192.168.137.22 icmp_seq=2 Destination Host Unreachable
From 192.168.137.22 icmp_seq=3 Destination Host Unreachable

--- 192.168.137.99 ping statistics ---
3 packets transmitted, 0 received, +3 errors, 100% packet loss, time 2014ms
pipe 3
```

在 **Windows** 上：

```cmd
ping 192.168.137.22
```

也是不通的，所以现在需要拷贝一个自己的系统版本到 RK 3568 中，进一步检查问题。
