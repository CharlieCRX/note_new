# 2025.3

## 3.1

今天周六，门锁师傅7点就电话给我，安排半小时以后的门锁安装。和宝贝的早餐在Burger King吃的，油条很不错。

在吃早饭的时候，发现自己记账，上个月花了4400元。我去，这个月能否控制在1500左右呢？试试看

今天还是老规矩，先重写代码，然后学习新题目。

------

 10:00 - 开始

#### 《流浪地球》题目

**语法**

1. `calloc()`函数的用法

   代码中出现了之前并没有接触过的函数`calloc()`:

   ```C
   int *ans = (int *)calloc(n, sizeof(int));
   ```

   函数原型为：

   ```C
   void* calloc(size_t num, size_t size);
   ```

   `calloc()`也是内存分配函数，但是会将分配的每个字节设为`0`。动态分配的整型数组`ans`所有的数据初始化就为`0`。

2. 整型数组指针

   用来保存手动启动发动机的信息。

   ```C
   int **manual_events = (int **)malloc(manual_event_count * sizeof(int *));
   ```

**逻辑**

1. 最晚扩散时间

   为什么时间循环上限改为`engine_count + 1`？

   ```C
    for (int current_time = 0; current_time <= engine_count + 1; ++current_time) {}
   ```

   答：发现一个问题，如果N=6，E=1，然后T=6，P=0的话，正常扩散的时间和位置顺序应该是

   > T = 6:	P = 0;
   >
   > T = 7:	P = 5, 1;
   >
   > T = 8:	P = 4, 2;
   >
   > T = 9:	P = 3

   正确输出的结果应该为

   > 1
   >
   > 3

   但是按照现在的代码逻辑，处理时间`current_time`最大值是`7`，所以会导致省略了最后一步扩散的步骤，会输出

   > 2
   >
   > 2 4

   在发动机扩散问题中，时间循环上限 `current_time <= engine_count + 1` 的设定存在漏洞，导致某些场景无法正确处理。

   那么最长时间应该是多少呢？简单模拟一个最坏的时间。假定时间T = N时从索引0的发动机开始启动，并且只通过扩散启动的方式，单向传递。这样最坏的时间为`2*N`。

   而我们由于采用了环形扩散启动的方式，肯定小于这个最坏时间。所以这里的循环上限可以设置为`2*engine_count`.

2. 找左右邻居发动机

   ```C
   int left_neighbor = (current_engine - 1 + engine_count) % engine_count;
   int right_neighbor = (current_engine + 1) % engine_count;
   ```

3. 存储手动启动发动机的时间和编号

   ```C
   int **manual_events = (int **)malloc(manual_event_count * sizeof(int *));
   ```

**数据结构和算法**

1. 循环队列的长度

   ```C
   int len = isQueueEmpty(&engines_to_spread) ? 0 : (
     (engines_to_spread.rear >= engines_to_spread.front) ? (engines_to_spread.rear - engines_to_spread.front + 1) :
       (engines_to_spread.capacity - (engines_to_spread.front - engines_to_spread.rear - 1));
   );
   ```

2. 入队操作

   ```c
   // 元素入队
   void enqueue(Queue *q, int value) {
     if (isQueueEmpty(q)) {
       q->front = 0;
     }
     q->rear = (q->rear + 1) % q->capacity;
     q->data[q->rear] = value;
   }
   ```

   如果空队列，则添加一个元素后，对列的`front`值会变为0。而`rear`元素需要经过处理后使用。

 现在是晚上20：54，梳理下《流浪地球》题目的逻辑，然后写一遍代码再休息。

1. 创建一个在此时刻启动的发动机编号队列`engines_to_spread`（待扩散）
2. 将当前时刻`current_time`要手动启动的发动机编号放入队列中
3. 更新扩散的左右邻居发动机启动时间
   1. 获取当前时刻要启动的发动机的左右邻居发动机编号（`left_neighbor`和`right_neighbor`）
   2. 如果邻居发动机最早启动时间未初始化（`earliest_start_time[id] == -1`）则更新邻居发动机启动时间为下一时刻（`current_time + 1`）
4. 获取发动机最早启动时间数据中，最晚启动的数据
5. 输出结果

## 3.2

今天决定将x90换回xr体验一段时间了。但是问题在于，我的云盘照片怎么办？好几个设备云空间各自为政。~~或者可以试着将X90版本回退~~？（太麻烦了，还需要保存微信数据）

先不管这么多了，先回顾下。

复习流浪地球题目。

常用的代码逻辑熟悉并理解：

- 队列的操作：初始化、入队、出队、判空和元素个数

看下待启动发动机队列固定数据结构

```C
typedef struct {
  int *data;
  int front, back, capacity;
} Queue;

void initQueue(Queue *q, int capacity){
  q->data = (int *)malloc(capacity * sizeof(int));
  q->front = q->back = -1;
  q->capacity = capacity;
}
void enqueue(Queue *q, int value) {
  if (isQueueEmtpty(q)) {
    q->front = 0;
  }
  q->back = (q->back + 1) % q->capacity;
  q->data[q->back] = value;
}
int dequeue(Queue *q) {
    int value = q->data[q->front];
    if (q->back == q->front) {
        q->front = q->back = -1;
    } else {
        q->front = (q->front - 1 + q->capacity) % q->capacity;
    }
    return value;
}
int isQueueEmpty(Queue *q) {
    return q->front == -1;
}
```

获取元素个数

```C
int count_of_engines_to_start = isQueueEmpty(&engines_to_start) ? 0 :
((engines_to_start.back >= engines_to_start.front) ?
 (engines_to_start.back - engines_to_start.front + 1) :
 (engines_to_start.capacity - (engines_to_start.front - engines_to_start.back - 1))
);
```

## 3.3

昨天将设备换到了IPhoneXR，由于暂时没有高强度使用，体验还不错。主要是手表的功能让我很是心动，训练和睡眠监测都不错的。deepseek训练的课表已经通过b站老哥的方法设置到了手表上，到时候开干就完了！

今天的训练任务是2000m热身加上8*400m训练。配速训练为5：20/km，折合400m距离用时2分08秒。组间休息时间为1分~1分30秒。

加油加油。

先回顾一下前两个个题目的核心算法：

1. 已知排序后的单词序列`deques[256]`、首单词`res[0]`以及现在存放结果单词的数量`resCount`，按照规则单词接龙

   ```C
   while(1) {
       char *now_word = res[resCount -1];
       char last_character = now_word[0];
       
       if (isEmpty(&deques[last_character])) {
           break;
       }
       char *s = popFront(&deques[last_character]);
       res[resCount++] = s;
   }
   ```

2. 滑动窗口统计连续相同字符的子串长度。已知数组`mp[26]`保存了连续字母个数，字符串`s[1001]`存放了输入的字符串

   ```C
   for (int i = 0; i < strlen(s); i++) {
       int j = i;
       int count = 1;
       while (j + 1 < strlen(s) && s[j] == s[j+1]) {
           j++;
           count++;
       }
       int id = s[i] - 'A';
       mp[id] = MAX(mp[id], count);
       i = j;
   }
   ```

10:45 - 11：18 - 写新题目4

------

15：01 - 15：27（开始学习题目5）

理解题目的逻辑：

1. 通过结构体数组来记录每个学生的信息，并且成绩需要`m+1`个
2. 科目名称存放在科目`subject`数组中
3. 将每个学生的总分存放在成绩表的第一个元素`score[0]`中。其他分数分别存放在`[1, m]`的下标中，分数下标正好与科目`subject`的下标形成了差1的关系。即：若`subjects[0] = "math"`，则存放数学成绩的栏在`score[1]`中。
4. malloc后，要及时free掉
5. 学生信息的排序函数，输入指向学生信息的指针`Stu *stu`，输出按照某科（`[1, m]`）成绩或者总分成绩输出的结果。如果成绩相同，则按照姓名的字典序输出。

15:27 - 16:18

写题目

## 3.4

不要自暴自弃亲亲。

继续研究题目5

速度慢在哪里了：

- 在排序算法中，void指示的是`Student`类型的指针变量，我如何强制类型转换

  ```C
  int comp(const void *a, const void *b) {
  	Student *stu1 = (Student *)a;
  	Student *stu2 = (Student *)b;
  	...
  }
  ```

  原因：对于将`Student`数组排序方法不清晰

9：56 开始学习题目6

问题：

1. 如何从小到大排序手牌？

   答：除去2后，按照升序规则，使用下标`[0, 12]`存储斗地主手牌面值

   ```C
   char pokes[13][3] = {"3", "4", "6", "7", "8", "9", "10", "J", "Q", "K", "A"};
   ```

   然后将输入的牌与升序面值比对，如果面值相同，则该面值牌数量+1

2. 滑动窗口处理顺子

   ```C
   int ok = 0;
   for (int i = 0; i < 8; i++) {
       int yes = 1;
       char mp[20][3];
       int mp_len = 0;
   	for (j = 0; j < 5; j++) {
           if (c[i + j] == 0) { // 面值缺失
               yes = 0;
               break;
           }
       }
       
       if (yes) {
           for (int j = 0; j < 20; j++) {
               if (i + j >= arr_len || c[i + j] == 0) {
                   break;
               }
               c[i + j]--;
               strcpy(mp[mp_len++], arr[i + j]);
           }
           
           // 打印找到的连续卡牌
           for (int k = 0; k < mp_len; k++) {
               printf("%s ", mp[k]);
           }
           printf("\n");
           ok = 1;
       }
   }
   ```

3. 如何不包含2

   答：直接数组数据不保存2即可

4. 如何处理重复牌？

   答：将手牌数量存放在数组中即可

15：50 - 学习题目7知识

1. 去除字符串末尾的字符

   ```C
   char str = "ABCDe";
   str[strlen(str) - 1] = '\0';
   
   char str1 = "ABCDe";
   str[strcspn(str, "e")] = '\0';
   printf("%s\n%s\n", str, str1);
   ```

   两者都可以，但是更倾向于用`strlen`来简单去除末尾字母。第二种适用于在字符串中去掉指定的首个字母

2. 将单词字母按照字典序排列并去重的函数

   ```C
   char *convert(const char *s);
   ```

3. 将处理后的字谜结果，存放在结构体中

## 3.5

今天需要按照进度，确认需要延期。下午给HR说一声，我需要最起码再一周的时间。

今天继续。

昨天的算法回顾：

题目5智能成绩表：qsort数组排序| 总成绩 | arr[i].fen[j + 1] = scores[j]

题目6斗地主之顺子：滑动窗口找顺子

题目7猜字谜：字符串字典序排序并去重| mianInput[strlen(mianInput) - 1] = '\0' | struct Set {...} st = {.count = 0};

但是很明显，我现在没法流畅地将其中涉及的算法复现出来，我该怎么办？

> ### 复习不是重做，而是模式提取
>
> 把每道题拆解为可复用的**解题原子操作**，例如：
>
> - **变量定义模块** → 初始值设定、作用域控制
> - **边界处理模块** → 循环终止条件、递归基线条件
> - **算法核心模块** → 状态转移方程、指针移动逻辑

**复习不是重做**，这句话让我真心汗颜啊！😭原来我只是在背题罢了，效率低下很正常！】

13:00 - 13:28 完成分析题目7

13:28 - 13:49 准备了一个每日必刷的常见算法，用来加深对于每个题目的理解。

13：51 学习第k个排列 - 卡在了函数`next_permutation`，询问gpt，发现是下一个排列算法。给的答案不理解，遂询问leetcode

[下一个排列算法详解：思路+推导+步骤，看不懂算我输！](https://leetcode.cn/problems/next-permutation/solutions/80560/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/)

太吊了！😏

## 3.6

复习了下一个排序的算法，还是感觉牛逼

今天目标是啃下10个题目，写不完不睡觉了。

9：14 - 9：22 读完题目10的分析。就是找最长连续数字，使得和为sum，应该是滑动窗口的问题

9：23 - 9:54 题目11，很简单，也是简单的排序算法。 

10：13 - 11：02。题目12很简单，就是高矮的位置确定后，临近替换即可

11：02 - 11：32 解决题目3的问题-矩形面积

14：40 - 15:08 - 题目14分糖果，使用递归计算

15：13 - 15:50 题目15最小的调整次数

16:00 - 17:19 开始第16题字符串分割

问题：

1. 如何判断字母的大小写？

   自答：~~c - ['a', 'z'] or ['A', 'Z']~~直接使用`<ctype.h>`中的函数`isupper()`和`islower()`

18:42 - 开始第17题找终点

## 3.7

复习题目10、11、12、13、14、15、16

9：45 - 10：05 题目10涉及两个：输入字符串转换int数组；滑动窗口找最长子序列

10：05 - 10：19 题目11：简单的升序算法

10：20 - 11：01 题目12：卡在了判断字符串是否合法

14：48 - 14：58 题目13矩形相交的面积 

14：59 - 15：04 题目14分糖果

15：04 - 15：20 题目15最小调整次数

15：20 - 15:56 题目16字符串分割

### 问题汇总

1. 题目10：分割以`,`分隔、且以换行符结尾的字符串，并将其转换为整型数组

   ```C
   char int_str[] = "1,2,3,4,5,6\n";
   char *token = strtok(int_str, ",\n");
   
   int arr[20];
   int count = 0;
   while (token) {
     arr[count++] = atoi(token);
     token = strtok(NULL, ",\n");
   }
   ```

2. 题目12：输入的字符串中，判断出现非法参数情况（存在除空格和数字外的字符，或者超长）

   ```C
     if (len > 0 && input[len - 1] == '\n') {
       input[len - 1] = 0;
     }
     // 1. 判断是否存在除空格和数字外的字符
     for (int i = 0; i < len - 1; i++) {
       if (input[i] != ' ' && !isdigit(input[i])) {
         printf("[]\n");
         return 0;
       }
     }
     // 2. 如果输入合法，将其转换为整型数组并获取长度
     int arr[1000];
     int count = 0;
     char *token = strtok(input, " ");
     for (int i = 0; i < len; i++) {
       arr[count++] = atoi(token);
       token = strtok(NULL, " ");
       if (!token) break;
     }
   
     if (count > 100) {
       printf("[]\n");
       return 0;
     }
   ```

## 3.8

今天是3月8号了哎，是我们认识一周年的纪念日！:rainbow:

今天也是要勇往直前啊喂！

11：03 - 11：18 分析题目17

13：42 - 14：44 脑子清晰分析17题目，现在整理下17涉及的小细节

1. 队列初始化是

   ```C
   q->front = q->rear = 0;
   ```

   队列的判空

   ```C
   q->front == q->rear;
   ```

2. 动态规划（现阶段不是很理解）

   状态定义和转移方程

14：48 - 15：17 题目18

15：17 - 16:00 题目19喊7的次数重排

1. 如何判断数字是否是7的倍数

   ```C
   num % 7 == 0
   ```

2. 判断数字中是否存在7

   ```C
   while (num > 0) {
       if (x % 10 == 7) return true;
       x /= 10;
   }
   ```

3. 汇总喊“过”的次数总和`sum`

16:44 - 17:20 题目20

1. 字符串按照非英文字母进行分割

   ```C
   int isAlpha(char c) {
       return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));
   }
   ```

2. 将字符串分割为英文单词（非英文单词的字符，均作为分隔符）

## 3.9

今天避免过多消耗精力吧。今日目标是21-30题目。完成后打双影奇境。哦对了，今天还有个长距离10km的训练。

还有一个问题，静下心来，设置一个完成CSAPP的计划。然后看情况，要重启CSAPP和数据结构的学习。

读书的分享，准备将《大秦帝国》作为读书分享交流的起点。

然后就是我宝贝的chatgpt的账号申请+傻瓜式的vpn操作教程。

首先是昨日的代码重写+核心代码构造。

9：53 - 10：32 重写17题的队列操作。此队列保存了`(当前位置， 当前步数)`。作用是逐步拓展到下一个位置，直到到达终点或队列为空。

10:50 - 12:00 重写20题目的处理字符串分割为单词数组函数。

下午又去搬家了，然后打扫完毕后，那个讨厌的二房东依旧扣除了我们的清洁费。

22：35 - 23：02 题目21

23：02 - 题目22猜数字

## 3.10

8：00 - 8：26 复习猜数字中的获取猜测结果和任意数字的提示结果函数。

8：43 - 9：00 理解23题日志采集系统中，对于终止条件和扣分的实现。

9：02 - 10：41 题目24自己理解+题目的滑动窗口

10：42 - 11：36 25题数大雁（学习如何记录目标字符串）

11：39 - 12：27 26题动态规划问题（还是不懂DP）

15：55 -16：02 暂时放置题目27

16：02 -  28 数组拼接

## 3.11

准备放弃字符串操作的某些题目，从33题的三叉树开始刷。今天目标是刷5道题目，然后重写之前（1-15道）的核心代码。

明天就是刷刷动态规划的题目，将16-30题目重新写一遍核心代码。然后周五在开始刷难题吧。

10：52 - 11：05 题目33

11：06 - 11：25 题目34最小字符串

中午看了jyy的OS课程，才发现自己对于自己的计算机之路充满期待！我现在基本完成了基础的训练，下一步就是做OS部分的lab了。

17：33 开始刷题，从15题目开始，往前刷核心算法。

17：33 开始15题目

## 3.15

由于前两天看了jyyOS，对于老师提出的ag系统非常的感兴趣。现在就实现一下一个简单的ag工具。

> Prompt：ag工具是一个ubuntu上的智能助手，当我输入ag命令发的时候，默认会调用deepseek的V3模型来进行访问问题。ag输入，即可进入访问功能，然后再输入自己的提问，得到回答。
>
> 然后ag还有其他的选项：
>
> 1. `-q`：可以通过`ag -q 问题`来直接询问问题
> 2. `-a`：可以启动R1模型来进行深度思考
>
> 应该可以用`ag.py`作为脚本来实现，请你实现一下。

可以的，但是回答问题的速度依旧很慢。

其实就是每天进步一点点就可以了，自己还是认不清这个道理吗~

马拉松就是无脑执行计划就可以了。等刷题时间过了，就开始训练。

## 3.17

终于过了华为的机考，接下来面对的就是技术面了。下面看下自己要准备的工作。

综测问题

1. 为什么为自己定一个很高的目标是不合适的？
2. 在重要的时刻来临时担心
3. 发掘计划中的阻碍及难处

### 简历

经过和HR的沟通，确定了修改简历的几个要点：

1. GAP这半年，你做了什么？为什么要这么做？你的成果是什么？（就将职业安排到半年吧2024.6）
2. 工作经历中，同类项目简化，突出能力优势

### 半年安排

学习离散数学，完成CS70的学习任务，通读离散数学及其应用课本。

CSAPP重新再来一遍，重点是lab和课后习题。

linux脚本和命令熟悉安排
