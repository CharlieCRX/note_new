# 8.1

今天是开工的好日子啊！

## 设置位置参数

当 P100S 电机的运动模式为“多圈绝对位置移动”的时候，需要设置电机的圈数和单圈脉冲数来控制最终位置。设置绝对位置的寄存器为：

- `P4-2`：目标圈数(30000- 30000)。是多圈绝对位置的圈数部分
- `P4-3` ：圈内脉冲(±~~电机~~指令输入分辨率10800)

这里就存疑了。这个多圈绝对位置脉冲，代表的是伺服控制器的指令脉冲还是电机的位置脉冲呢？

### P4-2参数

又是厂家无聊的把戏。

这里就能体现出P100S电机手册的垃圾之处了。在P100S的手册中，P4-2代表的是：设定第 1 段内部位置的位置圈数。正常人是肯定不理解这个到底设置的是指令脉冲还是电机的位置脉冲的。

所以你需要跳转到手册《P100S使用功能延申》，去阅读“9、485 通讯方式控制(相对位置单段模式) ”的章节。其中的例子中，提到了

> 举例，P4-2 设置为 2 P4-3 设置为-5000 电机实际位置=2*10000-5000=15000

虽然含糊不清，但是经过其手册的多年折磨，我来替你翻译一下：

- 目标圈数设置为2
- 圈内脉冲设置为 -5000
- 电机每旋转 1 圈的指令脉冲数设置为 10000

那么此时电机实际位置就是`2 × 10000 - 5000 = 15000`。所以这里就隐含了其实多圈数据设置的P4功能就是面向指令脉冲的。

当前 P100S 指令脉冲分辨率为`10800`。

### 接口实现

而最终的暴露给上层程序设置位置接口为：

```cpp
bool setAbsoluteTargetRevolutions(double rev) override;
bool setRelativeTargetRevolutions(double deltaRev) override;
```

这里屏蔽了电机指令脉冲数`10800`的相关问题，让上层程序聚焦在电机圈数上。

所以现在需要解决的核心问题就是：圈数`targetRevolutions_`如何转换为多圈位置的参数？

- `P4-2`：`targetRevolutions_`的整数部分`revolutions_integer`
- `P4-3` ：`targetRevolutions_`的小数部分再乘以指令脉冲分辨率
  - 指令脉冲分辨率 =  电机分辨率 ÷ 电子齿轮比  = `(1 << PA95) ÷（PA12 / PA13 ）` =  131072 / 8192 * 675 = 10800
  - 即`P4-3` = `fractional_part` *  指令脉冲分辨率

### 基于TDD开发

现在已经有P100S的测试框架，类似

```cpp
class P100SMotorTest : public QObject
{
    Q_OBJECT

private slots:
    void positionAndReset_shouldWork();
};
```

```cpp
void P100SMotorTest::positionAndReset_shouldWork()
{
    // ✅ 初始化串口协议
    SerialCommProtocol protocol;
    QVERIFY2(protocol.open("COM10", true), "串口打开失败");

    // ✅ 创建寄存器访问器和电机对象
    MotorRegisterAccessor accessor(&protocol);
    const int motorID = 5;
    P100SMotor motor(motorID, &accessor);

    // ✅ 获取当前圈数
    double revBeforeReset = motor.getCurrentRevolutions();
    qDebug() << "归零前圈数:" << revBeforeReset;

    // ✅ 设置当前位置为 0
    QVERIFY2(motor.setCurrentPositionAsZero(), "设置当前位置为零失败");

    // ✅ 再次读取圈数
    double revAfterReset = motor.getCurrentRevolutions();
    qDebug() << "归零后圈数:" << revAfterReset;

    // ✅ 断言圈数接近 0（允许浮点误差）
    QVERIFY2(qAbs(revAfterReset) < 0.01, "归零后圈数不为 0");

    protocol.close(); // 主动关闭串口
}
```

请你依据这个，实现`triggerMove`与`setAbsoluteTargetRevolutions`和`setRelativeTargetRevolutions`的联动功能测试函数。

#### 1.设置测试函数

```cpp
void moveAbsoluteAndRelative_shouldWork();
```

实现为

```cpp
void P100SMotorTest::moveAbsoluteAndRelative_shouldWork()
{
    // ✅ 步骤 1: 初始化
    SerialCommProtocol protocol;
    QVERIFY2(protocol.open("COM10", true), "串口打开失败");
    MotorRegisterAccessor accessor(&protocol);
    const int motorID = 5;
    P100SMotor motor(motorID, &accessor);

    // ✅ 步骤 2: 设置初始状态
    // 先将当前位置归零，确保测试从已知起点开始
    QVERIFY2(motor.setCurrentPositionAsZero(), "设置当前位置为零失败");
    QVERIFY2(motor.waitMoveDone(), "电机归零超时");
    double currentRev = motor.getCurrentRevolutions();
    QVERIFY2(qAbs(currentRev) < 0.01, "归零后圈数不为 0");

    // ✅ 步骤 3: 执行第一次绝对位置移动
    const double target1 = 5.5; // 目标圈数：5圈半
    qDebug() << "执行第一次绝对位置移动，目标圈数:" << target1;
    QVERIFY2(motor.setMoveRPM(600), "设置移动速度失败");
    QVERIFY2(motor.setAbsoluteTargetRevolutions(target1), "设置绝对目标圈数失败");
    QVERIFY2(motor.triggerMove(), "触发移动命令失败");
    
    // ✅ 步骤 4: 等待移动完成并验证结果
    QVERIFY2(motor.waitMoveDone(10000), "第一次移动超时");
    currentRev = motor.getCurrentRevolutions();
    qDebug() << "第一次移动完成，当前圈数:" << currentRev;
    QVERIFY2(qAbs(currentRev - target1) < 0.01, "第一次移动位置不准确");

    // ✅ 步骤 5: 执行第二次相对位置移动
    const double deltaRev = 2.25; // 相对移动 2.25 圈
    const double target2 = target1 + deltaRev; // 最终目标位置
    qDebug() << "执行第二次相对位置移动，增量圈数:" << deltaRev;
    QVERIFY2(motor.setRelativeTargetRevolutions(deltaRev), "设置相对目标圈数失败");
    QVERIFY2(motor.triggerMove(), "触发移动命令失败");

    // ✅ 步骤 6: 等待移动完成并验证结果
    QVERIFY2(motor.waitMoveDone(10000), "第二次移动超时");
    currentRev = motor.getCurrentRevolutions();
    qDebug() << "第二次移动完成，当前圈数:" << currentRev;
    QVERIFY2(qAbs(currentRev - target2) < 0.01, "第二次移动位置不准确");

    // ✅ 步骤 7: 清理
    protocol.close();
}
```

#### 测试逻辑说明

1. **初始化与归零**：测试开始时，首先确保电机通过 `setCurrentPositionAsZero()` 归零，为后续的移动提供一个确定的起始点。
2. **绝对位置移动**：
   - 设置一个明确的绝对目标圈数（例如 `5.5`）。
   - 调用 `setAbsoluteTargetRevolutions()` 和 `triggerMove()`。
   - 使用 `waitMoveDone()` 等待电机到达位置，并设置了超时机制。
   - 通过 `QVERIFY2` 断言最终位置与期望的绝对目标位置高度接近，以验证绝对移动功能的正确性。
3. **相对位置移动**：
   - 在上一次绝对移动成功的基础上，设置一个相对移动量（例如 `2.25`）。
   - 调用 `setRelativeTargetRevolutions()` 和 `triggerMove()`。
   - 同样，等待移动完成并验证结果。这里的验证逻辑是检查当前位置是否等于**前一个位置**加上**相对增量**。这能有效证明相对位置移动逻辑的准确性。
4. **超时处理**：`waitMoveDone(10000)` 调用了我们之前实现的带超时功能的等待函数，这在实际测试中非常重要，可以防止测试因电机未能完成移动而无限期挂起。
5. **浮点误差容忍**：使用 `qAbs(...) < 0.01` 来比较浮点数，这是一种在测试中处理浮点数不精确性的标准做法。

# 8.2

其实先不着急实现位置移动，分析下之前的位置移动是怎么检测完成的。

检测位置移动完成的逻辑在`MotorCtrl::checkMove()`中，方法就是获取DO的定位完成输出。并且最终要获取电机的实际位置脉冲数和设置的绝对位置的脉冲数进行比对，差值要小于一定量才算移动完成。

## 位置移动逻辑

现在我们重新梳理下，关于触发位置移动的逻辑`triggerMove()`分层理解。

### `triggerMove()` 逻辑分层

**TO0: 触发位置移动** 这个顶层目标是让电机从当前位置移动到预定的绝对位置。为了完成这个任务，`triggerMove()` 方法需要依次执行以下三个主要子任务：

- **TO1：准备移动参数**
- **TO2：发送移动命令**
- **TO3：处理移动结果**

在触发电机位置移动之前，需要发送使能信号。向 PA53 寄存器写入 1，电机使能。 

------

**TO1: 准备移动参数** 这个任务的目的是将外部接口（浮点圈数）所需的目标位置，转换为 P100S 伺服驱动器内部所需要的格式（整数圈数和圈内脉冲）。这个过程包括：

- **TO1.1：校验目标位置**
  - 检查目标圈数 `targetRevolutions_` 是否超限。如果是，则立即报错。
- **TO1.2：将浮点圈数分解**
  - **TO1.2.1：获取整数圈数** 将 `targetRevolutions_` 的整数部分作为 **P4-2**（目标圈数）的值。
  - **TO1.2.2：计算圈内脉冲** 获取 `targetRevolutions_` 的小数部分，然后乘以 **指令脉冲分辨率（10800）**，得到 **P4-3**（圈内脉冲）的值。

------

**TO2: 发送移动命令** 一旦参数准备完毕，这个任务就是通过 MODBUS 协议与伺服驱动器进行通信，告诉它“你要移动了”。具体步骤如下：

- **TO2.1：写入目标圈数** 将计算出的整数圈数值通过 MODBUS 写入 P4-2 寄存器。
- **TO2.2：写入圈内脉冲** 将计算出的圈内脉冲值通过 MODBUS 写入 P4-3 寄存器。
- **TO2.4：发送触发信号** 向 P3-31 寄存器先写入 `0x0000` 再写入 `0x0001`，产生一个上升沿信号，正式启动电机的移动。

------

**TO3: 处理移动结果** 这个任务用于在命令发出后，确认电机是否成功到达了目标位置。这是可选的，但对于一个健壮的系统来说至关重要。

- **TO3.1：等待定位完成** 持续轮询 `DO_STATUS_WORD` 状态寄存器。
- **TO3.2：检查定位完成标志** 检查状态寄存器的 Bit5（`COIN`，定位完成标志）是否为 `1`。
  - 如果为 `1`，则移动成功。
  - 如果在等待超时后仍未变为 `1`，则移动失败。

## 位置移动函数分层

```cpp
// TO1.2: 将浮点数圈数分解为P4-2和P4-3
bool prepareMoveParameters(double targetRev, uint32_t& outRevolutions, uint32_t& outPulses) const;
// TO2: 将移动参数写入寄存器并发送触发信号
bool sendMoveCommand(uint32_t revolutions, uint32_t pulses);
```

- **`prepareMoveParameters()`:** 这个函数封装了 **TO1** 的所有逻辑。它负责将浮点圈数 `targetRevolutions_` 转换为 P4-2 和 P4-3 所需的整数值，并包含了目标位置的校验。
- **`sendMoveCommand()`:** 这个函数封装了 **TO2** 的所有逻辑。它负责将准备好的参数写入寄存器，并发送触发信号。

## 处理移动结果

现在`triggerMove()`的两个主要逻辑已经完成了：

-  准备移动参数
- 发送移动命令

此时的电机应该能按照预定设置的目标进行移动了。请问下一步应该怎么实现处理移动结果的步骤呢？

> **TO3: 处理移动结果** 这个任务用于在命令发出后，确认电机是否成功到达了目标位置。这是可选的，但对于一个健壮的系统来说至关重要。
>
> - **TO3.1：等待定位完成** 持续轮询 `DO_STATUS_WORD` 状态寄存器。
> - **TO3.2：检查定位完成标志** 检查状态寄存器的 Bit5（`COIN`，定位完成标志）是否为 `1`。
>   - 如果为 `1`，则移动成功。
>   - 如果在等待超时后仍未变为 `1`，则移动失败。

完成后进行最终测试。

## 位置移动测试

现在关于位置移动的逻辑基本完成了。

```cpp
bool setMoveRPM(int rpm);
int getMoveRPM();
bool setAbsoluteTargetRevolutions(double rev);
bool setRelativeTargetRevolutions(double deltaRev);
bool triggerMove();
```

- 设置位置移动速度
- 设置绝对位置
- 设置相对位置
- 触发位置移动

并且获取位置状态的函数：

```cpp
double getCurrentRevolutions();
```

请给出测试案例，进行一个位置移动的测试。

# 8.4

今天主要目标，就是测试在2MHz单板上进行增益控制的测试。我只负责，设置多少增益，就按照计划设置多少CODE值。

## 2MHz单板

现在是测试2MHz单板：

```bash
ping 10.1.2.176
```

首先我要明确最终目标是什么。

好的，上午经过熟悉环境，并且测试了程序是否能够正常设置成功。现在目标就是在原有的增益挡位`0/20/40`Db下，能否设置正确的CODE值。

结果就是：

```c
    /**| 通道  | 增益 (dB)  | 校准值 (Reparation) | 计算出的 CODE   | 最终写入 FPGA 的 CODE |
       | ---- | --------- | ------------------- | ------------- | --------------------- |
       | 2    | 0         | 5                   | 2538          | 2533 (0x9E5)          |
       | 3    | 20        | -3                  | 1719          | 1722 (0x6BA)          |
       | 4    | 40        | 2                   | 899           | 897  (0x381)          |
       | 
```

那首先梳理下当前存在的逻辑。

## 校准流程

我们直接看校准时候的日志：

```C
Aug  4 06:01:04 localhost pcieCollecter: [INFO][parse_and_handle_message](203)RCV:{"chns":[0,0,0,0,0,0,0,0],"cmd":127,"gains":[1,0,0],"ppMv":200,"singleHz":10000}
Aug  4 06:01:04 localhost pcieCollecter: [ERROR][handle_adjust](149)Adjust request gains count != GAIN_CAL_CN(8)
```

就从报错开始研究，看下代码是如何实现校准的。

### `handle_adjust()`

报错是发生在这里的：

```C
  if(cnt != GAIN_CAL_CNT){
    ERR_LOG("Adjust request gains count != GAIN_CAL_CN(%d)\n", GAIN_CAL_CNT);
    return -2;
  }
```

因为后续加入了8个增益挡位：

```C
static const int g_supported_gain_db[GAIN_CAL_CNT] = { -20, -10, -6, 0, 6, 20, 30, 40 };
```

而之前的增益挡位只有三个：

```C
{0, 20, 40};
```

而请求的json数据中`"gains":[1,0,0]`对应的增益是使用0增益，即为下标为0的代表0增益。后面下标为1代表的的20增益、下标为2代表的40增益均不使用。

所以新旧交互的地方，存在了问题。

现在就需要将获取到的请求命令

```json
{"chns":[0,0,0,0,0,0,0,0],"cmd":127,"gains":[1,0,0],"ppMv":200,"singleHz":10000}
```

改为对应的8挡位数据`"gains":[0,0,0,1,0,0,0,0]`，即为新下标3对应的0增益有关系。

而请求命令是通过

```C
void dealCmdLoop(void *para)
{
  socklen_t sadd_len = sizeof(struct sockaddr_in);
  int msglen = 0;
  
  if(initSocket(g_lsn_port)){
    return ;
  }
  while (1){
    msglen = recvfrom(g_sock, g_rcvbuffer, MAX_UDP_MSG_LEN, MSG_WAITALL
      , (struct sockaddr *)&g_cliaddr, &sadd_len);
    if(msglen>0){
      memset(g_sendbuffer, 0, MAX_UDP_MSG_LEN);
      parse_and_handle_message(g_rcvbuffer, g_sendbuffer, MAX_UDP_MSG_LEN);
      send_message(g_sendbuffer);
    }
  }
}
```

这里从网络字符串`g_rcvbuffer`中获取到的命令字符串。所以需要修改这里，让其成为固定输入命令，以此来测试场景1：

- 通道2
- 增益0

加入

```C
// 固定的测试 JSON 命令^M
const char *test_command = "{\"chns\":[0,1,0,0,0,0,0,0],\"cmd\":127,\"gains\":[0,0,0,1,0,0,0,0],\"ppMv\":200,\"singleHz\":10000}";
```

由于此时校准值为`5`

所以最终要查看通道2`fpga -r 0x12`的值，是否为`0x9E5`。校准会修改校准值，所以我们需要查看下如何按照预设的校准值设置增益。

## 按照预设的校准值增益控制

首先恢复环境`dealCmdLoop`，然后点击信号观察看处理逻辑。

```bash
Aug  4 07:28:21 localhost pcieCollecter: [INFO][parse_and_handle_message](203)RCV:{"cmd":0,"gains":[0,0,20,0,0,0,0,0],"pulseFreq":60,"ulseMV":1,"pulseWidth":10,"samplerate":20000,"timespace":10}
```

看下日志，这是CH3（通道3）设置20dB的增益后的日志。那这样的话，对应数组`gains`：

- 下标就是对应通道`1`到`8`
- 值就是对应通道的增益值。



## 快速编译2

现在我需要在2MHz测试单板上，测试程序。

现在编译到运行的流程是：

1. 从`192.168.70.129`上进行交叉编译，生成最终在2MHz能运行的可执行文件`pcieCollecter`

2. 登录2MHz单板`10.1.2.176`，杀掉之前运行的程序：

   1. ```bash
      root@localhost:~# ps -ef | grep pcieCollecter
      root      4329  4327  0 Jan28 ?        00:00:00 ./pcieCollecter
      root      4860  4847  0 00:04 pts/0    00:00:00 grep --color=auto pcieCollecter
      root@localhost:~# ps -ef | grep collector.sh
      root      4327  4323  0 Jan28 ?        00:00:00 /bin/bash /root/collector.sh
      root      4862  4847  0 00:04 pts/0    00:00:00 grep --color=auto collector.sh
      ```

      首先这个`collector.sh`脚本是启动`pcieCollecter`的。所以需要先杀掉`collector.sh`，然后再杀掉`pcieCollecter`。

      所以这里需要运行两个`kill -9 xxxx`，按照其编号终止进程。

3. 再次回到编译环境`192.168.70.129`，执行`scpls1046A`

   ```bash
   alias scpls1046A='scp pcieCollecter root@10.1.2.176:/root/pcieCollecter'
   ```

   将程序传输到编译单板。

4. 回到单板根目录，后台运行`collector.sh`

现在我想简化这场编译-kill-传输-运行的浪费时间的流程，我该怎么做才能实现一步到位的结果？

就是通过一个快速编译部署脚本`deploy.sh`：

```sh
#!/bin/bash

# 设置变量
TARGET_IP=10.1.2.176
TARGET_USER=root
TARGET_PATH=/root/pcieCollecter
START_SCRIPT=/root/collector.sh
LOCAL_BINARY=pcieCollecter

echo "🛠️ Step 1: 编译项目..."
make -j12 || { echo "❌ 编译失败"; exit 1; }

echo "🔪 Step 2: 杀死远程旧进程..."
ssh ${TARGET_USER}@${TARGET_IP} <<EOF
  pkill -9 -f collector.sh || echo "collector.sh 不存在或已退出"
  pkill -9 -f pcieCollecter || echo "pcieCollecter 不存在或已退出"
EOF

echo "📤 Step 3: 传输新文件..."
scp ${LOCAL_BINARY} ${TARGET_USER}@${TARGET_IP}:${TARGET_PATH}

# echo "🚀 Step 4: 启动新 collector.sh ..."
# ssh ${TARGET_USER}@${TARGET_IP} "nohup ${START_SCRIPT} > /root/collector.log 2>&1 &"

# echo "🚀 Step 4: 启动新 pcieCollecter ..."
# ssh ${TARGET_USER}@${TARGET_IP} "nohup ${TARGET_PATH} > /root/collector.log 2>&1 &"


echo "✅ 部署完成"
```

哈哈哈哈，截至下午4点，已经基本完成了2MHz的增益适配。下一步就是配合前端，修改校准时候的数组定义。

## 点动逻辑

这样吧，还是重新启一章分析P100S的电动逻辑吧。其中包括松闸和抱闸逻辑。

# 8.5

## 点动逻辑实现

实现点动逻辑之前，需要按照当前的测试逻辑，基于TDD的形式给出一个测试案例。

## 调整架构

现在就要重新梳理架构了。写一份严格的手册，以便于下一步的开发工作。

```bash
Administrator@CRX MINGW64 /f/project/servoV6 (master)
$ tree -I 'build|.git|external'
.
|-- CMakeLists.txt
|-- CMakeLists.txt.user
|-- README.md
|-- adapters
|   |-- CMakeLists.txt
|   |-- ServoAdapterFactory.cpp
|   |-- ServoAdapterFactory.h
|   |-- motors
|   |   |-- CMakeLists.txt
|   |   `-- P100S
|   |       |-- P100SMotor.cpp
|   |       `-- P100SMotor.h
|   |-- protocol
|   |   |-- CMakeLists.txt
|   |   |-- MotorRegisterAccessor.cpp
|   |   |-- MotorRegisterAccessor.h
|   |   |-- SerialCommProtocol.cpp
|   |   `-- SerialCommProtocol.h
|   `-- servos
|       |-- CMakeLists.txt
|       |-- GearRotaryAdapter.cpp
|       `-- GearRotaryAdapter.h
|-- app
|   |-- CMakeLists.txt
|   |-- main.cpp
|   `-- qml
|       `-- Main.qml
|-- application
|   |-- BusinessLogic.cpp
|   |-- BusinessLogic.h
|   |-- CMakeLists.txt
|   `-- MotorCommandExecutor.h
|-- domain
|   |-- CMakeLists.txt
|   |-- CommandVisitor.h
|   |-- ICommProtocol.h
|   |-- IMotor.h
|   |-- IServoAdapter.h
|   |-- MovementCommand.h
|   `-- RegisterType.h
|-- tests
|   |-- CMakeLists.txt
|   |-- test_gear_rotary_adapter.cpp
|   |-- test_gear_rotary_adapter.h
|   |-- test_main.cpp
|   |-- test_motorregisteraccessor.cpp
|   |-- test_motorregisteraccessor.h
|   |-- test_p100smotor.cpp
|   |-- test_p100smotor.h
|   |-- test_serialcommprotocol.cpp
|   `-- test_serialcommprotocol.h
`-- utils
    |-- CMakeLists.txt
    |-- Logger.cpp
    `-- Logger.h

11 directories, 44 files
```

现在分别理解子架构。

### `domain` 模块中的文件作用

`domain` 模块是项目的核心，它就像一份蓝图或一套合同，定义了系统中各个组件之间的关系和职责，但绝不涉及具体实现。这种设计模式被称为**依赖倒置原则**，它确保了高层业务逻辑不依赖于底层具体实现，而是依赖于抽象接口。

并且**使用现代 C++ 特性（`std::variant`）和访问者模式 (`CommandVisitor`) 来实现灵活且可扩展的命令处理系统**。这个设计是整个 `application` 层能够解耦并高效运行的关键。

#### 1. `MovementCommand.h` 的核心作用

- **职责**：定义了所有**上层业务命令**的结构和类型。
- **核心思想**：
  - 使用 `struct` 来表示每个命令，这些结构体只包含数据，没有行为。例如，`RelativeMove { double delta_mm; }`。这种设计使得命令对象成为纯粹的“数据包”，易于创建和传递。
  - 使用 `std::variant<...>` 将所有命令类型统一封装成一个 `Command` 类型。这解决了传统命令模式中，基类指针需要向下转型的问题，提供了类型安全和编译时检查。
  - `CommandSequence` ( `std::vector<Command>` ) 使得你可以轻松地创建和管理一个由不同命令组成的任务队列，这是自动化和批处理任务的基础。
- **如何理解**：`MovementCommand.h` 定义了你的系统能够理解的“所有语言”。每个 `struct` 都是一个词汇，`Command` 是一个句子，`CommandSequence` 是一篇文章。

#### 2. `CommandVisitor.h` 的核心作用

- **职责**：定义了**如何处理**这些业务命令的接口。它将命令的类型与执行命令所需的**适配器 (`IServoAdapter`)** 关联起来。
- **核心思想**：
  - 实现了**访问者模式**，但做了一些巧妙的变通。传统的访问者模式中，`visit` 函数只接收被访问者 (`Command`)。而你的设计更进一步，`visit` 函数同时接收**命令类型**和**适配器类型**。
  - 通过函数重载，为每一种命令 (`SetPositionSpeed`) 和每一种适配器 (`ILinearServoAdapter`) 组合都提供了 `visit` 函数。例如，`visit(ILinearServoAdapter* adapter, const SetPositionSpeed& cmd)`。
  - 这种设计将“命令”与“执行者”完美解耦。执行者（具体的 `CommandVisitor` 实现）通过 `IServoAdapter` 接口来操作电机，而 `CommandVisitor` 接口本身只关心如何将命令分发给正确的执行者。
- **如何理解**：`CommandVisitor.h` 定义了“如何翻译”命令的规则。它知道“如果命令是 `SetPositionSpeed`，并且执行者是 `ILinearServoAdapter`，那么就调用 `adapter->setPositionSpeed()`”。

#### 3. `domain` 模块整体逻辑

现在，`domain` 模块的逻辑变得非常清晰和强大：

- `IServoAdapter.h` 和 `IMotor.h` 定义了**系统功能和硬件的抽象**。它们是“执行者”的抽象接口。
- `MovementCommand.h` 定义了**系统指令的抽象**。它们是“任务”的抽象数据。
- `CommandVisitor.h` 定义了**指令和功能的绑定**。它是一个“调度器”或“翻译官”的抽象接口，将指令 (`Command`) 传递给相应的执行者 (`IServoAdapter`)。

这个架构的优点在于：

1. **极高的可扩展性**：
   - 如果需要添加新命令（例如 `WaitForSensorSignal`），只需在 `MovementCommand` 中添加新的 `struct` 和在 `Command` `variant` 中添加新的类型，然后在具体的 `CommandVisitor` 实现中添加相应的 `visit` 函数即可。
   - 如果需要添加新的适配器类型（例如 `IPressureAdapter`），只需在 `IServoAdapter` 中添加新接口，并在 `CommandVisitor` 中添加相应的 `visit` 函数重载。
   - **你不需要修改任何现有代码**（开放-封闭原则）。
2. **类型安全**：
   - `std::variant` 确保了你不能传递不存在的命令类型。
   - `CommandVisitor` 的重载机制，确保了 `SetPositionSpeed` 命令只能被 `ILinearServoAdapter` 类型的适配器处理，这在编译时就得到了保证。

------

### `application` 模块的作用

`application` 模块是整个项目的**大脑和中枢**。它的核心职责是**管理业务流程、调度命令执行**，并将上层业务需求转化为对抽象接口的调用。

这个模块有两个核心组件：`MotorCommandExecutor` 和 `BusinessLogic`。它们共同实现了**命令模式、访问者模式和依赖注入**，将业务逻辑与底层实现彻底解耦。

#### 1.`MotorCommandExecutor.h` 分析

`MotorCommandExecutor` 的作用是**执行者**。它实现了 `domain` 模块中定义的 `CommandVisitor` 抽象接口。

- **单一职责原则**: 它的唯一职责就是**执行命令**。对于每一种命令类型 (`RelativeMove`) 和每一种适配器类型 (`ILinearServoAdapter`) 的组合，它都提供了一个具体的 `visit` 方法来实现其功能。
- **依赖倒置**: `MotorCommandExecutor` 不依赖任何具体电机型号（如 `P100SMotor`）或通信协议。它只依赖于 `IServoAdapter` 接口，这使得它能够处理任何实现了这个接口的电机，无论是线性的还是旋转的。
- **代码清晰**: 每一个 `visit` 方法的实现都非常简单，它只做一件事：调用 `IServoAdapter` 对应的功能方法。这使得代码非常清晰、易于维护和调试。
- **日志集成**: 你在每个 `visit` 方法中都加入了日志，这是一个很好的实践。它使得在调试时，你可以清楚地追踪到每个命令的执行过程。

------

#### 2.`BusinessLogic.h` 分析

`BusinessLogic` 的作用是**调度器和管理者**。它是整个业务流程的入口点，负责管理电机适配器并执行命令序列。

- **依赖注入**: `BusinessLogic` 的构造函数接收一个 `std::map<std::string, std::unique_ptr<IServoAdapter>>`。这意味着 `BusinessLogic` 本身不负责创建适配器，而是由外部（通常是程序入口）创建后注入进来。这极大地提高了模块的灵活性和可测试性，你可以轻松地用 mock 对象替换真实的适配器进行单元测试。
- **任务调度**: `executeCommandSequence()` 方法是核心。它接收一个电机ID和一系列命令 (`CommandSequence`)，然后**利用 `MotorCommandExecutor` 来执行这些命令**。
- **管理状态**: 它管理着一个 `adapterMap`，负责保存和查找所有可用的电机适配器。

#### 3.`application` 模块的整体工作流

1. **准备阶段**: 在程序启动时，外部代码（比如 `main.cpp`）通过工厂 (`ServoAdapterFactory`) 创建一个或多个 `IServoAdapter` 实例，并将它们注入到 `BusinessLogic` 中。
2. **业务请求**: 当用户或系统触发一个业务逻辑时，它会调用 `BusinessLogic::executeCommandSequence()`。
3. **命令执行**: `BusinessLogic` 在 `adapterMap` 中找到对应的 `IServoAdapter` 实例，然后遍历 `CommandSequence`。
4. **分发执行**: 对于序列中的每一个 `Command`，`BusinessLogic` 会使用 `std::visit` 和 `MotorCommandExecutor` 将命令分发给正确的 `visit` 方法。
5. **调用适配器**: `MotorCommandExecutor` 中的 `visit` 方法被调用，它会进一步调用 `IServoAdapter` 的相应方法。
6. **底层执行**: `IServoAdapter` 将业务单位（如毫米）转换为底层物理单位（如圈数），最终通过 `IMotor` 和 `ICommProtocol` 完成对硬件的操作。

这个流程完美地展示了你的架构分层：

- **`application` 层**：关心**业务流程**。
- **`domain` 层**：关心**接口和契约**。
- **`adapters` 层**：关心**具体实现和适配**。

这种设计使得你的系统高度可扩展，能够轻松应对未来业务和硬件的变化。

## 命令下发流程分析

整个过程可以概括为以下四个核心步骤：

1. **业务逻辑层：封装命令并调用执行器** (`application` 层)
2. **命令执行器：命令分发与适配** (`application` 层)
3. **适配器层：单位转换与协议封装** (`adapters` 层)
4. **协议层：硬件通信与数据发送** (`adapters` 层)

下面是每一步的详细分解，以一个“相对旋转 90 度”命令 (`RelativeAngularMove{90.0}`) 为例。

### 1. 业务逻辑层：`BusinessLogic`

- **入口点**: 用户在 UI (如你的 `Main.qml` 或 `app/main.cpp`) 中触发一个旋转操作，这个请求被传递到 `BusinessLogic` 类。
- **命令序列**: `BusinessLogic` 接收到命令，将其封装成一个 `CommandSequence`，例如 `CommandSequence { RelativeAngularMove{90.0} }`。
- **执行器调用**: `BusinessLogic` 找到与电机 ID 对应的 `IServoAdapter` 实例，然后调用 `executeCommandSequence` 方法，并将命令序列和适配器传递给 `MotorCommandExecutor`。

### 2. 命令执行器：`MotorCommandExecutor`

- **命令访问**: `BusinessLogic` 使用 `std::visit` 机制，遍历 `CommandSequence` 中的每个 `Command`。`std::visit` 会根据当前命令的**具体类型**（例如 `RelativeAngularMove`）来调用 `MotorCommandExecutor` 中相应的 `visit` 方法。

- **类型检查**: 在 `visit` 方法中，通过 `dynamic_cast<IRotaryServoAdapter*>` 检查当前的 `IServoAdapter` 实例是否可以安全地向下转型为 `IRotaryServoAdapter`。如果转型成功，说明这个命令适用于这个电机。

- **命令分发**: `MotorCommandExecutor` 调用转型后的 `IRotaryServoAdapter` 接口方法。

  ```C++
  // 伪代码: BusinessLogic.cpp
  std::visit([&](auto&& arg) {
    if constexpr (std::is_same_v<T, RelativeAngularMove>) {
      if (IRotaryServoAdapter* rotaryAdapter = dynamic_cast<IRotaryServoAdapter*>(adapter)) {
        return executor.visit(rotaryAdapter, arg); // 这一步将控制权传递给执行器
      }
    }
  }, cmd);
  ```

  ```C++
  // 伪代码: MotorCommandExecutor.h
  bool visit(IRotaryServoAdapter* adapter, const RelativeAngularMove& cmd) override {
    // 在这里调用 IRotaryServoAdapter::relativeAngularMove
    return adapter->relativeAngularMove(cmd.degrees);
  }
  ```

### 3. 适配器层：`GearRotaryAdapter`

- **单位转换**: `IRotaryServoAdapter` 的具体实现类（例如 `GearRotaryAdapter`）接收到 `relativeAngularMove(90.0)` 调用。它使用**内部存储的物理参数**（如减速比）将业务单位 (`degrees`) 转换为电机所需的单位 (`revolutions`)。
  - `revolutions = (90.0 / 360.0) * reductionRatio`
- **调用底层**: `GearRotaryAdapter` 接着调用其内部持有的 `IMotor` 实例的相应方法，例如 `IMotor::setRelativeTargetRevolutions(revolutions)`。
- **触发运动**: 最后，`GearRotaryAdapter` 调用 `IMotor::triggerMove()` 来启动电机的运动。

### 4. 协议层：`P100SMotor` -> `MotorRegisterAccessor` -> `SerialCommProtocol`

- **寄存器转换**: `P100SMotor` 接收到 `setRelativeTargetRevolutions(revolutions)` 调用。它将 `revolutions` 转换为 P100S 电机专用的**脉冲数**，并确定相应的**寄存器地址**。
- **访问器封装**: `P100SMotor` 调用 `MotorRegisterAccessor::writeReg32()`，传入电机 ID、寄存器地址和脉冲值。
- **协议编码**: `MotorRegisterAccessor` 负责将这些参数打包成符合 P100S 协议的**数据帧**。
- **串口发送**: `MotorRegisterAccessor` 最后调用 `ICommProtocol::write()` 方法，将数据帧传递给 `SerialCommProtocol`。
- **物理通信**: `SerialCommProtocol` 负责通过**串口**将这些数据帧发送到 P100S 电机。

------

### 架构优势总结

这个分层设计有以下几个关键优势：

- **高内聚低耦合**: 每一层都只专注于自己的职责。`BusinessLogic` 不知道齿轮外径或串口协议，`SerialCommProtocol` 也不知道 90 度旋转是什么意思。
- **可扩展性**: 如果你换用不同型号的电机（如 P200S），你只需在 `adapters/motors` 目录下新增一个 `P200SMotor` 类，实现 `IMotor` 接口即可。
- **可测试性**: 每一层都可以通过 Mock 对象独立测试。你可以测试 `GearRotaryAdapter` 是否正确调用了 `IMotor` 的方法，而无需连接实际电机。

这个架构不仅保证了命令下发的正确性，也为未来的维护和功能扩展奠定了坚实的基础。

# 8.7

昨天报告一下，调试继电器IO模块了，并且实现了Qt串口的调试。

今天任务就是：实现蓝牙通信+安卓的Qt6环境适配

## Qt6安卓环境适配

当前Qt版本为`QT6.9\6.9.1`

# 8.8

今天继续安装安卓环境。昨天安装完毕安装环境后，遇到的问题：

- 安卓模拟器启动不了
- 编译的时候，链接报错。

索性直接将Qt5和Qt6卸载重装了。这次就是记录下，我在基于目标安卓设备：

> 设备是 **ARM 64 位架构**，在 Qt6 编译安卓环境时应该选择：**✅ android arm64-v8a**

配置环境的记录。

# 8.9

## 蓝牙连接

现在要加入`RelayIO`模块对于安卓设备的适配。前两天经过艰苦的奋斗，终于将Qt6 + 安卓环境搭配好。但是也牺牲了Qt5的安卓环境配置。

### 需求

现在要基于`ICommProtocol`的接口协议，实现蓝牙的读写能力。

- 能够正常读写
- 连接设备后，使用`QSettings`保存设备的MAC地址（最快连接）+名称

请你给出一个实现。

其实到了现在，存在的问题就是由于QtQuick不熟悉，我现在基本写不了东西。

# 8.11

现在重申下蓝牙连接的功能实现。

## 蓝牙连接2

首先基于`ICommProtocol`的接口协议，实现蓝牙的读写能力。然后首先默认搜索以`MOTOR`开头的蓝牙设备即可。

测试能否正常读写。

所以基于这个蓝牙连接的情况，不需要做展示。

可以，截至下午14：56分，做出了第一版的蓝牙接口连接程序。现在就是直接根据蓝牙设备的 MAC 地址进行连接的。

## 正在尝试连接

现在蓝牙连接按钮按下后，只会展示`正在尝试连接...`，连接成功与否都不会展示。现在需要修改这部分代码。我觉得，很多时候是由于自己对于前端知识掌握的太少，而导致后端写不下去。

其实自己的前后端都挺差劲的。对于C++的高级语法，真的用不出来。今天趁着正好没啥事，就先把这个Qt以后想走远的基础打一下。

# 8.12

## delegate

在 QML 中，**delegate（委托）是一个模板组件**，用来描述**数据模型（model）中的每一条数据应该如何显示和交互**。

### delegate 的执行过程

假如代码为：

```js
Tumbler {
    model: 12
    delegate: Text {
        text: modelData + " 月"
        color: Tumbler.displacement === 0 ? "red" : "gray"
        opacity: 1.0 - Math.abs(Tumbler.displacement) / (Tumbler.tumbler.visibleItemCount / 2)
    }
}

```

- `Tumbler` 有一个数据模型（`model: 12` 意味着数字 0~11）。
- QML 引擎为模型的每个元素创建一个 delegate 实例。
- 在创建实例时，会把该项的数据（`modelData`、`index` 等）注入到 delegate 中。
- 如果控件滚动、数据变化，QML 会更新 delegate 的绑定，让 UI 自动刷新。

## Tumbler

在学习[`Tumbler`](https://doc.qt.io/qt-6/qml-qtquick-controls-tumbler.html)的案例时候，为了实现"离中心越远，透明度越低"的渐变式滚轮效果，使用了如下的策略：

```js
opacity: 1.0 - Math.abs(Tumbler.displacement) / (Tumbler.tumbler.visibleItemCount / 2)
```

这段代码的关键在于两个属性：

- `Tumbler.displacement`
- `Tumbler.tumbler.visibleItemCount`

理解这两个属性的含义，就能看出它们分别属于**局部信息**和**全局信息**。

### 局部属性

`Tumbler.displacement`是`Tumbler`的附加属性。

- 作用域：只能在`Tumbler`的 delegate 中访问。
- 含义：当前 delegate 项目相对于滚轮中心选中项的位移，单位是行数。

### 全局属性

`Tumbler.tumbler.visibleItemCount`

- `Tumbler.tumbler`：附加属性，指向当前 delegate 所属的`Tumbler`实例
- `visibleItemCount`：`Tumbler`本身的属性，表述滚轮上可见的总行数。
- 含义：整个`Tumbler`空间一次性可以显示多少行。

### 为什么有时直接用 `Tumbler.xxx`，有时要 `Tumbler.tumbler.xxx`

- 直接用`Tumbler.xxx`：访问 delegate 的附加属性，它和当前项强相关。
- 用`Tumbler.tumbler.xxx`：先拿到父`Tumbler`实例，再访问它的属性。

这就像：

- `Tumbler.displacement`：我自己距离中心多少（个人信息）。
- `Tumbler.tumbler.visibleItemCount`：这个滚轮一次能看到多少行（全局设定）。

### 总结

 每个 delegate 都有自己的 `displacement`。对于滚轮模型展示的数据，对于每一行的数据，都会经过 delegate 进行注入展示。

- **`Tumbler.displacement`** 是一个**局部附加属性**，对**每一个 delegate 实例**都有单独的值。
- 当滚动时，`displacement` 会实时更新，让 delegate 知道“我现在离中心多远”

这是 `Tumbler` 渐变透明度效果的核心原理。



## 开发板RK3568

插上网线到能 **ping 通**的流程如下。

### 1. 物理层建立连接（Layer 1）

- 网线插入网口，RJ45 接触良好。
- PHY(读法：`/faɪ/`)（以太网物理芯片）和对端设备（交换机、路由器、电脑）通过 **自协商** 协定速率（10/100/1000Mbps）和双工模式。
- 网口指示灯亮或闪，表示物理链路 OK。

### 2. 数据链路层启动（Layer 2）

- 网卡驱动加载并注册接口（如 eth0），并分配 MAC 地址。
- 网口被置为 **UP** 状态（`ip link set eth0 up`）。
- 系统可以在局域网内广播和接收帧，但还没有 IP 概念。

# 8.13

## 挂载共享文件夹

```bash
sudo vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other
```

这样就可以将windows本地的文件夹共享到linux环境了。因为开发板RK3568的SDK包有35G左右，所以需要处理好。

## 手册阅读

### linux版本

RK3568使用的Linux版本是5.10。

### 文档说明

> Rockchip Linux SDK 中在 docs ⽬录下附带了 Common（通⽤开发指导⽂档）、Socs（芯⽚平台相关⽂
> 档）、Linux （Linux 系统开发指南）、Others（其他参考⽂档）、docs_list.txt (docs⽂件⽬录结构）。

### SDK软件架构

> Rockchip Linux系统是基于Buildroot/Yocto/Debian 系统, 内核基于 kernel 4.4/4.19/5.10开发，针对多种不
> 同产品形态开发的SDK。

这里指的是 Rockchip 提供的 Linux 系统**根文件系统（rootfs）构建方式**不只一种，你可以选择不同的构建框架：

- **Buildroot**：轻量级、快速构建的嵌入式 Linux 根文件系统，常用在资源受限的板子上。
- **Yocto**：模块化、可高度定制的构建系统，更适合复杂商业产品。
- **Debian**：直接基于 Debian 发行版，功能齐全，包管理方便（apt），常用在功能丰富的设备上

Rockchip 提供的 Linux 内核是在这几个版本的 Linux 内核（mainline）基础上进行二次开发的。

总结就是：

> Rockchip 给你的 Linux 系统开发包可以基于 Buildroot、Yocto 或 Debian 来做根文件系统，内核是在 4.4 / 4.19 / 5.10 这些版本的 Linux 上改的，并且这个 SDK 已经为各种不同的 Rockchip 硬件产品形态做了适配。

### SDK 开发坏境搭建

- **U-Boot 和内核编译用 SDK 目录里已经准备好的交叉编译器（`prebuilt/gcc`）**，方便快速和保证兼容。
- **Buildroot 编译用户空间（根文件系统）及应用程序时，默认用的是 buildroot 自己生成的工具链**，这工具链是在 buildroot 运行时自动下载源码、编译的，独立于 `prebuilt/gcc`。

这样做的原因是：

- 好处是内核和 bootloader 保持统一的、官方验证过的编译环境，减少问题。
- 而用户空间应用可以自由定制 buildroot 工具链，便于升级、定制和裁剪。

------

## Buildroot 交叉编译环境配置

- **场景**：你用 Buildroot 为 RK3588（Rockchip芯片）构建系统时，Buildroot 会自动编译并生成交叉编译工具链。

- **工具链位置**：位于

  ```
  buildroot/output/rockchip_rk3588/host/usr
  ```

- **配置环境变量**：

  - 需要把工具链的 `bin/` 目录加入到你的环境变量 `PATH`，通常是：

    ```
    buildroot/output/rockchip_rk3588/host/usr/bin/
    ```

  - 这个目录里包含编译器（gcc）、链接器等工具，比如：

    ```
    aarch64-buildroot-linux-gnu-gcc
    ```

  - 这样你在终端就能直接调用交叉编译器进行编译第三方应用或者单独模块。

- **自动配置脚本**：

  - 在 Buildroot 顶层目录一般会有一个 `envsetup.sh` 脚本，执行：

    ```bash
    source envsetup.sh
    ```

  - 该脚本会自动把工具链路径加入 `PATH` 环境变量，设置交叉编译相关变量，方便后续开发。

------

## Buildroot 编译

Buildroot 是一个自动化的**构建工具**，专门用来帮你从源码一步步生成嵌入式 Linux 系统。

它的功能包括：

- 自动下载、配置、交叉编译各种软件包和工具链
- 生成 rootfs 镜像文件（可以是 cpio、ext4 镜像等格式）
- 生成内核、bootloader（可选）

| 名称      | 作用                                      | 关系                |
| --------- | ----------------------------------------- | ------------------- |
| Buildroot | 用于自动构建 Linux 系统和根文件系统的工具 | 负责“制造”rootfs    |
| Rootfs    | Linux系统启动后实际挂载的根文件系统       | Buildroot生成的产物 |

现在已经将文件解压到

```bash
/home/crx/work/rk3568SDK
```

下一步就是进行网络的调试了。

## ARP协议

ARP（Address Resolution Protocol，地址解析协议）是**计算机网络中用来把 IP 地址解析成 MAC 地址**的协议。

假设主机 A 想给主机 B（IP：192.168.1.20）发送数据：

1. **A 先查 ARP 缓存表**（ARP Cache），看有没有 192.168.1.20 对应的 MAC 地址。

2. 如果没有，就会发一个 **ARP 请求广播帧**：

   > “谁是 192.168.1.20？请告诉我你的 MAC 地址！”

3. **B 收到后**，发现自己 IP 是 192.168.1.20，就发一个 **ARP 应答单播帧**：

   > “我是 192.168.1.20，我的 MAC 地址是 00:11:22:33:44:55。”

4. **A 收到应答**后，把 IP 与 MAC 对应关系写进自己的 ARP 缓存表，下次直接用。

## `ip link` 输出

lo / dummy0 / ethX 对比表

| 特征                      | lo（回环接口）              | dummy0（虚拟网卡）                | ethX（真实以太网口）                      |
| ------------------------- | --------------------------- | --------------------------------- | ----------------------------------------- |
| **接口名称**              | `lo` 固定                   | `dummy0`、`dummy1`…               | `eth0`、`eth1`、`enpXsY` 等               |
| **链路类型** (`link/...`) | `link/loopback`             | `link/ether`                      | `link/ether`                              |
| **MAC 地址**              | `00:00:00:00:00:00`（全 0） | 随机虚拟 MAC（如 `de:c1:ee:...`） | 真实硬件 MAC（厂商 OUI 前缀）             |
| **广播地址**              | 全 0 (`00:00:00:00:00:00`)  | 全 F (`ff:ff:ff:ff:ff:ff`)        | 全 F (`ff:ff:ff:ff:ff:ff`)                |
| **标志位 `<...>`**        | `LOOPBACK,UP,LOWER_UP`      | `BROADCAST,NOARP,UP,LOWER_UP`     | `BROADCAST,MULTICAST,...`（一般无 NOARP） |
| **MTU 默认值**            | `65536`（很大）             | `1500`（以太网标准）              | `1500`（以太网标准，可改）                |
| **物理链路检测**          | 无物理层，永远 `LOWER_UP`   | 无物理层，永远 `LOWER_UP`         | 受网线/信号影响（插网线才有 `LOWER_UP`）  |
| **用途**                  | 本机内部通信（`127.0.0.1`） | 测试、占位、路由绑定              | 实际网络通信                              |
| **是否占用硬件**          | 否                          | 否                                | 是（网卡芯片）                            |

### **为什么 dummy0 有 NOARP？**

- `dummy` 接口是虚拟的，没有真实的物理网络要通信，所以不需要 ARP 解析 MAC。
- Linux 内核默认创建 `dummy` 接口时会加上 NOARP 标志来节省资源。

### **LOWER_UP**

**意思：**

- **LOWER_UP** = 数据链路层（Layer 2）状态为 *up*。
- 对物理网卡来说，这通常意味着：
  - 网线插好
  - 交换机/路由器端口已激活
  - 有正常的物理信号（Link detected）

## 状态字的含义

执行`ip link`后，查看`eth1`的接口：

```bash
4: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether ba:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
```

### 1. `UP` 状态的含义

`UP` 对应的是 **接口的管理状态（administrative state）**，由标志 `IFF_UP` 表示，其核心作用是：

- 表明该网络接口被 **启用**（可通过 `ip link set dev <网卡名> up` 手动设置），系统会为其分配资源（如队列、协议处理模块），允许其接收和发送数据包。
- 该状态 **不受物理链路影响**，仅由用户或系统配置决定。即使网线拔掉、物理链路断开，只要未执行 `ip link set dev <网卡名> down`，`UP` 状态就会一直保留。

### 2. `LOWER_UP` 状态的含义

`LOWER_UP` 对应的是 **底层链路状态（link state）**，由标志 `IFF_LOWER_UP` 表示，其核心作用是：

- 表明网卡的 **底层链路（物理层 + 数据链路层）是活动的（active）**，即物理层和数据链路层已准备就绪（例如：网线插好、光纤连接正常、无线网卡已关联到 AP 并获取链路信号等）。
- 该状态完全依赖物理链路状态，由网卡驱动或底层协议（如以太网的链路检测机制）实时报告：
  - 当网线插好时，物理层会检测到链路脉冲（Ethernet Link Pulse），数据链路层会完成链路协商（如速率、双工模式），此时驱动会向内核报告 “底层链路活动”，`LOWER_UP` 状态被触发。
  - 当拔掉网线，物理层链路断开（无信号），驱动报告 “底层链路非活动”，`LOWER_UP` 状态随之消失。

### 3. `state UP`

谁决定 state 是 UP 还是 DOWN？

- 软件层（管理员/系统配置）

  ```bash
  ip link set eth1 up
  ip link set eth1 down
  ```

  - up：**软件层**把接口打开，内核会尝试让网卡进入工作状态。
  - down：软件会直接关闭接口，不管物理网线有没有插上，`state` 都会变成 `DOWN`（并且标志位里也会去掉 `UP`）。

-  硬件/驱动检测到的物理链路状态

  - 网卡芯片通过 **PHY（物理层收发器）** 检测是否有电信号（Link beat）。
  - 驱动收到“有信号”事件时，会告诉内核：
    - 如果**软件已经 up** → `state` 变成 `UP`（或 DORMANT）
    - 如果**软件已经 up** 但物理层断开 → `state` 变成 `DOWN` 并加上 `NO-CARRIER`
  - 驱动通过 **ethtool API** 把这个信息传给内核网络栈。

  > 这一步是“操作状态”（Operational State）。

  > 开了灯的开关（UP），但电源没通（NO-CARRIER），所以灯没亮（state DOWN）。

### 总结

- **是否 `UP`** → 由你/系统命令决定（软件层）
- **是否 `LOWER_UP` / `NO-CARRIER`** → 由驱动+物理层检测决定
- **`state` 字段** → 内核综合前两者得出的结果



## 网络不通问题

现在我使用的开发板芯片是`RK3568`，设备上有一个RJ45网口。我现在想实现插上网线后，能够网络连接而不是串口调试这个设备。但是现在的问题是，我插上网线后，但是不知道怎么连接它。

请问如何连接一个网络设备？

### 1️⃣ 确认开发板网络接口状态

检查设备是否插上网线

```bash
root@RK356X:/# ip link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: dummy0: <BROADCAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/ether de:c1:ee:20:94:44 brd ff:ff:ff:ff:ff:ff
3: eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether be:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
4: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether ba:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
```

首先排除回环口`lo`和虚拟网口`dummy0`。然后我们看`eth0`的输出：

```bash
3: eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether be:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
```

- `eth0` → 没有 UP，也没有 LOWER_UP → **没插/没启用**

然后再看`eth1`输出：

```bash
4: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether ba:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
```

- `eth1` → 有 UP + LOWER_UP → **网线插在 eth1**

根据上面所学，我们验证下**网线是否真的插在了 eth1**上：

拔下网线，看下`eth1`的标志位是否会删除`LOWER_UP`，然后只剩下 UP：

```bash
4: eth1: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN mode DEFAULT group default qlen 1000
    link/ether ba:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
```

可以看出`LOWER_UP`已经消失，证明数据链路层已经失效。但是软件层的`eth1`接口仍旧是配置为`UP`的。这就导致其`state DOWN`。

这就证明网线接在了`eth1`接口上了。如果不放心可以直接通过`ethtool`来检测`eth1`。可以看到

```bash
	Link detected: yes
```

证明底层链路网线已经连接到了接口`eth1`。但是仅有物理层和链路层保证网络通畅还不够，如果没有 IP 地址，也不能进行通信。有了 IP，设备才能“参与网络”，互相找到对方，进行 TCP/IP 通信。

### 2️⃣ 配置 IP 地址

网络设备要能互相通信，必须在同一网段或者有路由可达。现在已经知道的是 Windows PC 的 IP 地址及其子网掩码是

```bash
10.1.2.9/8
```

所以其网络号为`10.0.0.0`。网络号相同的主机被认为在同一个子网内，可以直接通信（不用路由）。所以我们配置3586的 IP 地址也为相同的网络号内。

#### 配置静态 IP

```BASH
# 设置 IP 地址和子网掩码
ip addr add 10.1.2.55/8 dev eth1
```

#### 验证配置

```bash
# 查看接口状态和 IP 配置
ip addr show eth1
```

输出：

```bash
root@RK356X:/# ip addr show eth1
4: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether ba:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
    inet 169.254.176.42/16 brd 169.254.255.255 scope global eth1
       valid_lft forever preferred_lft forever
    inet 10.1.2.55/8 scope global eth1
       valid_lft forever preferred_lft forever
    inet6 fe80::9563:4c46:7d91:3623/64 scope link 
       valid_lft forever preferred_lft forever
```

现在从 Windows PC 上进行测试

```bash
C:\Users\Administrator>ping 10.1.2.55

正在 Ping 10.1.2.55 具有 32 字节的数据:
来自 10.1.2.9 的回复: 无法访问目标主机。
来自 10.1.2.9 的回复: 无法访问目标主机。

10.1.2.55 的 Ping 统计信息:
    数据包: 已发送 = 2，已接收 = 2，丢失 = 0 (0% 丢失)，
Control-C
```

从 RK3568 设备上进行测试

```bash
root@RK356X:/# ping 10.1.2.9
PING 10.1.2.9 (10.1.2.9) 56(84) bytes of data.
From 10.1.2.55 icmp_seq=1 Destination Host Unreachable
From 10.1.2.55 icmp_seq=2 Destination Host Unreachable
From 10.1.2.55 icmp_seq=3 Destination Host Unreachable
From 10.1.2.55 icmp_seq=4 Destination Host Unreachable
^C
--- 10.1.2.9 ping statistics ---
7 packets transmitted, 0 received, +4 errors, 100% packet loss, time 6064ms
pipe 4
```

配置的 IP 和子网号理论上在同一网段，但 **ping 不通**，说明问题不在 IP 子网，而是**物理链路或其他阻碍通信的因素**。

### 3️⃣Destination Host Unreachable

> 当本机要向同一局域网内的目标主机发送数据时，需要通过 ARP 协议获取目标主机的 MAC 地址。如果 ARP 查询失败（目标主机不存在或未响应），本机内核会生成 “主机不可达” 的 ICMP 错误，通知上层协议（如 TCP/UDP）该目标无法通信。

根据配置和路由表，理论上：

- RK3568 IP：10.1.2.55/8
- PC IP：10.1.2.9/8
- 路由表有：10.0.0.0/8 → eth1
- ping 应该走 eth1 直接发送，不经过默认路由

**但是仍然 unreachable，可能原因：**

#### (a) 物理链路问题

- 网线损坏、没插好
- 交换机端口未启用
- PC 网口没 UP

#### (b) ARP 无法解析

- RK3568 发 ARP 请求找 PC 的 MAC 地址失败
- Windows 防火墙阻止 ARP 或 ICMP
- Linux 上也可能存在老的冲突 ARP 缓存

#### (c) IP 冲突或多 IP 干扰

- eth1 还有 `169.254.176.42/16`
- 有时内核选择错误的源 IP 发送 ICMP，导致链路不可达

### 4️⃣排查步骤（建议顺序）

1. **删除 APIPA IP**

```bash
ip addr del 169.254.176.42/16 dev eth1
```

2. **确认路由**

```bash
root@RK356X:/# ip route 
10.0.0.0/8 dev eth1 proto kernel scope link src 10.1.2.55 # 确认 10.0.0.0/8 指向 eth1
```

3. **检查物理链路**

```bash
root@RK356X:/# cat /sys/class/net/eth1/operstate
up # 输出 should be "up"
```

* 确认网线或直连

4. **查看 ARP 表**

```bash
root@RK356X:/# arp -n
? (10.1.2.9) at <incomplete>  on eth1
? (10.1.2.1) at <incomplete>  on eth1

root@RK356X:/# ping -c1 10.1.2.9
PING 10.1.2.9 (10.1.2.9) 56(84) bytes of data.
From 10.1.2.55 icmp_seq=1 Destination Host Unreachable

--- 10.1.2.9 ping statistics ---
1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms


root@RK356X:/# arp -n
? (10.1.2.9) at <incomplete>  on eth1
? (10.1.2.1) at <incomplete>  on eth1
```

* 看是否成功解析到 PC 的 MAC

5. **关闭 Windows 防火墙（临时测试）**

```powershell
netsh advfirewall set allprofiles state off
```

6. **再 ping**

```bash
ping 10.1.2.9
```

---

💡 核心结论：

* 你配置的 IP 和路由表本身没问题
* “Destination Host Unreachable” 表示 **链路或 ARP 阶段失败**
* 不是路由表匹配问题

---



## 判断网线插在了哪个接口

```bash
┌─────────────────────┐
│       Linux 内核      │
│  (net_device, ip link)│
└─────────┬───────────┘
          │
          ▼
┌─────────────────────┐
│ MAC (Media Access    │
│ Controller, eth0)   │  ← eth0 在 Linux 上对应 MAC + net_device
└─────────┬───────────┘
          │ 数字信号 (RGMII / RMII)
          ▼
┌─────────────────────┐
│ PHY (Physical Layer) │
│ 电信号收发器         │  ← 负责链路检测、速度/双工协商
└─────────┬───────────┘
          │ 电信号（TX/RX）
          ▼
┌─────────────────────┐
│ RJ45 插口             │  ← 网线插入点
└─────────┬───────────┘
          │ 网线 (Cat5/Cat6)
          ▼
      交换机 / 路由器 / 对端设备
```

| 层级                  | 对应硬件/接口        | 作用                                                         |
| --------------------- | -------------------- | ------------------------------------------------------------ |
| **eth0 / net_device** | Linux 内核接口       | 软件层面的网卡表示，用于 ip link / ifconfig / ethtool        |
| **MAC**               | SoC 内部以太网控制器 | 处理以太网帧，DMA 与内存交互，控制 PHY                       |
| **PHY**               | 物理层收发器         | 将数字信号转换为电信号；检测 Link Beat；速度、双工自动协商；链路状态上报 |
| **RJ45**              | 网口插座             | 提供网线接口，保证物理电气连接符合以太网标准                 |
| **网线**              | Cat5/Cat6            | 传输电信号到交换机/路由器                                    |
| **对端设备**          | 交换机/路由器        | 对等链路，完成以太网通信                                     |

### 1. 通过 ip link 标志

- 判断物理网卡判断插网线的两个条件：
  - `<UP, LOWER_UP>`同时存在（UP = 软件启用接口；LOWER_UP = 物理层连通）
  - `state UP`：内核综合软件+硬件判断网线是否已经插入并且启用了此网口
- 反向操作，断开网线，对应接口会出现两个条件：
  - `<UP>`：软件启用接口
  - `state DOWN`

### 2. 用 ethtool 检测链路状态

```bash
ethtool eth0
ethtool eth1
```

输出会有：

```bash
Link detected: yes   # 有物理连接
Link detected: no    # 没插或没信号
```

直接读取网卡驱动的 **PHY 物理层链路检测**结果，这种方法最直观可靠。

## IP 地址与子网掩码

------

### 1️⃣ 子网掩码的作用

子网掩码（netmask）决定了 **IP 地址哪一部分是“网络号”**，哪一部分是“主机号”：

- `/24` → 255.255.255.0 → 前 24 位是网络号，最后 8 位是主机号
- `/8`  → 255.0.0.0   → 前 8 位是网络号，后 24 位是主机号

网络号相同的主机被认为在同一个子网内，可以直接通信（不用路由）。

------

### 2️⃣ 举例对比

#### (a) `10.1.2.55/24`

- 子网掩码 `/24` → 网络号是 `10.1.2.0`
- 可用 IP 范围：`10.1.2.1 ~ 10.1.2.254`
- PC 的 IP 是 `10.1.2.9/8` → 网络号是 `10.0.0.0`
- **结果**：RK3568 认为 PC 不在同一子网，需要走默认路由，而默认路由可能指向 169.254.x.x（APIPA），因此通信失败。

#### (b) `10.1.2.55/8`

- 子网掩码 `/8` → 网络号是 `10.0.0.0`
- 可用 IP 范围：`10.0.0.1 ~ 10.255.255.254`
- PC 的 IP `10.1.2.9/8` → 网络号也是 `10.0.0.0`
- **结果**：RK3568 认为 PC 在同一子网，可以直接通信。

------

### 3️⃣ 总结

| 配置         | RK3568 网络号 | PC 网络号 | 是否同一子网 |
| ------------ | ------------- | --------- | ------------ |
| 10.1.2.55/24 | 10.1.2.0      | 10.0.0.0  | ❌ 否         |
| 10.1.2.55/8  | 10.0.0.0      | 10.0.0.0  | ✅ 是         |

> **核心原因**：通信是否成功不是看 IP 是否一样，而是**两台设备是否在同一个网络号内**。子网掩码决定了这个“网络号”。

------

💡 小比喻：

- 子网掩码就像“邮政区号的长度”。
- `/24` → 只看前三段地址，RK3568 认为 PC 不在同一区号。
- `/8`  → 只看第一段地址，RK3568 认为 PC 在同一区号。

------

# 8.14

因为昨天使用路由转发的场景，ping不通RK3568设备。并且报错

```bash
Destination Host Unreachable
```

所以今天就尝试一把用网线直连 **PC ↔ RK3568** 。

## 网线直连 **PC ↔ RK3568** 

### 理由

- 排除中间设备干扰：确保链路层（L2）报文直接到对方网口，不会被其他设备拦截

- 确保 ARP 广播可达：直连等于保证 **ARP request** 一定能到对方网卡，并收到 **ARP reply**

- 排查问题简单：

  ```bash
  PC网卡 <——网线——> RK3568网卡
  ```

  - 任何 ping 不通的问题，几乎只可能是：
    1. IP/掩码配置错误
    2. 网线问题（或网口坏）
    3. 双方网卡驱动/状态不正常

### 排查步骤

#### 1. 设置Windows PC网络

设置为`192.168.137.xx/24`网段来直连。

设置完毕后，能在cmd中通过

```cmd
ipconfig
```

看到

```cmd
以太网适配器 以太网:
   IPv4 地址  . . . . . . . . . . : 192.168.137.99
   子网掩码  . . . . . . . . . . : 255.255.255.0
```

#### 2. RK3568 配置 IP

之前我们排查出 RK3568 的 eth1 网口是跟网线连接的。所以给 eth1 配置与 Windows PC 相同的网段不同 IP。

在 RK3568 上

```bash
ifconfig eth1 192.168.137.22 netmask 255.255.255.0 up
```

或者（推荐用 ip 命令）：

```bash
ip addr flush dev eth1
ip addr add 192.168.137.22/24 dev eth1
ip link set eth1 up
```

验证

```bash
root@RK356X:/# ip addr show eth1
4: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether ba:14:62:16:92:45 brd ff:ff:ff:ff:ff:ff
    inet 192.168.137.22/24 scope global eth1
       valid_lft forever preferred_lft forever
    inet6 fe80::9563:4c46:7d91:3623/64 scope link 
       valid_lft forever preferred_lft forever
```

应看到

```bash
inet addr:192.168.137.22  Mask:255.255.255.0
```

#### 3. 互相 Ping 测试

在 **RK3568** 上：

```bash
root@RK356X:/# ping 192.168.137.99 -c 3
PING 192.168.137.99 (192.168.137.99) 56(84) bytes of data.
From 192.168.137.22 icmp_seq=1 Destination Host Unreachable
From 192.168.137.22 icmp_seq=2 Destination Host Unreachable
From 192.168.137.22 icmp_seq=3 Destination Host Unreachable

--- 192.168.137.99 ping statistics ---
3 packets transmitted, 0 received, +3 errors, 100% packet loss, time 2014ms
pipe 3
```

在 **Windows** 上：

```cmd
ping 192.168.137.22
```

也是不通的，所以现在需要拷贝一个自己的系统版本到 RK 3568 中，进一步检查问题。

## RK 3568 系统

### 编译Uboot

编译成功，能看到编译的结果为`uboot.img`，但是不知道其目录在哪里。索性寻找下这个文件的目录：

```bash
crx@crxVMstation:~/work/rk3568SDK$ find . -type f -name "uboot.img" -exec ls -hl {} \;
-rw-rw-r-- 1 crx crx 2.0M Jan 17  2022 ./debian/overlay-firmware/usr/share/npu_fw_pcie/uboot.img
-rw-rw-r-- 1 crx crx 2.0M Jan 17  2022 ./debian/overlay-firmware/usr/share/npu_fw/uboot.img
-rw-rw-r-- 1 crx crx 4.0M Aug 14 10:23 ./u-boot/uboot.img
-rw-rw-r-- 1 crx crx 4.0M Aug 31  2023 ./IMAGE/RK3568-EVB1-DDR4-V10-LINUX_20230831.0957_RELEASE_TEST/IMAGES/uboot.img
```

可以看出最新的`08-14`的编译结果在`./u-boot/`下面。

### 编译Kernel

编译成功，但是提示

```bash
 PLEASE CHECK BOARD GPIO POWER DOMAIN CONFIGURATION !!!!!
 <<< ESPECIALLY Wi-Fi/Flash/Ethernet IO power domain >>> !!!!!
 Check Node [pmu_io_domains] in the file: /home/crx/work/rk3568SDK/kernel/arch/arm64/boot/dts/rockchip/myzr-rk3568.dts

 请再次确认板级的电源域配置！！！！！！
 <<< 特别是Wi-Fi，FLASH，以太网这几路IO电源的配置 >>> ！！！！！
 检查内核文件 /home/crx/work/rk3568SDK/kernel/arch/arm64/boot/dts/rockchip/myzr-rk3568.dts 的节点 [pmu_io_domains]
Running build_kernel succeeded.
```

**编译内核成功了**，但是编译输出里有一个 **板级电源域（power domain）配置的警告**，尤其是 Wi-Fi / Flash / Ethernet 这些外设的 IO 电源。

我们找到对应的`pmu_io_domains`代码 - 描述 RK3568 的 PMU（电源管理单元）里的 **IO 电压域配置功能**。

####  1. **`pmu_io_domains` 节点**：默认模板

```C
pmu_io_domains: io-domains {
    compatible = "rockchip,rk3568-pmu-io-voltage-domain";
    status = "disabled";
};
```

- **`pmu_io_domains`** 是一个节点名，用来描述 RK3568 的 PMU（电源管理单元）里的 **IO 电压域配置功能**。
- **`compatible`** 表明它使用 Rockchip 提供的 `rk3568-pmu-io-voltage-domain` 驱动
- **`status = "disabled";`** 表示这个节点在这里是默认禁用的（可能是个模板节点，具体板级文件会覆盖它的配置）

#### 2. `&pmu_io_domains` 配置块

```C
&pmu_io_domains {
    status = "okay";
    pmuio2-supply = <&vcc3v3_pmu>;
    vccio1-supply = <&vccio_acodec>;
    vccio3-supply = <&vccio_sd>;
    vccio4-supply = <&vcc_1v8>;
    vccio5-supply = <&vcc_3v3>;
    vccio6-supply = <&vcc_1v8>;
    vccio7-supply = <&vcc_3v3>;
};

```

这是引用前面定义的 `pmu_io_domains` 节点，并且**启用**（`status = "okay"`）并指定了各个 IO 域的供电来源。

每个 `vccioX-supply` 就是 **一个 IO 电源域的供电电压来源**：

- **vccio1-supply = <&vccio_acodec>**
   IO 域 1 用 `vccio_acodec` 这个电源（通常是音频编解码器接口）
- **vccio3-supply = <&vccio_sd>**
   IO 域 3 用 `vccio_sd` 电源（通常是 SD 卡接口）
- **vccio4-supply = <&vcc_1v8>**
   IO 域 4 用 1.8V 电源
- **vccio5-supply = <&vcc_3v3>**
   IO 域 5 用 3.3V 电源
- 依此类推……

这些 `<&xxx>` 是 **DTS 的 phandle 引用**，指向另一个节点（比如电源管理芯片、LDO、DCDC），告诉内核这个 IO 域用哪个电源供电。

DTS 里的这个节点就是告诉内核：

> “芯片的 IO 域 X 用哪个电压供电，这个电源是谁提供的”

最终编译内核时，会用板级的启用配置覆盖模板，这样板子启动时内核就知道每个 IO 域该用几伏。

### 编译Recovery

编译了很久，不出意外结果也不会很好

```bash
Done in 30min 30s  (error code: 2)
log saved on /home/crx/work/rk3568SDK/br.log
====Build rockchip_rk356x_recovery failed!====
```

后面还有其他信息

```bash
2025-08-14T15:22:43 /usr/bin/ld: /usr/local/lib/libpython2.7.a(posixmodule.o): in function `posix_tempnam':
2025-08-14T15:22:43 /home/crx/Downloads/Python-2.7.18/./Modules/posixmodule.c:7595:(.text+0xbde): warning: the use of `tempnam' is dangerous, better use `mkstemp'
2025-08-14T15:22:43 /usr/bin/ld: /usr/local/lib/libpython2.7.a(posixmodule.o): in function `posix_tmpnam':
2025-08-14T15:22:43 /home/crx/Downloads/Python-2.7.18/./Modules/posixmodule.c:7648:(.text+0xac6): warning: the use of `tmpnam_r' is dangerous, better use `mkstemp'
2025-08-14T15:22:43 /usr/bin/ld: /usr/local/lib/libpython2.7.a(signalmodule.o): warning: relocation against `PyExc_KeyboardInterrupt' in read-only section `.text'
2025-08-14T15:22:43 /usr/bin/ld: /usr/local/lib/libpython2.7.a(floatobject.o): relocation R_X86_64_PC32 against symbol `PyExc_TypeError' can not be used when making a shared object; recompile with -
fPIC
2025-08-14T15:22:43 /usr/bin/ld: final link failed: bad value
2025-08-14T15:22:43 collect2: error: ld returned 1 exit status
2025-08-14T15:22:43
2025-08-14T15:22:43 Python build finished, but the necessary bits to build these modules were not found:
2025-08-14T15:22:43 _bsddb             _hashlib           _sqlite3
2025-08-14T15:22:43 _tkinter           bsddb185           dbm
2025-08-14T15:22:43 dl                 gdbm               imageop
2025-08-14T15:22:43 nis                sunaudiodev
2025-08-14T15:22:43 To find the necessary bits, look in setup.py in detect_modules() for the module's name.
2025-08-14T15:22:43
2025-08-14T15:22:43
2025-08-14T15:22:43 Failed to build these modules:
2025-08-14T15:22:43 _bisect            _codecs_iso2022    _collections
2025-08-14T15:22:43 _csv               _ctypes            _ctypes_test
2025-08-14T15:22:43 _elementtree       _functools         _heapq
2025-08-14T15:22:43 _hotshot           _io                _json
2025-08-14T15:22:43 _locale            _lsprof            _md5
2025-08-14T15:22:43 _multibytecodec    _multiprocessing   _random
2025-08-14T15:22:43 _sha               _sha256            _sha512
2025-08-14T15:22:43 _socket            _ssl               _struct
2025-08-14T15:22:43 _testcapi          array              audioop
2025-08-14T15:22:43 binascii           cmath              cPickle
2025-08-14T15:22:43 crypt              cStringIO          datetime
2025-08-14T15:22:43 fcntl              future_builtins    grp
2025-08-14T15:22:43 itertools          linuxaudiodev      math
2025-08-14T15:22:43 mmap               operator           parser
2025-08-14T15:22:43 pyexpat            readline           resource
2025-08-14T15:22:43 select             spwd               strop
2025-08-14T15:22:43 syslog             termios            time
2025-08-14T15:22:43 unicodedata        zlib
2025-08-14T15:22:43
2025-08-14T15:22:43 make[2]: *** [Makefile:544: sharedmods] Error 1
2025-08-14T15:22:43 make[1]: *** [package/pkg-generic.mk:231: /home/crx/work/rk3568SDK/buildroot/output/rockchip_rk356x_recovery/build/host-python-2.7.16/.stamp_built] Error 2
2025-08-14T15:23:07 make: *** [/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk356x_recovery/Makefile:16: _all] Error 2
Command exited with non-zero status 1
you take 30:30.60 to build recovery
ERROR: Running build_recovery failed!
ERROR: exit code 1 from line 858:
    /usr/bin/time -f "you take %E to build recovery" $COMMON_DIR/mk-ramdisk.sh recovery.img $RK_CFG_RECOVERY
```



## DTS

DTS（Device Tree Source）本质上是一个**硬件描述文件**，用文本形式把**硬件连接和属性**记录下来，让 Linux 内核在启动时知道板子上有什么外设、它们是怎么连的、用什么参数工作。

你可以把它想象成：

> **硬件说明书 + 接线图 + 配置表**
>  用来告诉内核：“我这块板子长什么样、接口在哪、要怎么用”。

### 1. 它是怎么工作的

- DTS 是**人类可读**的文本文件
- 编译成 **DTB**（Device Tree Blob，二进制）
- U-Boot 或引导程序把 DTB 传给内核
- 内核解析 DTB，按里面的描述加载驱动、初始化外设

流程：

```bash
DTS(文本) --[dtc编译]--> DTB(二进制) --> 内核启动时读取
```

## buildroot

这是一个嵌入式 Linux 系统的构建工具。在本次旅程中，就是专门为`RK3568`负责生成对应系统的工具。它的目标是：

- 输入：配置文件（.config）
- 输出：一套可以直接启动到 Linux Shell 的系统镜像

> **一句话理解**：Buildroot 是一个“一键全家桶构建器”，帮你把引导程序、内核、文件系统全都编译好并打包成可烧录的镜像。

## u-boot、kernel、recovery、rootfs 的角色

整个启动流程可以这样看：

```bash
[ROM Code]
    |
    v
[U-Boot (Bootloader)]
    |
    v
[Linux Kernel]
    |
    v
[Root Filesystem (Buildroot生成)]
    |
    v
[User Space Applications]
```

- **u-boot（引导加载程序）**

  - 第一个运行的软件（在 SoC ROM code 之后）
  - 初始化 DRAM、时钟、串口等
  - 负责加载 Linux Kernel（和设备树 DTB）到内存
  - 可能还负责选择启动分区（比如正常启动 / recovery）

- **kernel（内核）**

  - Linux 操作系统的核心
  - 管理硬件（驱动）、进程调度、内存管理、网络协议
  - 启动后会挂载根文件系统（rootfs）并进入用户空间

- **rootfs（根文件系统）**

  - 包含所有用户空间程序、库、配置文件（bash、init、busybox 等）
  - Buildroot 会帮你编译并打包 rootfs

- **recovery（恢复模式）**
  - 一个特殊的 rootfs + 内核
  - 用于系统修复、固件更新、重新烧录系统
  - 类似手机的 Recovery 模式

###  Buildroot 与这些模块的关系

```CSS
          ┌─────────────┐
          │  Buildroot  │
          └──────┬──────┘
                 │
   ┌─────────────┼─────────────────┐
   │             │                 │
[U-Boot]     [Kernel]          [RootFS]
  (源码)       (源码)            (busybox, app, lib)
   │             │                 │
编译成bin   编译成zImage       制作成ext4/squashfs
   │             │                 │
   └─────打包成启动镜像─────────────┘

```

- **Buildroot 管理 u-boot、kernel、rootfs 的编译和打包流程**
- 它可以选择性地编译 recovery 镜像
- recovery 其实就是 **kernel + 一个特殊 rootfs**，Buildroot 也能帮你生成

## 如果不用 Buildroot 会怎样

你就得：

1. 自己去下载 u-boot 源码，交叉编译
2. 自己去下载 Linux 内核源码，交叉编译
3. 自己去编译 busybox、glibc 等库
4. 手动打包成文件系统
5. 自己写脚本把它们拼成一个启动镜像

> Buildroot 就是帮你自动化完成这些步骤。

# 8.18

## 打包报错

### 1️⃣ 问题根源

完成 Kernel/U-Boot/Recovery/Rootfs 各个部分的编译后，进⼊⼯程⽬录根⽬录执⾏以下命令⾃动完成所有的编译：

```bash
./build.sh all # 只编译模块代码（u-Boot，kernel，Rootfs，Recovery）

./build.sh
```

但是此时会报错：

```bash
/home/crx/work/rk3568SDK/.repo/repo/repo:625: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a futureects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
  now = datetime.datetime.utcnow()
Traceback (most recent call last):
  File "/home/crx/work/rk3568SDK/.repo/repo/main.py", line 56, in <module>
    from subcmds.version import Version
  File "/home/crx/work/rk3568SDK/.repo/repo/subcmds/__init__.py", line 34, in <module>
    mod = __import__(__name__,
          ^^^^^^^^^^^^^^^^^^^^
  File "/home/crx/work/rk3568SDK/.repo/repo/subcmds/help.py", line 20, in <module>
    from formatter import AbstractFormatter, DumbWriter
ModuleNotFoundError: No module named 'formatter'
ERROR: Running build_save failed!
ERROR: exit code 1 from line 1172:
    .repo/repo/repo forall -c "$TOP_DIR/device/rockchip/common/gen_patches_body.sh"
```

问题根源是：

```bash
ModuleNotFoundError: No module named 'formatter'
```

原因是：

- 系统 Python 版本是 **Python3.12**
- 老版本 repo（2020 年 master 分支）依赖 Python 内置模块 `formatter`，而 Python3.8+ 已经移除了这个模块
- 因此 **旧版 repo 脚本无法在新 Python 上运行**

### 2️⃣ 官方给出的解决思路

> repo sync -c 更新的时候提⽰ No module named formatter 这个由于您得主机使⽤新版本的python,
> ⽐如python3.8+完全移除了 formatter, 对外SDK得repo版本太旧导致, 这种只能更新repo版本 ⽐如通过如下
> ⽅式解决
>
> ```bash
> $ cd .repo/repo/
> $ git checkout origin/stable
> ```
>
> 这个分⽀repo是2022版本, 默认master分⽀是2020得版本. 或者repo init⼯程时候增加`--repo-rev=stable`来切换到新版本repo.
>
> ```bash
> repo init --repo-url ssh://git@www.rockchip.com.cn/repo/rk/tools/repo --repo-rev=stable \
> -u ssh://git@www.rockchip.com.cn/linux/rockchip/platform/manifests -b linux -m \
> rk3588_linux_release.xml
> ```

#### 方法 A：切换 repo 到 stable 分支

```bash
cd .repo/repo/
git checkout origin/stable
```

- stable 分支是 **2022 年版本**
- 新版 repo 脚本已经去掉了 `formatter` 依赖
- 适用于你这种 Python3.8+ 的环境

⚠️ 注意：

- 这只是切换了 repo 的源码（`subcmds/` 等目录），**不会自动替换 repo 可执行脚本**
- 你还需要确保执行的是 stable 分支的 repo 脚本，否则依然会报错

就像现在，依旧报错：

```bash
crx@crxVMstation:~/work/rk3568SDK/.repo/repo$ git checkout origin/stable
HEAD is now at 7896447 download: add a --branch option
crx@crxVMstation:~/work/rk3568SDK/.repo/repo$ ./repo --version
/home/crx/work/rk3568SDK/.repo/repo/./repo:621: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
  now = datetime.datetime.utcnow()
Traceback (most recent call last):
  File "/home/crx/work/rk3568SDK/.repo/repo/main.py", line 56, in <module>
    from subcmds.version import Version
  File "/home/crx/work/rk3568SDK/.repo/repo/subcmds/__init__.py", line 35, in <module>
    mod = __import__(__name__,
          ^^^^^^^^^^^^^^^^^^^^
  File "/home/crx/work/rk3568SDK/.repo/repo/subcmds/help.py", line 20, in <module>
    from formatter import AbstractFormatter, DumbWriter
ModuleNotFoundError: No module named 'formatter'
```

所以需要另想办法。

#### 方法 B：在 repo init 时直接指定 stable 版本

```bash
repo init --repo-url ssh://git@www.rockchip.com.cn/repo/rk/tools/repo \
  --repo-rev=stable \
  -u ssh://git@www.rockchip.com.cn/linux/rockchip/platform/manifests \
  -b linux \
  -m rk3588_linux_release.xml
```

- 作用：**下载并使用 stable 分支的 repo**
- 这样在 `repo sync` 时，就不会再遇到 `formatter` 错误

这个办法也没什么用，因为远程连接`rockchip`资源需要密码。

所以尝试直接使用Python3.8来安装。

## Python版本切换

这里的教程就是按照[How to Install Python 3.8 on Ubuntu 24.04](https://vegastack.com/tutorials/how-to-install-python-3-8-on-ubuntu-24-04/)来实现的。

但是前提是需要将虚拟机挂上代理，否则下载不了源码。

# 8.19

## stmmac

这是 Linux 内核里专门支持 **Synopsys DesignWare GMAC** 控制器的驱动。

- **Synopsys** 是一家做芯片 IP（Intellectual Property，知识产权核）的公司。
- **DesignWare GMAC (Gigabit Media Access Controller)** 就是它提供的一种 **以太网 MAC 控制器 IP**。
- **IP核**就是别人已经设计好的一块 **可复用的硬件模块**，用在芯片设计里。它通常是 **数字逻辑电路的设计文件**（比如用 Verilog/VHDL 写的），可以直接被拿来放进 SoC 里。
- 所谓 **IP 核**，就是一段可以直接被集成到芯片里的“硬件模块设计”，SoC 厂商（比如 Rockchip、全志）在做自己的芯片时，不需要自己重新设计以太网控制器，而是花钱买 Synopsys 的 GMAC 核心，放到芯片里用。

简单说：
SoC 厂商买了 Synopsys 的现成积木，塞进自己的芯片 → 这样芯片就有了网卡控制器。

- **Synopsys DesignWare GMAC 是一个通用的以太网控制器 IP。**

- **很多 ARM 芯片厂家都买了这个 IP 集成到自己的 SoC 里。**

- **Linux 内核里 stmmac 驱动就是专门用来驱动这些 GMAC 控制器的。**

## DMA 引擎

- **DMA（Direct Memory Access）**：直接内存访问。
- 在网卡里，DMA 的作用是：不用 CPU 逐个拷贝数据，而是让网卡硬件直接把数据搬进内存（接收），或者从内存搬出去（发送）。
- **没有 DMA** 的话，CPU 得自己去操作内存，网络吞吐量会非常低，基本跑不起来千兆网。

在 stmmac 驱动初始化时，它要做一件关键事：

 👉 配置 DMA 控制器，让网卡硬件知道数据缓冲区（Ring buffer）在哪里。

## 设备树

**原理分析：**

1. **设备树是 Linux 内核的“硬件说明书”**
   - 内核不知道板子上有哪些硬件，地址在哪里，时钟频率是多少，复位控制怎么拉。
   - DTS 文件告诉内核这些信息，驱动才能正确初始化。
2. **为什么影响 DMA reset**
   - DMA 是 MAC 的一个子模块，如果 **DMA 的寄存器地址、时钟或复位信号配置错误**，MAC 就无法正常复位 DMA。
   - 比如 clocks 配错 → DMA 无时钟 → reset 操作永远卡住。
   - resets 配错 → reset 线拉不到位 → DMA 无法进入初始状态。
   - phy-handle 配错 → 驱动无法绑定 PHY，虽然 DMA 可以重置，但链路无法建立。

**逻辑**：设备树错误 → 驱动读寄存器/配置硬件失败 → DMA reset 失败。

## 开发板网络问题

现在启动 RK3568 开发板，会报错：

```bash
[    4.768877] Generic PHY stmmac-1:02: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-1:02, irq=POLL)
[    4.874701] rk_gmac-dwmac fe010000.ethernet: Failed to reset the dma
[    4.874729] rk_gmac-dwmac fe010000.ethernet eth0: stmmac_hw_setup: DMA engine initialization failed
[    4.874740] rk_gmac-dwmac fe010000.ethernet eth0: stmmac_open: Hw setup failed
[    4.877194] Generic PHY stmmac-0:01: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-0:01, irq=POLL)
[    4.978391] rk_gmac-dwmac fe2a0000.ethernet: Failed to reset the dma
[    4.978421] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_hw_setup: DMA engine initialization failed
[    4.978433] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_open: Hw setup failed
```

说明 **（Synopsys DesignWare Ethernet MAC 驱动）初始化 DMA 引擎失败**，导致网卡设备 `eth0` / `eth1` 启动不起来。

可以把整个网卡启动类比成这样：

- **PHY 芯片**：像网口的“变压器”，负责和网线说话。
- **MAC 控制器**：像网卡的“大脑”，决定什么时候发/收包。
- **DMA 引擎**：像搬运工，把数据从网卡搬到内存（或者反过来）。
- **驱动（stmmac）**：像工头，负责叫醒“搬运工”，告诉它数据存放位置。

你现在遇到的情况，就是 **工头喊了半天，搬运工没动** → DMA reset 不成功。

## 修改 dts 树

现在问题在于：

> 官方手册的设备树配置中，`gmac0` 节点的 `phy-handle = <&rgmii_phy0>` 引用了一个名为 `rgmii_phy0` 的PHY设备。这个 `rgmii_phy0` 设备在 `mdio0` 节点下定义，其地址（`reg`）被设置为 **1**。
>
> 但是修改电路，将PHY芯片的地址从 **1** 改为 **0** 后，导致了网络端口（gmac0）无法连接网络。这背后的原因主要是因为 **设备树配置与实际硬件不匹配**。

### 详细解释

1. **设备树（Device Tree）的作用** 设备树是一种用于描述硬件设备信息的数据结构。Linux内核在启动时会解析这个文件，并根据其中的信息来识别和配置各种硬件设备，包括网络控制器（如gmac0）和与之相连的PHY芯片。
2. **`phy-handle` 和 PHY 地址**
   - `phy-handle` 属性在网络控制器（MAC）的设备树节点中，它的作用是告诉MAC控制器去哪里寻找与它连接的 **PHY（物理层）芯片**。
   - 它引用的是一个PHY设备的设备树节点，而这个PHY节点有一个重要的属性：`reg`。
   - `reg` 属性定义了PHY芯片在MDC/MDIO总线上的 **物理地址**。这个地址是唯一的，用于MAC控制器和PHY芯片进行通信，比如协商速率、双工模式等。
3. **设备树与硬件不匹配**
   - 您提供的设备树配置中，`rgmii_phy0` 节点的 `reg = <1>` 表示Linux内核会尝试在 **地址为1** 的位置去寻找PHY芯片。
   - 但您修改了电路，将PHY芯片的地址硬编码（通过硬件引脚配置）为 **0**。
   - 当Linux内核启动，驱动程序尝试通过MDIO总线与地址为1的PHY芯片通信时，它会发现 **找不到任何设备**。
4. **最终导致的结果**
   - MAC控制器（gmac0）无法与PHY芯片（地址为0的芯片）建立通信。
   - 由于无法进行通信，MAC控制器就无法获取PHY芯片的状态，例如链接状态、网络速率等。
   - 这会导致网络驱动程序无法正确配置网络接口，从而表现为 **“网口无法连接网络”** 的现象，即无法进行数据收发。

## 重新打包 DTS 办法

需要将设备树中的配置与实际硬件地址保持一致。设备树位于：

```bash
./kernel/arch/arm64/boot/dts/rockchip/myzr-rk3568-ddr4.dtsi
```

1. 将 `&mdio0` 节点下的 `rgmii_phy0` 设备的 `reg` 属性从 **1** 修改为 **0**，使其与您修改后的硬件地址匹配。

   ```C
   &mdio0 {
           rgmii_phy0: phy@0 {
                   compatible = "ethernet-phy-ieee802.3-c22";
                   reg = <0>;
           };
   };
   ```

2. 编译 kernel

   ```bash
   ./build.sh kernel
   ```

3. 打包 update.img

   ```bash
   ./build.sh updateimg
   ```

   生成目录为

   ```bash
   /home/crx/work/rk3568SDK/rockdev
   ```

   使用工具将`update.img`按照 SD启动 选项进行烧录。

   

## 重新梳理思路

此段dts树中的代码：

```C
//eth1 U5
&mdio0 {
        rgmii_phy0: phy@0 {
                compatible = "ethernet-phy-ieee802.3-c22";
                reg = <0>;
        };
};
//eth0 U9
&mdio1 {
        rgmii_phy1: phy@2 {
                compatible = "ethernet-phy-ieee802.3-c22";
                reg = <2>;
        };
};

```

设备树中有两个以太网控制器，它们与对应的 PHY 芯片和网络接口（`eth0`, `eth1`）之间的关系是这样的：

- **`eth1`** 对应 **`&mdio0`**，其 PHY 地址为 **0**。
- **`eth0`** 对应 **`&mdio1`**，其 PHY 地址为 **2**。

### 日志与设备树的对应关系

重新分析一下 `dmesg` 日志：

1. `[ 20.796152] Generic PHY stmmac-0:00: attached PHY driver...`
   - **`stmmac-0`** 对应 **`gmac0`** 控制器。
   - **`00`** 表示它找到了地址为 **0** 的 PHY。
   - 根据您的设备树，`eth1` 对应的正是 `gmac0` 和地址为 0 的 PHY。
   - **结论：`eth1` 的 PHY 驱动加载成功，硬件可识别。**
2. `[ 20.691327] Generic PHY stmmac-1:02: attached PHY driver...`
   - **`stmmac-1`** 对应 **`gmac1`** 控制器。
   - **`02`** 表示它找到了地址为 **2** 的 PHY。
   - 根据您的设备树，`eth0` 对应的正是 `gmac1` 和地址为 2 的 PHY。
   - **结论：`eth0` 的 PHY 驱动加载成功，硬件也可识别。**

到目前为止，一切正常。两个网口的 PHY 芯片都被内核正确识别了。

### 真正的问题所在

`eth0` 和 `eth1` 在启动时都出现了完全相同的 DMA 复位失败错误。

1. **PHY 驱动加载成功**
   - 当您启动 `eth1` 时，日志显示 `stmmac-0:00` 的 PHY 驱动加载成功。
   - 当您启动 `eth0` 时，日志显示 `stmmac-1:02` 的 PHY 驱动加载成功。
   - **这再次证明了 PHY 芯片和与之相关的设备树配置（`reg`, `phy-handle`）都是正确的。PHY 物理层是工作的。**
2. **DMA 复位失败**
   - `eth1` 的启动失败在 `fe2a0000.ethernet` 上。
   - `eth0` 的启动失败在 `fe010000.ethernet` 上。
   - `fe010000.ethernet` 通常对应 `gmac0`，`fe2a0000.ethernet` 通常对应 `gmac1`。
   - **这表明两个 MAC 控制器（`gmac0` 和 `gmac1`）都无法正常初始化它们的 DMA 引擎。**

### 根本原因的推断

既然两个独立的 MAC 控制器都出现了完全相同的错误，那么问题很可能不在于单个控制器的特定配置（如某个复位引脚接错），而在于**一个影响所有或多个 MAC 控制器的公共资源或配置。**

# 8.20

因为昨天弄得迷迷糊糊的，所以想今天重新梳理下，dts 树和网络连接的关系。

## 修改方案

加入 gmac 供电

```C
        ...
		pinctrl-names = "default";
        pinctrl-0 = <&gmac1m1_miim
                &gmac1m1_tx_bus2
                &gmac1m1_rx_bus2
                &gmac1m1_rgmii_clk
                &gmac1m1_rgmii_bus
                                &gmac1m1_clkinout>;

        tx_delay = <0x4f>;
        rx_delay = <0x26>;

        phy-supply = <&vcc3v3_phy>;
        phy-handle = <&rgmii_phy1>;
        status = "okay";
};

```

在根目录加入

```C
// 旧的后面直接加入即可...
        regulator-min-microvolt = <3300000>;
        regulator-max-microvolt = <3300000>;
        vin-supply = <&vcc5v0_sys>;
};

// 新加入 phy 电源部分
vcc3v3_phy: vcc3v3-phy-regulator {
        compatible="regulator-fixed"
        regulator-name ="vcc3v3_phy";
        regulator-min-microvolt = <3300000>;
        regulator-max-microvolt = <3300000>;
        regulator-boot-on;
        regulator-always-on;

};
```

## PHY芯片背景补充

现在RK3568板子上的phy芯片型号为

```BAsh
RTL8211E P3FF5(6)H1 GP14B
```

这部分内容部分来源于[PHY芯片快速深度理解](https://www.eet-china.com/mp/a292887.html)，部分来源于AI。

物理层芯片是 PHY 芯片，数据链路层芯片称为 MAC。

RGMII 和 MII 是连接 PHY 和 MAC 的标准接口（定义了两者如何交互通讯），常用于连接芯片内部的 MAC 和外部的 PHY 芯片。

### MDIO

定义：MDIO（Management Data Input/Output）是一种用于管理和控制以太网物理层设备（PHY）的接口标准。它通常与MII（Media Independent Interface）或RGMII（Reduced GMII）等数据接口配合使用，允许MAC（媒体访问控制）层与PHY层之间进行通信。

MDIO接口主要用于：

1. **配置和管理PHY设备**：MDIO可以用于读取和写入PHY的寄存器，配置如速度、双工模式、电源管理等设置。
2. **获取设备状态**：通过MDIO，MAC层可以查询PHY的状态信息，例如链路状态（链路是否正常）、错误指示等。
3. **调试和监控**：MDIO还可用于诊断PHY的工作状态，进行故障排查或性能监控。

MDIO通常使用两根线：

- **MDC（Management Data Clock）**：时钟信号线，用于同步数据传输。
- **MDIO（Management Data Input/Output）**：数据线，用于传输管理命令和数据。

MAC通过MDIO来配置PHY的工作状态，查询PHY的状态，或者诊断和调试PHY设备。

### MII

MII 是用于 MAC 和 PHY 之间的数据交换的。定义了 MAC 和 PHY 之间的数据传输格式和速度。

- **MII/RGMII** 是用于数据的高速传输，它们负责实际的网络数据包交换。

- **MDIO** 则用于管理控制，它让MAC能够配置PHY的工作状态、查询PHY的状态信息等，但不直接参与数据交换。

**MDIO** 让你“管理”PHY，而 **MII/RGMII** 让你“传输数据”。

## DTS树中的PHY和MAC配置

针对RK3568平台的以太网控制器和PHY芯片的设置，具体来说，它配置了**MDIO接口**、**PHY设备**以及**GMAC（以太网MAC）控制器**的相关参数。

### **1. MDIO接口配置**

`&mdio0` 和 `&mdio1` 配置了两个MDIO总线，这对应了RK3568平台上两个不同的以太网接口（`eth1` 和 `eth0`）所连接的PHY设备。

```C
&mdio0 {
    rgmii_phy0: phy@0 {
        compatible = "ethernet-phy-ieee802.3-c22";
        reg = <0>;
    };
};

&mdio1 {
    rgmii_phy1: phy@2 {
        compatible = "ethernet-phy-ieee802.3-c22";
        reg = <2>;
    };
};
```

#### mdio

在设备树中，`mdio0` 和 `mdio1` 是 **MDIO 总线接口的标识符**，它们通常映射到硬件平台上的两个不同的 **MDIO 总线控制器**。每个 MDIO 总线控制器可以管理一组 PHY 芯片。

- **`mdio0`**：表示第一个 MDIO 总线，控制与 **MDIO 总线 0** 相关的 **PHY 芯片**。它可以连接多个 PHY 设备。
- **`mdio1`**：表示第二个 MDIO 总线，控制与 **MDIO 总线 1** 相关的 **PHY 芯片**。它可以连接其他的 PHY 设备。

这些总线通常由 **网络控制器** 或 **SoC** 上的 **MAC 控制器** 提供支持。在设备树中，`&mdio0` 和 `&mdio1` 作为总线的引用，指向具体的硬件控制器或驱动。

这证明 RK3568 至少存在两个 MDIO 控制器，因此可以有多个 MDIO 总线（例如 `mdio0`、`mdio1` 等），每个总线可以管理不同的 PHY 设备。

#### phy

- **`phy@0`**：是设备树中节点的名字，表示该节点是一个 **PHY 芯片**，并且在设备树中命名为 `phy@0`

- **`reg = <0>`**：是表示该 PHY 芯片在 **MDIO 总线** 上的 **唯一地址**。即 **`reg = <0>`** 表示 PHY 芯片的地址是 0。

所以这段 MDIO 接口配置，最终决定了：

- `mdio0`总线上，绑定了地址为 0 的 PHY 芯片，且设备树名为`phy@0`
- `mdio1`总线上，绑定了地址为 2 的 PHY 芯片，且设备树名为`phy@2`

`phy@0` 是设备树中的节点名称，而 `reg = <0>` 则指定了该 PHY 芯片在 MDIO 总线上的地址。也就是说，理论上设备树中的节点名称和实际的 **PHY 地址** 是可以不同的。

#### **`phy@0` 和 `rgmii_phy0` 的关系**

- **`phy@0`** 是硬件设备的唯一标识符，代表的是 **MDIO 总线 0 上的地址为 0 的 PHY 芯片**，它用于描述和配置该设备的硬件属性。
- **`rgmii_phy0`** 是设备树中的别名，用于引用 **`phy@0`** 节点。它只是一个标签，让设备树的结构更加清晰和易于维护。
  - 你可以通过 **`rgmii_phy0`** 在设备树的其他地方进行引用，指向该 **PHY 芯片** 的配置。
  - 实际上，**`rgmii_phy0`** 是 **`phy@0`** 节点的一个别名，方便在设备树中进行标识和管理。

### **2. GMAC控制器配置**

GMAC（以太网MAC）控制器的配置。这些控制器负责实际的数据包处理和转发，并且与PHY芯片通过**RGMII**接口进行通信。

#### GMAC0 配置

```C
&gmac0 {
    phy-mode = "rgmii";
    clock_in_out = "input";
    snps,reset-gpio = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
    snps,reset-active-low;
    snps,reset-delays-us = <0 20000 100000>;
    assigned-clocks = <&cru SCLK_GMAC0_RX_TX>, <&cru SCLK_GMAC0>;
    assigned-clock-parents = <&cru SCLK_GMAC0_RGMII_SPEED>, <&gmac0_clkin>;
    assigned-clock-rates = <0>, <125000000>;
    pinctrl-names = "default";
    pinctrl-0 = <&gmac0_miim
                &gmac0_tx_bus2
                &gmac0_rx_bus2
                &gmac0_rgmii_clk
                &gmac0_rgmii_bus
                &gmac0_clkinout>;
    tx_delay = <0x3c>;
    rx_delay = <0x2f>;
    phy-supply = <&vcc3v3_phy>;
    phy-handle = <&rgmii_phy0>;
    status = "okay";
};
```

- `phy-mode = "rgmii"`：指定使用**RGMII**接口与PHY进行数据交换。

- `phy-handle = <&rgmii_phy0>`：指定此GMAC控制器连接的PHY设备（这里是`rgmii_phy0`，即`phy@0`）。

- `tx_delay` 和 `rx_delay`：设置RGMII信号的时序延迟，用于确保数据传输的同步性，避免信号冲突或错误。

### 3. 总结

1. MDIO 配置：用于连接 MAC 和  PHY 之间的管理信号
   - `&mdio0` 和 `&mdio1` 分别代表两个MDIO总线，每个总线连接一个PHY设备。
2. GMAC 控制器配置：每个 MDIO 控制器，配置了单独的以太网 MAC 控制器。
   - `phy-mode = "rgmii"` 表示使用RGMII接口进行数据交换。
   - `phy-handle = <&rgmii_phy0>` 和 `phy-handle = <&rgmii_phy1>` 确定了与哪个PHY芯片相连。
3. 硬件连接
   - MDIO 总线：用于配置和管理 PHY 设备，如读取链路状态或调整 PHY 设置。
   - RGMII 总线：用于数据传输，将数据从MAC层传递到PHY层，进行实际的以太网数据交换。

## DTS再总结

这段设备树描述了你板子上的两个网口，我们称它们为 **网口0** 和 **网口1**。（存疑，这部分内容，需要通过验证内核输出的信息）

- **网口1（对应U5）**
  - 它的硬件大脑是 **`gmac0`** 控制器。
  - 它的 PHY 芯片（负责物理连接）在 **`mdio0`** 总线上，地址是 **0** (`reg = <0>`)。
  - 设备树中，`&gmac0` 节点通过 `phy-handle = <&rgmii_phy0>` 告诉内核：“我的 PHY 芯片是 `rgmii_phy0`”。而 `rgmii_phy0` 正是那个在 `mdio0` 总线、地址为0的芯片。
- **网口0（对应U9）**
  - 它的硬件大脑是 **`gmac1`** 控制器。
  - 它的 PHY 芯片在 **`mdio1`** 总线上，地址是 **2** (`reg = <2>`)。
  - 设备树中，`&gmac1` 节点通过 `phy-handle = <&rgmii_phy1>` 告诉内核：“我的 PHY 芯片是 `rgmii_phy1`”。而 `rgmii_phy1` 则是那个在 `mdio1` 总线、地址为2的芯片。

**小结：** 从设备树上看，你的两个网口都配置得非常清楚，**`gmac0` 对应 网口1，`gmac1` 对应 网口0**。

## RGMII 数据线组成

| 信号名       | 方向             | 说明                 |
| ------------ | ---------------- | -------------------- |
| TXC          | 输出 (MAC → PHY) | 发送时钟，由MAC输出  |
| TXD[3:0]     | 输出 (MAC → PHY) | 发送数据，MAC发给PHY |
| RXC          | 输入 (PHY → MAC) | 接收时钟，由PHY输出  |
| RXD[3:0]     | 输入 (PHY → MAC) | 接收数据，PHY发给MAC |
| TXCTL / TXEN | 输出 (MAC → PHY) | 发送使能信号         |
| RXCTL / RXDV | 输入 (PHY → MAC) | 接收有效信号         |

- **TX（Transmit）**：MAC → PHY
- **RX（Receive）**：PHY → MAC

因此虽然RGMII总线可以在一条接口中完成双向通信，但**物理线路上是分开的**，不是同一根线双向传输

这样配置了 DTS 后，就需要编译到内核成为 DTB （硬件说明书）后，被内核识别。

## 确定eth1对应的gmac编号

### 1. `realpath` 输出

Linux 系统启动时，会把 **设备树中的 MAC 节点** 与 **内核网卡接口（ethX）** 对应起来。你可以检查：

```bash
ls /sys/class/net/eth1/device/of_node
```

- 这个目录会链接到设备树中对应的节点。
- 你可以通过 `realpath` 查看它对应的设备树路径：

```bash
root@RK356X:/# realpath /sys/class/net/eth1/device/of_node
/sys/firmware/devicetree/base/ethernet@fe2a0000
```

- `eth1` 对应的设备树节点是 `ethernet@fe2a0000`。

- 这个节点在设备树中正好是你看到的（`rk3568SDK/kernel/arch/arm64/boot/dts/rockchip/rk3568.dtsi`）：

```C
gmac0: ethernet@fe2a0000 {
    compatible = "rockchip,rk3568-gmac", "snps,dwmac-4.20a";
    ...
};
```

- 节点名 `gmac0` 是设备树中给这个节点起的 **别名**，地址 `fe2a0000` 与 `eth1` 对应的硬件地址一致。

### 2. **`dmesg` 日志**

```bash
root@RK356X:/# dmesg | grep eth1
[   10.943862] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_hw_setup: DMA engine initialization failed
[   10.943870] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_open: Hw setup failed
```

- 内核日志中显示 **eth1** 对应的设备是 `fe2a0000.ethernet`。
- `fe2a0000` 正是 **gmac0 的寄存器基地址**。
- 这说明 **eth1 绑定的 MAC 控制器就是 gmac0**。

### 3. 结论

结合 **设备树节点** 和 **内核日志**，可以确定：

- `eth1` 对应的硬件 MAC 控制器是 **gmac0**。

注意这里 `eth1` 只是操作系统中的接口名字，而 `gmac0` 是硬件控制器/设备树节点名称，两者通过设备树绑定。

# 8.21

## 验证 eth 对应的 GMAC

昨天已经将DTS配置里的 MDIO 和 GMAC 的关系理清了。下一步就是验证运行中的Linux是否真的按 DTS 配置在使用。

### 启动日志

内核启动时会根据 DTS 初始化 GMAC 和 PHY，日志里能看到匹配结果，首先是

```bash
dmesg | grep -i eth
```

输出结果为：

```BASH
root@RK356X:/# dmesg | grep eth 
[    0.000000] psci: probing for conduit method from DT.
[    1.814111] rk_gmac-dwmac fe010000.ethernet: Looking up phy-supply from device tree
[    1.814127] rk_gmac-dwmac fe010000.ethernet: Looking up phy-supply property in node /ethernet@fe010000 failed
[    1.814149] rk_gmac-dwmac fe010000.ethernet: no regulator found
[    1.814171] rk_gmac-dwmac fe010000.ethernet: clock input or output? (input).
[    1.814187] rk_gmac-dwmac fe010000.ethernet: TX delay(0x4f).
[    1.814201] rk_gmac-dwmac fe010000.ethernet: RX delay(0x26).
[    1.814219] rk_gmac-dwmac fe010000.ethernet: integrated PHY? (no).
[    1.814264] rk_gmac-dwmac fe010000.ethernet: clock input from PHY
[    1.814509] rk_gmac-dwmac fe010000.ethernet: init for RGMII
[    1.814755] rk_gmac-dwmac fe010000.ethernet: User ID: 0x30, Synopsys ID: 0x51
[    1.814776] rk_gmac-dwmac fe010000.ethernet: 	DWMAC4/5
[    1.814793] rk_gmac-dwmac fe010000.ethernet: DMA HW capability register supported
[    1.814805] rk_gmac-dwmac fe010000.ethernet: RX Checksum Offload Engine supported
[    1.814817] rk_gmac-dwmac fe010000.ethernet: TX Checksum insertion supported
[    1.814829] rk_gmac-dwmac fe010000.ethernet: Wake-Up On Lan supported
[    1.814867] rk_gmac-dwmac fe010000.ethernet: TSO supported
[    1.814880] rk_gmac-dwmac fe010000.ethernet: Enable RX Mitigation via HW Watchdog Timer
[    1.814894] rk_gmac-dwmac fe010000.ethernet: TSO feature enabled
[    1.949133] rk_gmac-dwmac fe2a0000.ethernet: Looking up phy-supply from device tree
[    1.949149] rk_gmac-dwmac fe2a0000.ethernet: Looking up phy-supply property in node /ethernet@fe2a0000 failed
[    1.949172] rk_gmac-dwmac fe2a0000.ethernet: no regulator found
[    1.949200] rk_gmac-dwmac fe2a0000.ethernet: clock input or output? (input).
[    1.949217] rk_gmac-dwmac fe2a0000.ethernet: TX delay(0x3c).
[    1.949231] rk_gmac-dwmac fe2a0000.ethernet: RX delay(0x2f).
[    1.949249] rk_gmac-dwmac fe2a0000.ethernet: integrated PHY? (no).
[    1.949296] rk_gmac-dwmac fe2a0000.ethernet: clock input from PHY
[    1.949538] rk_gmac-dwmac fe2a0000.ethernet: init for RGMII
[    1.949767] rk_gmac-dwmac fe2a0000.ethernet: User ID: 0x30, Synopsys ID: 0x51
[    1.949786] rk_gmac-dwmac fe2a0000.ethernet: 	DWMAC4/5
[    1.949803] rk_gmac-dwmac fe2a0000.ethernet: DMA HW capability register supported
[    1.949813] rk_gmac-dwmac fe2a0000.ethernet: RX Checksum Offload Engine supported
[    1.949826] rk_gmac-dwmac fe2a0000.ethernet: TX Checksum insertion supported
[    1.949838] rk_gmac-dwmac fe2a0000.ethernet: Wake-Up On Lan supported
[    1.949875] rk_gmac-dwmac fe2a0000.ethernet: TSO supported
[    1.949890] rk_gmac-dwmac fe2a0000.ethernet: Enable RX Mitigation via HW Watchdog Timer
[    1.949905] rk_gmac-dwmac fe2a0000.ethernet: TSO feature enabled
[    2.083003] usbcore: registered new interface driver cdc_ether
[    2.390245] optee: probing for conduit method from DT.
[   10.839533] rk_gmac-dwmac fe010000.ethernet: Failed to reset the dma
[   10.839567] rk_gmac-dwmac fe010000.ethernet eth0: stmmac_hw_setup: DMA engine initialization failed
[   10.839576] rk_gmac-dwmac fe010000.ethernet eth0: stmmac_open: Hw setup failed
[   10.943828] rk_gmac-dwmac fe2a0000.ethernet: Failed to reset the dma
[   10.943862] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_hw_setup: DMA engine initialization failed
[   10.943870] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_open: Hw setup failed
```

#### 1.eth 和 phy 对应关系

其中两个 gmac寄存器地址为（在`kernel/arch/arm64/boot/dts/rockchip/rk3568.dtsi`中定义）：

```C
gmac0: ethernet@fe2a0000...

gmac1: ethernet@fe010000...
```

- 内核日志中显示 **eth1** 对应的设备是 `fe2a0000.ethernet`，`eth0`对应的设备是`fe010000.ethernet`
- 而在另一个设备树中，`fe2a0000` 正是 **gmac0 的寄存器基地址**；`fe010000`是 gmac1 的寄存器基地址。
- 这说明 **eth1 绑定的 MAC 控制器就是 gmac0**；同理 **eth0 绑定的 MAC 控制器就是 gmac1**

所以现在理论上已知的网口对应的PHY关系为：

- `eth1` → `fe2a0000.ethernet`→`gmac0` → `mdio0`→ `rgmii_phy0`→ `phy0`
- `eth0`  → `fe010000.ethernet`→ `gmac1` → `mdio1`→ `rgmii_phy1`→ `phy2`

#### 2.实际启动信息

刚才上面`eth1`→`phy0`只是我们通过阅读 dts 文件和部分日志推论出来的：

```bash
[   10.839533] rk_gmac-dwmac fe010000.ethernet: Failed to reset the dma
[   10.839567] rk_gmac-dwmac fe010000.ethernet eth0: stmmac_hw_setup: DMA engine initialization failed
[   10.839576] rk_gmac-dwmac fe010000.ethernet eth0: stmmac_open: Hw setup failed
[   10.943828] rk_gmac-dwmac fe2a0000.ethernet: Failed to reset the dma
[   10.943862] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_hw_setup: DMA engine initialization failed
[   10.943870] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_open: Hw setup failed
```

但是实际真的是`eth1`对应的`mdio0`上的`phy0`芯片吗？我们还得进一步分析。

首先我们看下`fe010000`即推导`gmac1`启动日志：

```bash
[    0.000000] psci: probing for conduit method from DT.
[    1.814111] rk_gmac-dwmac fe010000.ethernet: Looking up phy-supply from device tree
[    1.814127] rk_gmac-dwmac fe010000.ethernet: Looking up phy-supply property in node /ethernet@fe010000 failed
[    1.814149] rk_gmac-dwmac fe010000.ethernet: no regulator found
[    1.814171] rk_gmac-dwmac fe010000.ethernet: clock input or output? (input).
[    1.814187] rk_gmac-dwmac fe010000.ethernet: TX delay(0x4f).
[    1.814201] rk_gmac-dwmac fe010000.ethernet: RX delay(0x26).
[    1.814219] rk_gmac-dwmac fe010000.ethernet: integrated PHY? (no).
[    1.814264] rk_gmac-dwmac fe010000.ethernet: clock input from PHY
[    1.814509] rk_gmac-dwmac fe010000.ethernet: init for RGMII
[    1.814755] rk_gmac-dwmac fe010000.ethernet: User ID: 0x30, Synopsys ID: 0x51
[    1.814776] rk_gmac-dwmac fe010000.ethernet: 	DWMAC4/5
[    1.814793] rk_gmac-dwmac fe010000.ethernet: DMA HW capability register supported
[    1.814805] rk_gmac-dwmac fe010000.ethernet: RX Checksum Offload Engine supported
[    1.814817] rk_gmac-dwmac fe010000.ethernet: TX Checksum insertion supported
[    1.814829] rk_gmac-dwmac fe010000.ethernet: Wake-Up On Lan supported
[    1.814867] rk_gmac-dwmac fe010000.ethernet: TSO supported
[    1.814880] rk_gmac-dwmac fe010000.ethernet: Enable RX Mitigation via HW Watchdog Timer
[    1.814894] rk_gmac-dwmac fe010000.ethernet: TSO feature enabled
```

我们看下这两行：

```bash
[    1.814187] rk_gmac-dwmac fe010000.ethernet: TX delay(0x4f).
[    1.814201] rk_gmac-dwmac fe010000.ethernet: RX delay(0x26).
```

这是之前 DTS 文件中，每个 gmac 控制器都有的配置，所以看下两个 gmac 配置的 TX 和 RX 延迟是多少：

gmac1：

```C
&gmac1 {
        phy-mode = "rgmii";
        clock_in_out = "input";
        ...

        tx_delay = <0x4f>;
        rx_delay = <0x26>;

        phy-handle = <&rgmii_phy1>;
        status = "okay";
};
```

gmac0：

```C
&gmac0 {
        phy-mode = "rgmii";
        clock_in_out = "input";
		...

        tx_delay = <0x3c>;
        rx_delay = <0x2f>;

        phy-supply = <&vcc3v3_phy>;
        phy-handle = <&rgmii_phy0>;
        status = "okay";
};
```

日志中，gmac地址`fe010000`的TX延迟为`0x4f`，RX延迟为`0x26`，对应的即为`gmac1`配置。这样既可以初步验证：

- `eth0`  → `fe010000.ethernet`→ `gmac1`

同理，也可验证：

- `eth1` → `fe2a0000.ethernet`→`gmac0`

这样我们初步验证的网口eth和对应的以太网控制器连接关系，就对应上了。**用 DTS 配置参数和内核打印进行交叉验证**，完全对应得上。

接下来要验证的就是 **gmac ↔ mdio ↔ phy** 的绑定关系，也就是 DTS 里 `phy-handle` 指向的 `rgmii_phy0 / rgmii_phy1` 是否真的被内核探测到了。

## 验证 eth ↔ gmac ↔ mdio ↔ phy 对应

在验证的时候，将目光转移到在上面的启动日志中较为后面的内容：

```bash
[   10.839533] rk_gmac-dwmac fe010000.ethernet: Failed to reset the dma
[   10.839567] rk_gmac-dwmac fe010000.ethernet eth0: stmmac_hw_setup: DMA engine initialization failed
[   10.839576] rk_gmac-dwmac fe010000.ethernet eth0: stmmac_open: Hw setup failed
[   10.943828] rk_gmac-dwmac fe2a0000.ethernet: Failed to reset the dma
[   10.943862] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_hw_setup: DMA engine initialization failed
[   10.943870] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_open: Hw setup failed
[65966.980361] rk_gmac-dwmac fe2a0000.ethernet: Failed to reset the dma
[65966.980391] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_hw_setup: DMA engine initialization failed
[65966.980400] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_open: Hw setup failed
```

- 两个 GMAC 控制器 `fe010000`（eth0）和 `fe2a0000`（eth1）都完成了基础初始化（时钟、RGMII 时序、DWMAC4/5 能力等）。
- **但在 `~10s` 打开网口时双双报错：**
   `Failed to reset the dma` → `stmmac_hw_setup: DMA engine initialization failed` → `stmmac_open: Hw setup failed`
- 日志里**没有出现**类似 “`... ethX: PHY ID xxxx at <addr>`” 的行。

从你这段 dmesg 看，**MAC（stmmac）在“打开网口”阶段就因为 “Failed to reset the dma” 掉坑了**，所以**还没走到真正“绑定 PHY”的那一步**；因此现在无法仅凭这段日志确认 `gmac ↔ phy-handle` 是否已生效。

##  PHY 芯片

`PHY` 并不仅仅指以太网的物理层芯片，而是所有通信/接口系统中“物理层（Physical Layer）”的实现模块。

### 1️⃣ PHY 的基本概念

- **PHY = Physical Layer Device**
   在 OSI 七层模型里，物理层（Layer 1）负责信号的实际传输，包括电气/光学信号、时序、编码、速率等。
- PHY 芯片就是把数字信号转换为物理媒介可传输的信号（电压、电流、光信号、射频信号等），也能把接收到的物理信号还原为数字信号给上层使用。

------

### 2️⃣ 不同接口的 PHY

| 接口类型                 | PHY 作用                                         | 典型芯片                        |
| ------------------------ | ------------------------------------------------ | ------------------------------- |
| **以太网**               | 将 MAC 的数字信号转换成以太网电缆上的差分电信号  | RTL8211、KSZ9031                |
| **USB**                  | 将 USB 控制器输出的数字信号转换为 USB 总线电信号 | USB3300、TUSB320                |
| **HDMI/CSI/DisplayPort** | 将图像/视频数据编码并发送到接口线缆              | ADV7513、TDA19988               |
| **PCIe / SATA / MIPI**   | 高速串行接口的物理信号收发                       | TI PCIe PHY、Rockchip MIPI DPHY |

> 🔹 总结：所有高速数字接口都需要 PHY 芯片做“数字 ↔ 模拟”的桥梁，同时保证信号完整性和时序。

### 3️⃣ PHY 的核心功能

1. **电平转换/驱动**：将芯片逻辑电平转换成接口电平。
2. **时钟/速率控制**：同步数据传输速率。
3. **信号调节**：包括均衡、去抖、抖动控制、前向纠错等。
4. **状态反馈**：比如以太网 PHY 会告诉 MAC 链路状态、速率、全双工/半双工等。

### 4️⃣ MAC + PHY 的关系（以以太网为例）

- **MAC（Media Access Controller）**：控制数据帧的打包、解析、流控等，是逻辑层。
- **PHY**：将 MAC 的数字信号映射到物理媒介上。
- **总线**：MAC 和 PHY 通常通过 MDIO/MII/RGMII/SPI 等接口连接。

同理，USB 或 PCIe 中也有“控制器 + PHY”的分层思想：

- USB 控制器负责协议/传输逻辑；
- USB PHY 负责电气信号的收发。

✅ **理解要点**

> PHY 是“物理信号层的接口芯片”，它与接口协议类型紧密相关，但本质都是完成数字 ↔ 物理信号的转换与可靠传输。它不处理高层协议逻辑，只关注信号的传输质量、时序和状态。

## stmmac 和 rk_gmac-dwmac 的关系

```C
[    1.814111] rk_gmac-dwmac fe010000.ethernet: Looking up phy-supply from device tree
[    1.814127] rk_gmac-dwmac fe010000.ethernet: Looking up phy-supply property in node /ethernet@fe010000 failed
[    1.814219] rk_gmac-dwmac fe010000.ethernet: integrated PHY? (no).
[    1.814264] rk_gmac-dwmac fe010000.ethernet: clock input from PHY
[    1.949133] rk_gmac-dwmac fe2a0000.ethernet: Looking up phy-supply from device tree
[    1.949149] rk_gmac-dwmac fe2a0000.ethernet: Looking up phy-supply property in node /ethernet@fe2a0000 failed
[    1.949249] rk_gmac-dwmac fe2a0000.ethernet: integrated PHY? (no).
[    1.949296] rk_gmac-dwmac fe2a0000.ethernet: clock input from PHY
[   10.737352] Generic PHY stmmac-1:02: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-1:02, irq=POLL)
[   10.842452] Generic PHY stmmac-0:01: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-0:01, irq=POLL)
```

stmmac 和 rk_gmac-dwmac 是 Linux 内核中以太网驱动相关的两个概念，它们之间是继承和适配的关系。

- 接口：stmmac（STMicroelectronics MAC）是 STMicroelectronics 开发的以太网控制器驱动，基于 Synopsys 的 DesignWare MAC（DWMAC）架构，可用于多种支持 DWMAC 的芯片平台，提供了通用的以太网功能初始化、硬件操作等功能。
- 继承并适配：rk_gmac-dwmac 则是 Rockchip 针对其芯片平台上的以太网 MAC 控制器所实现的驱动，在 stmmac 驱动的基础上进行了定制和扩展，以适配 Rockchip 芯片的硬件特性。

 rk_gmac-dwmac 复用了 stmmac 的部分核心初始化逻辑，并且根据 Rockchip 芯片的特点，添加一些特定的功能，如延迟线配置等。

## dmesg PHY 关键词

```bash
root@RK356X:/# dmesg | grep -i phy
[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]
[    0.000000] arch_timer: cp15 timer(s) running at 24.00MHz (phys).
[    1.744587] rockchip-csi2-dphy csi2-dphy0: csi2 dphy0 probe successfully!
[    1.744750] rockchip-csi2-dphy-hw fe870000.csi2-dphy-hw: csi2 dphy hw probe successfully!
[    1.746618] phy phy-fe8a0000.usb2-phy.0: Looking up phy-supply from device tree
[    1.746670] phy phy-fe8a0000.usb2-phy.0: Linked as a consumer to regulator.7
[    1.747895] extcon extcon1: failed to create extcon usb2-phy link
[    1.747960] phy phy-fe8b0000.usb2-phy.1: Looking up phy-supply from device tree
[    1.748010] phy phy-fe8b0000.usb2-phy.1: Linked as a consumer to regulator.6
[    1.748108] phy phy-fe8b0000.usb2-phy.2: Looking up phy-supply from device tree
[    1.748168] phy phy-fe8b0000.usb2-phy.2: Linked as a consumer to regulator.6
[    1.748249] phy phy-fe8b0000.usb2-phy.2: Looking up vbus-supply from device tree
[    1.748256] phy phy-fe8b0000.usb2-phy.2: Looking up vbus-supply property in node /usb2-phy@fe8b0000/otg-port failed
[    1.748278] phy phy-fe8b0000.usb2-phy.2: No vbus specified for otg port
[    1.750044] phy phy-fe850000.video-phy.3: Looking up phy-supply from device tree
[    1.750055] phy phy-fe850000.video-phy.3: Looking up phy-supply property in node /video-phy@fe850000 failed
[    1.750818] phy phy-fe860000.video-phy.4: Looking up phy-supply from device tree
[    1.750827] phy phy-fe860000.video-phy.4: Looking up phy-supply property in node /video-phy@fe860000 failed
[    1.752504] phy phy-fe820000.phy.5: Looking up phy-supply from device tree
[    1.752515] phy phy-fe820000.phy.5: Looking up phy-supply property in node /phy@fe820000 failed
[    1.752915] phy phy-fe830000.phy.6: Looking up phy-supply from device tree
[    1.752923] phy phy-fe830000.phy.6: Looking up phy-supply property in node /phy@fe830000 failed
[    1.753255] phy phy-fe840000.phy.7: Looking up phy-supply from device tree
[    1.753263] phy phy-fe840000.phy.7: Looking up phy-supply property in node /phy@fe840000 failed
[    1.754348] phy phy-fe8c0000.phy.8: Looking up phy-supply from device tree
[    1.754358] phy phy-fe8c0000.phy.8: Looking up phy-supply property in node /phy@fe8c0000 failed
[    1.763019] rochchip_p3phy_init: lock failed 0x6890000, check input refclk and power supply
[    1.763048] phy phy-fe8c0000.phy.8: phy init failed --> -110
[    1.763065] rk-pcie 3c0800000.pcie: fail to init phy, err -110
[    1.763078] rk-pcie 3c0800000.pcie: phy init failed
[    1.788917] rockchip-vop2 fe040000.vop: [drm:vop2_bind] vp0 assign plane mask: 0x15, primary plane phy id: 4
[    1.788943] rockchip-vop2 fe040000.vop: [drm:vop2_bind] vp1 assign plane mask: 0x22, primary plane phy id: 5
[    1.788964] rockchip-vop2 fe040000.vop: [drm:vop2_bind] vp2 assign plane mask: 0x8, primary plane phy id: 3
[    1.814111] rk_gmac-dwmac fe010000.ethernet: Looking up phy-supply from device tree
[    1.814127] rk_gmac-dwmac fe010000.ethernet: Looking up phy-supply property in node /ethernet@fe010000 failed
[    1.814219] rk_gmac-dwmac fe010000.ethernet: integrated PHY? (no).
[    1.814264] rk_gmac-dwmac fe010000.ethernet: clock input from PHY
[    1.949133] rk_gmac-dwmac fe2a0000.ethernet: Looking up phy-supply from device tree
[    1.949149] rk_gmac-dwmac fe2a0000.ethernet: Looking up phy-supply property in node /ethernet@fe2a0000 failed
[    1.949249] rk_gmac-dwmac fe2a0000.ethernet: integrated PHY? (no).
[    1.949296] rk_gmac-dwmac fe2a0000.ethernet: clock input from PHY
[    2.084714] rockchip-usb2phy fe8a0000.usb2-phy: Requested PHY is disabled
[    2.449859] rockchip-vop2 fe040000.vop: [drm:vop2_bind] vp0 assign plane mask: 0x15, primary plane phy id: 4
[    2.449882] rockchip-vop2 fe040000.vop: [drm:vop2_bind] vp1 assign plane mask: 0x22, primary plane phy id: 5
[    2.449897] rockchip-vop2 fe040000.vop: [drm:vop2_bind] vp2 assign plane mask: 0x8, primary plane phy id: 3
[    2.450561] dwhdmi-rockchip fe0a0000.hdmi: Detected HDMI TX controller v2.11a with HDCP (DWC HDMI 2.0 TX PHY)
[    2.521976] rockchip-csi2-dphy0: No link between dphy and sensor
[    2.522327] rockchip-csi2-dphy0: No link between dphy and sensor
[   10.737352] Generic PHY stmmac-1:02: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-1:02, irq=POLL)
[   10.842452] Generic PHY stmmac-0:01: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-0:01, irq=POLL)

```

这些信息记录了系统启动过程中各类 **PHY 设备**（物理层芯片）的初始化、探测和状态信息。PHY 不仅限于以太网（之前讨论的 MDIO 总线上的以太网 PHY），还包括 USB、视频（HDMI/CSI）、PCIe 等硬件的物理层芯片。

其实`PHY` 并不仅仅指以太网的物理层芯片，而是所有通信/接口系统中“物理层（Physical Layer）”的实现模块。

### 日志内容解析（按功能分类）：

#### 1. **摄像头相关 PHY（CSI-2 DPHY）**

```bash
[    1.744587] rockchip-csi2-dphy csi2-dphy0: csi2 dphy0 probe successfully!
[    1.744750] rockchip-csi2-dphy-hw fe870000.csi2-dphy-hw: csi2 dphy hw probe successfully!
[    2.521976] rockchip-csi2-dphy0: No link between dphy and sensor
[    2.522327] rockchip-csi2-dphy0: No link between dphy and sensor
```

- **含义**：CSI-2 DPHY 是摄像头接口（CSI）的物理层芯片，负责摄像头数据的传输。
- **状态**：驱动成功探测到 DPHY 硬件（`probe successfully`），但后续提示 `No link between dphy and sensor`，说明 **摄像头传感器未连接或未正常通信**（可能是摄像头未接、接触不良，或传感器驱动未加载）。

#### 2. **USB 相关 PHY（USB2 PHY）**

```bash
[    1.746618] phy phy-fe8a0000.usb2-phy.0: Looking up phy-supply from device tree
[    1.746670] phy phy-fe8a0000.usb2-phy.0: Linked as a consumer to regulator.7
[    1.747895] extcon extcon1: failed to create extcon usb2-phy link
[    1.747960] phy phy-fe8b0000.usb2-phy.1: Looking up phy-supply from device tree
[    1.748010] phy phy-fe8b0000.usb2-phy.1: Linked as a consumer to regulator.6
[    1.748108] phy phy-fe8b0000.usb2-phy.2: Looking up phy-supply from device tree
[    1.748168] phy phy-fe8b0000.usb2-phy.2: Linked as a consumer to regulator.6
[    1.748249] phy phy-fe8b0000.usb2-phy.2: Looking up vbus-supply from device tree
[    1.748256] phy phy-fe8b0000.usb2-phy.2: Looking up vbus-supply property in node /usb2-phy@fe8b0000/otg-port failed
[    1.748278] phy phy-fe8b0000.usb2-phy.2: No vbus specified for otg port
[    2.084714] rockchip-usb2phy fe8a0000.usb2-phy: Requested PHY is disabled
```

- **含义**：USB2 PHY 是 USB 2.0 接口的物理层芯片，负责 USB 信号的传输。
- 状态：
  - 驱动在设备树中查找 PHY 所需的电源（`phy-supply`），并成功关联到 regulators（电源管理模块）。
  - 部分警告（如 `failed to create extcon usb2-phy link`、`No vbus specified`）是正常的兼容性提示，不影响基本功能（可能是设备树未定义某些非必需属性）。
  - 最后 `Requested PHY is disabled` 说明某个 USB PHY 被禁用（可能是硬件设计中该接口未使用，驱动主动禁用）。

#### 3.**视频相关 PHY**

```bash
[    1.750044] phy phy-fe850000.video-phy.3: Looking up phy-supply from device tree
[    1.750055] phy phy-fe850000.video-phy.3: Looking up phy-supply property in node /video-phy@fe850000 failed
[    1.750818] phy phy-fe860000.video-phy.4: Looking up phy-supply from device tree
[    1.750827] phy phy-fe860000.video-phy.4: Looking up phy-supply property in node /video-phy@fe860000 failed
[    1.788917] rockchip-vop2 fe040000.vop: [drm:vop2_bind] vp0 assign plane mask: 0x15, primary plane phy id: 4
[    1.788943] rockchip-vop2 fe040000.vop: [drm:vop2_bind] vp1 assign plane mask: 0x22, primary plane phy id: 5
[    1.788964] rockchip-vop2 fe040000.vop: [drm:vop2_bind] vp2 assign plane mask: 0x8, primary plane phy id: 3
[    2.449859] rockchip-vop2 fe040000.vop: [drm:vop2_bind] vp0 assign plane mask: 0x15, primary plane phy id: 4
[    2.449882] rockchip-vop2 fe040000.vop: [drm:vop2_bind] vp1 assign plane mask: 0x22, primary plane phy id: 5
[    2.449897] rockchip-vop2 fe040000.vop: [drm:vop2_bind] vp2 assign plane mask: 0x8, primary plane phy id: 3
[    2.450561] dwhdmi-rockchip fe0a0000.hdmi: Detected HDMI TX controller v2.11a with HDCP (DWC HDMI 2.0 TX PHY)
```

- **含义**：视频 PHY 用于显示接口（如 HDMI、LCD）的信号传输，VOP（显示控制器）负责分配显示层（plane）与 PHY 的关联。
- 状态：
  - 视频 PHY 未找到 `phy-supply`（电源）属性，属于正常（可能由其他电源模块统一管理）。
  - VOP 成功分配显示层与 PHY 的关联（`primary plane phy id`），HDMI 控制器也成功探测到 PHY（`DWC HDMI 2.0 TX PHY`），说明显示相关 PHY 工作正常。

#### 4. **PCIe 相关 PHY**

```bash
[    1.752504] phy phy-fe820000.phy.5: Looking up phy-supply from device tree
[    1.752515] phy phy-fe820000.phy.5: Looking up phy-supply property in node /phy@fe820000 failed
[    1.752915] phy phy-fe830000.phy.6: Looking up phy-supply from device tree
[    1.752923] phy phy-fe830000.phy.6: Looking up phy-supply property in node /phy@fe830000 failed
[    1.753255] phy phy-fe840000.phy.7: Looking up phy-supply from device tree
[    1.753263] phy phy-fe840000.phy.7: Looking up phy-supply property in node /phy@fe840000 failed
[    1.754348] phy phy-fe8c0000.phy.8: Looking up phy-supply from device tree
[    1.754358] phy phy-fe8c0000.phy.8: Looking up phy-supply property in node /phy@fe8c0000 failed
[    1.763019] rochchip_p3phy_init: lock failed 0x6890000, check input refclk and power supply
[    1.763048] phy phy-fe8c0000.phy.8: phy init failed --> -110
[    1.763065] rk-pcie 3c0800000.pcie: fail to init phy, err -110
[    1.763078] rk-pcie 3c0800000.pcie: phy init failed
```

- **含义**：PCIe PHY 是 PCIe 接口的物理层芯片，负责高速数据传输。
- 状态：
  - PCIe PHY 未找到 `phy-supply` 属性（正常），但最终初始化失败（`phy init failed --> -110`）。
  - 错误码 `-110` 对应 `ETIMEDOUT`（超时），日志提示 `check input refclk and power supply`，说明 **PCIe PHY 的时钟（refclk）或电源供应异常**，导致 PCIe 控制器初始化失败（可能是硬件故障或固件配置问题）。

#### 5. **以太网相关 PHY（stmmac 驱动管理）**

```bash
[    1.814111] rk_gmac-dwmac fe010000.ethernet: Looking up phy-supply from device tree
[    1.814127] rk_gmac-dwmac fe010000.ethernet: Looking up phy-supply property in node /ethernet@fe010000 failed
[    1.814219] rk_gmac-dwmac fe010000.ethernet: integrated PHY? (no).
[    1.814264] rk_gmac-dwmac fe010000.ethernet: clock input from PHY
[    1.949133] rk_gmac-dwmac fe2a0000.ethernet: Looking up phy-supply from device tree
[    1.949149] rk_gmac-dwmac fe2a0000.ethernet: Looking up phy-supply property in node /ethernet@fe2a0000 failed
[    1.949249] rk_gmac-dwmac fe2a0000.ethernet: integrated PHY? (no).
[    1.949296] rk_gmac-dwmac fe2a0000.ethernet: clock input from PHY
[   10.737352] Generic PHY stmmac-1:02: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-1:02, irq=POLL)
[   10.842452] Generic PHY stmmac-0:01: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-0:01, irq=POLL)
```

- **含义**：这是你之前关注的以太网 PHY（由 stmmac 驱动的 `rk_gmac-dwmac` 控制器管理）。
- 状态：
  - 以太网控制器（`fe010000.ethernet` 和 `fe2a0000.ethernet`）未找到 `phy-supply`（正常，电源可能由其他模块管理），且明确不是集成 PHY（`integrated PHY? (no)`），需要通过 MDIO 总线连接外部 PHY。
  - 最终日志 `attached PHY driver` 表明：两个以太网 PHY（`stmmac-0:01` 和 `stmmac-1:02`）成功与驱动关联，说明 **以太网 PHY 初始化成功**，与你之前在 `/sys/bus/mdio_bus/devices/` 看到的设备一致。

```bash
硬件 GMAC（fe010000） 
   ↓ DTS 描述
platform device（fe010000.ethernet） 
   ↓ 驱动 probe
stmmac-0 MDIO 总线注册 
   ↓ PHY 扫描 / phy-handle
stmmac-0:01 → Generic PHY driver
```



## 验证 GMAC 和 PHY 对应关系

其实这一步叫做：扫描 MDIO 总线 → 绑定 PHY 驱动。

我们上面执行了`dmesg | grep eth `，但是只得出了:

- `eth0`  → `fe010000.ethernet`→ `gmac1`
- `eth1` → `fe2a0000.ethernet`→`gmac0`

那么下一步就是验证`gmac`对应哪个`phy`芯片。

### 1️⃣ DTS 配置回顾

配置了两个 MDIO 总线和 PHY：

```C
&mdio0 {
        rgmii_phy0: phy@0 {
                compatible = "ethernet-phy-ieee802.3-c22";
                reg = <0>;
        };
}; // eth0 U9

&mdio1 {
        rgmii_phy1: phy@2 {
                compatible = "ethernet-phy-ieee802.3-c22";
                reg = <2>;
        };
};
```

意思是：

- `mdio0` 上挂了一个 PHY，地址 **0**
- `mdio1` 上挂了一个 PHY，地址 **2**

### 2️⃣ 内核日志含义

执行

```bash
dmesg | grep -i phy
```

日志分两类：

#### (a) GMAC 初始化

```bash
[    1.814***] rk_gmac-dwmac fe010000.ethernet: ...
[    1.949***] rk_gmac-dwmac fe2a0000.ethernet: ...
```

说明 DTS 里的 **ethernet@fe010000** （gmac1）和 **ethernet@fe2a0000**（gmac0） 两个 GMAC 节点被驱动`rk_gmac-dwmac`探测到了。

#### (b) PHY 绑定

```bash
[   10.737352] Generic PHY stmmac-1:02: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-1:02, irq=POLL)
[   10.842452] Generic PHY stmmac-0:01: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-0:01, irq=POLL)
```

参数解释：

- stmmac - 0 和 stmmac - 1，这是 **MDIO 总线（mii_bus）的名字**，由 stmmac 驱动在注册 MDIO 总线时自动生成。

- 冒号后面的 `:01` / `:02` 含义：这是 **PHY 的地址**（`phy_addr`），位于 MDIO 总线上的编号。

  在日志里：

  - `stmmac-0:01` → 代表 **挂在 stmmac-0 这个 MDIO 总线上的 PHY，地址是 0x01**
  - `stmmac-1:02` → 代表 **挂在 stmmac-1 这个 MDIO 总线上的 PHY，地址是 0x02**

拆解：

- `stmmac-1:02`
  - **stmmac-1** → 第二个 GMAC（`fe2a0000.ethernet`）的 MDIO 总线
  - **:02** → 在这个总线上的 PHY 地址是 **2**
  - → 对应 DTS 的 `&mdio1 { phy@2 {...} }` ✅
- `stmmac-0:01`
  - **stmmac-0** → 第一个 GMAC（`fe010000.ethernet`）的 MDIO 总线
  - **:01** → 在这个总线上的 PHY 地址是 **1**
  - → 这里有差异：你的 DTS 写的是 `phy@0`，但是驱动里探测并绑定到了 PHY 地址 **1**。

### 3️⃣ 结论

✔️ DTS 生效了：

- `fe010000.ethernet` → stmmac-0 → PHY 地址 **1**
- `fe2a0000.ethernet` → stmmac-1 → PHY 地址 **2**

❌ 但注意：

- 你写 `phy@0`，日志显示实际 attach 到了 **01**。

   这说明 **硬件上 PHY 的地址不是 0，而是 1**。可能是硬件 strap 引脚设置成了 1，或者板子设计就是这样。

## probe阶段

在阅读gpt提供的答案时候，提到了`probe阶段`：

> - 驱动里注册 MDIO 总线时会自动生成名字：
>
>   ```css
>   stmmac-[n]
>   ```
>
>   - `n` 是驱动在 probe 阶段注册的顺序号，从 0 开始。
>   - probe 顺序通常按照设备树里节点出现顺序或 platform_bus 探测顺序。

那么什么是`probe`阶段呢？

### 1.什么是 probe

**probe** 是驱动程序中一个函数，通常命名为 `xxx_probe()`，它的作用是 **在设备被发现（匹配）后初始化设备**。

> “驱动看到硬件来了，赶紧来初始化它，让它能正常工作。”

### 2.主要功能

| 步骤             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| **设备匹配**     | 驱动已经通过 `of_match_table`（设备树匹配表）、PCI/Vendor ID 等找到对应硬件 |
| **分配资源**     | 分配内存空间、寄存器映射（`ioremap`）、DMA 缓冲区等          |
| **获取硬件信息** | 读取设备树属性，如 PHY 节点、时钟、复位线、GPIO 等           |
| **初始化硬件**   | 配置寄存器、启动 DMA、初始化 MAC 控制器、配置 PHY 等         |
| **注册设备接口** | 在内核中注册网络接口、字符设备、块设备等，让上层可以使用     |
| **错误处理**     | 如果某一步失败，需要回滚之前分配的资源，保证系统稳定         |

### 3.以RK3568 网络驱动为例

日志中显示：

```bash
rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_hw_setup: DMA engine initialization failed
rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_open: Hw setup failed
```

这里发生的就是 **probe 阶段失败**：

- 驱动检测到 **fe2a0000.ethernet** 节点（gmac0）
- 调用 **rk_gmac-dwmac 驱动的 probe 函数**：
  1. 获取设备树中的 PHY 节点信息（`phy-supply`、PHY 地址）
  2. 初始化 DMA、时钟、复位
  3. 配置 MAC 寄存器
- 结果 `DMA engine initialization failed` → DMA 初始化失败，probe 就没有完成，导致 `eth1` 无法使用。



## rk_gmac-dwmac → stmmac 驱动框架

```bash
rk_gmac-dwmac fe010000.ethernet
rk_gmac-dwmac fe2a0000.ethernet
```

→ 变成

```bash
stmmac-0
stmmac-1
```

------

### 1. fe010000.ethernet、fe2a0000.ethernet

- `fe010000` / `fe2a0000` 是 **设备树里定义的寄存器基地址**（reg 属性），对应 SoC 内部的 GMAC 控制器的物理基地址。
- `rk_gmac-dwmac` 是驱动名（rockchip 平台的 GMAC glue 层，底层复用 `stmmac` 通用驱动）。
- 所以内核打印 `rk_gmac-dwmac fe010000.ethernet`，其实就是：
   👉 "rockchip gmac-dwmac 驱动实例，挂在地址 0xfe010000 的以太网控制器节点上"。

------

### 2. stmmac-N 命名逻辑

RK3568 的 stmmac 驱动可能在：

```bash
./kernel/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c:2304:           .name           = "rk_gmac-dwmac",
```

- Linux 内核的 **stmmac 驱动**（`drivers/net/ethernet/stmicro/stmmac/`）里，维护一个 **全局静态计数器**。
- 每实例化一个 GMAC，就会分配一个唯一的名字：`stmmac-0`、`stmmac-1`、`stmmac-2` ……
- 这个名字并不是 DTS 里规定的，而是驱动里 **自动生成** 的。

👉 也就是说：

- 第一个探测到的 GMAC（这里是 `fe010000.ethernet`） → `stmmac-0`
- 第二个探测到的 GMAC（这里是 `fe2a0000.ethernet`） → `stmmac-1`

（顺序由设备树和总线扫描顺序决定，一般和 DTS 节点声明顺序一致）

------

### 3. PHY 绑定的逻辑

当 GMAC 初始化时：

1. `dwmac-mdio`驱动会创建一个 `mii_bus`，名字就是 `stmmac-N`。
2. 通过 `phy-handle`（DTS 属性）去找对应的 MDIO 总线和 PHY 节点。
3. 绑定成功后，你就会看到这样的日志：

```bash
Generic PHY stmmac-1:02: attached PHY driver [...]
Generic PHY stmmac-0:01: attached PHY driver [...]
```

解读：

- `stmmac-1:02` → 表示 PHY 在 `stmmac-1` 这条 MII 总线上的地址 0x02。
- `stmmac-0:01` → 表示 PHY 在 `stmmac-0` 这条 MII 总线上的地址 0x01。

这就是 DTS 里 `mdio0/phy@1`、`mdio1/phy@2` 的落地结果。

------

### 4. 总结一句

- `fe010000.ethernet` / `fe2a0000.ethernet` → 来自 DTS 的寄存器基地址节点。
- `stmmac-0` / `stmmac-1` → 驱动内部给实例化的 GMAC 分配的逻辑名（通过计数器）。
- PHY 绑定信息（`stmmac-N:XX`）就是 **驱动把 GMAC → MDIO bus → PHY 地址** 的关系串起来后打印的。

所以：
 ✅ 这个命名不是 DTS 硬性规定的，而是 **rk_gmac-dwmac → stmmac 驱动框架**里定义的逻辑。

------

## 重新烧录版本

### 修改后的 DTS

现在为了排除之前的 PHY 对应地址错误问题，这次重新修改后的 DTS 到 SD 卡：

```C
&mdio0 {
    rgmii_phy0: phy@0 {
        compatible = "ethernet-phy-ieee802.3-c22";
        reg = <0>;
    };
};

&mdio1 {
    rgmii_phy1: phy@2 {
        compatible = "ethernet-phy-ieee802.3-c22";
        reg = <2>;
    };
};
```

- **`mdio0`**：表示第一个 MDIO 总线，控制与 **MDIO 总线 0** 相关的 **PHY 芯片**。它可以连接多个 PHY 设备。
- **`mdio1`**：表示第二个 MDIO 总线，控制与 **MDIO 总线 1** 相关的 **PHY 芯片**。它可以连接其他的 PHY 设备。

如果按照这个版本看日志的话，应该会有：

- gmac0 的 PHY 芯片地址为 mdio 总线的位置 0
- gmac1 的 PHY 芯片地址为 mdio 总线的位置 2

我们看下日志信息。

### 日志记录

```bash
root@RK356X:/# dmesg | grep -i phy
[    1.808328] rk_gmac-dwmac fe010000.ethernet: Looking up phy-supply from device tree
[    1.808343] rk_gmac-dwmac fe010000.ethernet: Looking up phy-supply property in node /ethernet@fe010000 failed
[    1.808438] rk_gmac-dwmac fe010000.ethernet: integrated PHY? (no).
[    1.808484] rk_gmac-dwmac fe010000.ethernet: clock input from PHY
[    1.943956] rk_gmac-dwmac fe2a0000.ethernet: Looking up phy-supply from device tree
[    1.944105] rk_gmac-dwmac fe2a0000.ethernet: integrated PHY? (no).
[    1.944151] rk_gmac-dwmac fe2a0000.ethernet: clock input from PHY
[    2.079432] rockchip-usb2phy fe8a0000.usb2-phy: Requested PHY is disabled
[   20.770106] Generic PHY stmmac-1:02: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-1:02, irq=POLL)
[   20.874499] Generic PHY stmmac-0:00: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-0:00, irq=POLL)
```

初始化 GMAC 控制器时，`stmmac` 驱动会注册一个 MDIO 总线，名字自动生成为 `stmmac-<id>`：

- 第一个探测到的 GMAC（fe010000 → gmac1） → `stmmac-0`
- 第二个探测到的 GMAC（fe2a0000 → gmac0） → `stmmac-1`

随后会通过 `phy-handle`（DTS 属性）去找对应的 MDIO 总线和 PHY 节点。

### PHY 扫描 & 绑定

- `stmmac-1:02` → 表示 **在 MDIO 总线 stmmac-1 上，探测到地址 0x02 的 PHY**，驱动绑定成功。
- `stmmac-0:00` → 表示 **在 MDIO 总线 stmmac-0 上，探测到地址 0x00 的 PHY**。

对应关系：

- `gmac0 (fe2a0000)` → 通过 `phy-handle = <&phy0>` 绑定到 **MDIO addr 0x00**
- `gmac1 (fe010000)` → 通过 `phy-handle = <&phy1>` 绑定到 **MDIO addr 0x02**

但是我们配置的 DTS 为：

```C
&mdio0 {
    rgmii_phy0: phy@0 {
        compatible = "ethernet-phy-ieee802.3-c22";
        reg = <0>;
    };
};

&mdio1 {
    rgmii_phy1: phy@2 {
        compatible = "ethernet-phy-ieee802.3-c22";
        reg = <2>;
    };
};
```

# 8.22

##  `stmmac` 的编号和 DTS 树

------

您提供的日志和设备树配置确实揭示了一个有趣的细节，完美地解释了为什么 `stmmac` 的编号与您在设备树中看到的 PHY 地址配置不匹配。

让我们一步步来分析。

### 1. 梳理设备树配置

首先，我们来整理您提供的设备树（DTS）片段中的对应关系：

- **`&gmac0` 节点：**
  - `phy-handle = <&rgmii_phy0>`
  - 根据下面的 `&mdio0` 配置，`rgmii_phy0` 的 `reg` 地址是 `<0>`。
  - 所以，**DTS 中，`gmac0` 对应 PHY 地址 `0x00`。**
- **`&gmac1` 节点：**
  - `phy-handle = <&rgmii_phy1>`
  - 根据下面的 `&mdio1` 配置，`rgmii_phy1` 的 `reg` 地址是 `<2>`。
  - 所以，**DTS 中，`gmac1` 对应 PHY 地址 `0x02`。**

### 27. 分析 `dmesg` 日志

现在，我们来看 `dmesg` 日志中 PHY 驱动的挂载信息：

- **`[ 20.643018] Generic PHY stmmac-1:02: attached PHY driver ...`**
  - 这行日志表示，`stmmac-1` 这个 GMAC 控制器，其 MDIO 总线上的 PHY 设备地址是 `02`。
  - 结合我们之前的分析：`stmmac-1` 对应的是 `fe2a0000.ethernet`，也就是 DTS 中的 `gmac0`。
  - **结论：`gmac0` 的 PHY 地址是 `0x02`。**
- **`[ 20.747888] Generic PHY stmmac-0:00: attached PHY driver ...`**
  - 这行日志表示，`stmmac-0` 这个 GMAC 控制器，其 MDIO 总线上的 PHY 设备地址是 `00`。
  - 结合我们之前的分析：`stmmac-0` 对应的是 `fe010000.ethernet`，也就是 DTS 中的 `gmac1`。
  - **结论：`gmac1` 的 PHY 地址是 `0x00`。**

### 3. 对比与解释

现在，我们将 DTS 的配置与实际的启动日志进行对比：

|             | DTS 配置        | `dmesg` 日志             | **是否匹配？** |
| ----------- | --------------- | ------------------------ | -------------- |
| **`gmac0`** | PHY 地址 `0x00` | 实际上 PHY 地址是 `0x02` | **不匹配**     |
| **`gmac1`** | PHY 地址 `0x02` | 实际上 PHY 地址是 `0x00` | **不匹配**     |

这确实表明 DTS 文件中的 PHY 地址配置与实际的硬件连接不一致。

### 问题根源和解决方案

**问题根源：**

Linux 内核在启动时，会按照 DTS 中指定的 `phy-handle` 引用来查找 PHY 设备。但是，如果 `phy-handle` 节点中定义的 `reg` 地址与实际硬件上 PHY 芯片的物理地址（通常由硬件跳线或引脚配置）不一致，就会出现您所看到的问题。

## DMA复位失败的根本原因分析

DMA复位失败（`Failed to reset the dma`）通常意味着设备无法完成其基本的初始化步骤。在你的案例中，这最可能与以下两个方面有关：

- **时钟（Clock）**：DMA引擎需要一个正常工作的时钟信号来驱动其内部逻辑。如果时钟信号缺失、不稳定或者频率不正确，DMA就无法响应复位命令。
- **复位（Reset）**：DMA引擎需要一个有效的复位信号来将其内部寄存器和状态恢复到初始值。如果复位信号没有正常触发，或者被错误地配置，DMA将一直处于不确定的状态，无法启动。

由于两个网口（`gmac0`和`gmac1`）都出现同样的问题，这几乎可以排除单个网口的硬件损坏，而指向一个**共享的、全局性的问题**。最可疑的就是**时钟和复位配置**。

## 寻找 DMA 初始化失败的问题

### 问题核心：两个网口都无法工作

```bash
root@RK356X:/# ifconfig eth1 up
[   41.874032] Generic PHY stmmac-0:00: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-0:00, irq=POLL)
[   41.976719] rk_gmac-dwmac fe2a0000.ethernet: Failed to reset the dma
[ ifcon fig: SIOCSIFFLAGS: Device or resource busy
 41.97root@RK356X:/# 6748] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_hw_setup: DMA engine initialization failed
[   41.976756] rk_gmac-dwmac fe2a0000.ethernet eth1: stmmac_open: Hw setup failed


root@RK356X:/# ifconfig eth0 up
[  156.151071] Generic PHY stmmac-1:02: attached PHY driver [Generic PHY] (mii_bus:phy_addr=stmmac-1:02, irq=POLL)
[  156.252871] rk_gmac-dwmac fe010000.ethernet: Failed to reset the dma
[  15ifconfig: SIOCSIFFLAGS: Device or resource busy
6.252905] root@RK356X:/# rk_gmac-dwmac fe010000.ethernet eth0: stmmac_hw_setup: DMA engine initialization failed
[  156.252915] rk_gmac-dwmac fe010000.ethernet eth0: stmmac_open: Hw setup failed
```

根据之前的日志，我们知道 `eth0` 和 `eth1` 两个网口都启动失败了，而且失败的原因是完全一样的：**DMA 引擎无法复位**。

- 当你尝试启动 `eth0` 时，内核在 `rk_gmac-dwmac fe010000.ethernet` (也就是 `gmac1`) 上报错。
- 当你尝试启动 `eth1` 时，内核在 `rk_gmac-dwmac fe2a0000.ethernet` (也就是 `gmac0`) 上报错。

这个日志再次证实了我们之前的结论：**问题不在于某个特定的网口，而是影响所有网口的通用问题。**

### 可能的原因

既然两个网口都出问题，而且是同样的错误，那么原因很可能出在它们共享的资源上。

1. **时钟或复位配置不正确** 这是最可能的原因。`DMA` 无法复位通常是因为它没有获得正确的工作时钟，或者它的复位信号没有正常工作。

   - **设备树（软件）问题**：在设备树中，`gmac0` 和 `gmac1` 节点所引用的时钟和复位资源（如 `SCLK_GMAC0`, `SCLK_GMAC1`, `SRST_A_GMAC0`, `SRST_A_GMAC1`）可能没有被正确地定义或使能。即使它们看起来是独立的，也可能依赖于同一个不正确的父时钟。
   - **硬件问题**：即使设备树配置正确，时钟或复位信号也可能由于硬件原因（如晶振损坏、PCB 走线错误、电源不稳定等）而没有到达 MAC 芯片。

2. **通用驱动或内核版本不匹配** 虽然可能性较低，但不能排除。你使用的 Linux 内核版本可能与你的设备型号（RK3568）的网卡驱动（`gmac-dwmac`）存在不兼容或已知的 Bug，导致 DMA 初始化失败。

3. **电源管理问题** `gmac0` 和 `gmac1` 可能共享一路电源。如果这路电源不稳定，或者在驱动尝试初始化时电压跌落，也可能导致 DMA 复位失败

   ------

### 后续排查的方向

你需要从软件和硬件两个层面，系统性地进行排查。

#### 软件排查：聚焦设备树（DTS）

1. **检查所有时钟和复位配置**：
   - 找到 `&cru` 节点。这个节点是所有时钟和复位资源的“总开关”。
   - 在 `&cru` 节点下，检查 `SCLK_GMAC0`, `SCLK_GMAC1`, `SRST_A_GMAC0`, `SRST_A_GMAC1` 等资源的定义。
   - 确保这些时钟的**父时钟**和**频率**被正确配置。比如，`SCLK_GMAC0` 是否来自一个正确的 PLL？频率是否是 `125MHz`？
2. **确认 GPIO 引脚**：
   - 检查 `gmac0` 和 `gmac1` 节点中的 `snps,reset-gpio` 属性。确保它所指向的 GPIO 引脚 (`gpio3 RK_PB2` 和 `gpio3 RK_PB0`) 在你的硬件设计中是正确的。

#### 硬件排查：验证关键信号

如果软件排查没有发现问题，那就必须通过硬件手段来验证。

1. **测量时钟信号**：
   - 使用**示波器**，找到 `gmac0` 和 `gmac1` 芯片的时钟输入引脚（需要查阅芯片手册）。
   - 上电后，测量这些引脚上的时钟信号。确保它们有稳定的波形，并且频率符合设备树中配置的频率（例如 125MHz）。如果时钟波形不稳定或没有信号，那就找到了问题所在。
2. **测量复位信号**：
   - 用示波器测量 `gmac0` 和 `gmac1` 芯片的复位引脚。
   - 观察系统上电时，这些引脚上的信号。当驱动执行复位操作时，这个引脚应该有一个高低电平的变化。如果信号没有变化，说明复位引脚的硬件连接或设备树配置有问题。

## `cru` (Clock and Reset Unit)

在你的Linux内核源码中，`cru` (Clock and Reset Unit) 的定义通常位于设备树（Device Tree Source, DTS）文件里。对于Rockchip RK3568芯片，你需要查找与该芯片架构相关的`.dtsi`或`.dts`文件。

通常，Rockchip的芯片定义文件路径如下：

1. **打开Linux内核源码目录。**
2. **进入设备树目录：** `arch/arm64/boot/dts/rockchip/`
3. **寻找芯片定义文件：** 在这个目录里，你会找到一个名为 `rk3568.dtsi` 的文件。这个文件是RK3568芯片的通用定义文件，包含了所有通用外设，包括 `cru`。

## GMAC0 的时钟来源 和 reset 信号来源

### 1️⃣ PHY 给 MAC 提供 125MHz 时钟

在 RK3568 + RTL8211F 或类似 RGMII PHY 的板子上：

- **RGMII 接口**有 3 类信号：（在手册`8211fe`中查询出的）

  1. TX/RX 数据线（`TXD[3:0]`, `RXD[3:0]`）
  2. TX/RX 控制信号（`TXCTL`, `RXCTL`）
  3. **TX/RX 时钟**（`TXC`,`RXC`）
     - `TXC`：PHY 输出给 MAC 的 125MHz 时钟（在 `clock_in_out = "input"` 模式下 MAC 接收）
     - `RXC`：有些 PHY 也输出 RX 时钟给 MAC（根据 PHY 手册，RTL8211F TX_CLK 就是 MAC 输入时钟）

所以在`rk3568`板子上：

- PHY 的 **RGMII_TXC**接到 SoC GMAC0 的 **CLK_MAC input** 脚。

- DTS （`myzr-rk3568-ddr4.dtsi`）里：

  ```c
  clock_in_out = "input";   // SoC 接收 PHY 时钟
  
  // 告诉内核这个设备依赖哪些时钟源
  assigned-clocks = <&cru SCLK_GMAC0_RX_TX>, <&cru SCLK_GMAC0>; // MAC 的 TX/RX 时钟 和 MAC内部核心时钟
  
  // 指定 时钟父源
  // 1.K_GMAC0_RX_TX 的父时钟是 SCLK_GMAC0_RGMII_SPEED
  // 2.SCLK_GMAC0 的父时钟是 gmac0_clkin - MAC 核心时钟由外部输入的 PHY 时钟提供
  assigned-clock-parents = <&cru SCLK_GMAC0_RGMII_SPEED>, <&gmac0_clkin>;
  ```

- `gmac0_clkin` 就是 PHY 提供的 125MHz 输入时钟。

这样就解释了日志中：

```bash
[    1.810389] rk_gmac-dwmac fe2a0000.ethernet: clock input from PHY
```

✅  `clock input from PHY` 就是 **PHY RGMII_TXC 直接给 GMAC 时钟输入**。

### 2️⃣ GMAC reset 信号来源

DTS（`myzr-rk3568-ddr4.dtsi`） 里：

```C
// 驱动在初始化 MAC 时会通过这个 GPIO3 拉低/拉高来复位芯片
snps,reset-gpio = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;

// 复位是低电平有效的
snps,reset-active-low;

// 等待 0 µs（几乎无延时）,拉低 GPIO 复位 20 ms,拉高 GPIO，释放复位后等待 100 ms，确保 MAC 内部稳定
snps,reset-delays-us = <0 20000 100000>;
```

- **`snps,reset-gpio`** 指定了一个 GPIO 脚（RK3568 的 GPIO3_PB2），由驱动在 probe 时拉高/低，控制 **PHY 和/或 MAC 复位**。
- **GPIO3_PB2** 接 PHY RESET 脚。
- MAC 内部 reset 由 SoC CRU 自身提供（driver 在 probe 时写寄存器复位 DMA）。

# 8.25

今天要将问题汇报给主板厂家。

## 网络连接错误问题

### 问题描述

RK 3568 在修改了 CPU 电源后，导致报错：DMA 引擎无法复位。

1. 没有修改 DTS 之前：初始的时候，我们调整过贵司开发板的电路，将 GMAC0 对应的 PHY 芯片地址改为了 0。所以正常启动的时候，会出现 PHY 芯片在 MDIO 总线的 1 号地址。虽然 GMAC0 驱动也能初始化网口 eth1，并且通过命令

   ```bash
   ip link set eth1 up/down
   ```

   可以正常启动/停止 eth1 对应的 GMAC0 端口。但是问题就是，无论怎么配置 ip 都无法连接上开发板。

2. 修改 DTS 后：按照贵司的提示，在 DTS 配置中将 GMAC0 对应的 PHY 芯片地址，从 1 搬到了 0。并且使用提供的 SD 卡启动方式，使用修改 DTS 后的镜像启动。此时虽然启动后， PHY 芯片在 MDIO 总线的 0 号地址，但是此时还是无论怎么配置 IP 都无法连接开发板。

3. 修改电路 + DTS 电源供应后：后面根据贵司提示，将 CPU 的供电电压，从 1.8v 改为了 3.3v，并且在 DTS 中，同步配置了 GMAC0 节点的电源供应节点。并且重新烧录启动后校验日志，确认了 DTS 中电源供应配置已经被读取并应用了。

   但是此时的问题就变成了 DMA 引擎无法复位。

   后续也在硬件上验证过 PHY 给 GMAC 提供的时钟为 125 MHz无误，并且供电电压确实改为了 3.3 V。但是还是报这个 DMA 引擎无法复位。

所以想问下老师，这个 CPU 电压修改后，是否影响了 DMA 引擎的初始化呢？

GPT总结：

> 修改 CPU 电源后，系统启动时出现 **“DMA 引擎无法复位”** 的报错描述。
>
> 1. **未修改 DTS 前**
>
>    - 我们最初调整过贵司开发板的电路，将 GMAC0 对应的 PHY 芯片地址改为了 **0**。
>
>    - 启动后，日志中 PHY 芯片会出现在 MDIO 总线的 **1 号地址**。此时 GMAC0 驱动仍能初始化网口 eth1，并且通过
>
>      ```
>      ip link set eth1 up/down
>      ```
>
>      可以正常启动/停止 eth1。
>
>    - 但问题是：无论如何配置 IP，始终无法与开发板建立网络连接。
>
> 2. **修改 DTS 后**
>
>    - 按照贵司建议，我们在 DTS 中将 GMAC0 的 PHY 地址从 **1 改为 0**。
>    - 使用修改后的 DTS 镜像启动后，PHY 芯片确实出现在 MDIO 总线的 **0 号地址**。
>    - 但问题依旧：依然无法通过 IP 配置连通开发板。
>
> 3. **修改电路 + DTS 电源供应后**
>
>    - 后续我们根据建议，将 **CPU 的供电电压从 1.8 V 改为 3.3 V**，并在 DTS 中同步配置了 GMAC0 节点的电源供应。
>    - 烧录启动后，通过日志确认 DTS 的电源配置已生效。
>    - 但此时问题变成了：系统报错 **“DMA 引擎无法复位”**。
>
>    我们进一步验证：
>
>    - 硬件上，PHY 向 GMAC 提供的时钟确认为 **125 MHz**；
>    - CPU 电源电压确实改为 **3.3 V**；
>    - 但依然出现 DMA 引擎无法复位的错误。
>
> ------
>
> 基于以上情况，我们有一个疑问：
>   **CPU 电源电压从 1.8 V 调整为 3.3 V 后，是否会影响 GMAC/DMA 引擎的初始化与复位？**
>  如果会，能否请老师您能指点我们进一步需要检查的环节（例如时钟源、电源域、复位控制、DTS 中的相关依赖等）？

# 8.26

今天先放下进度，研究下 MAC 芯片和 PHY 芯片是如何交互的。

## PHY 寄存器读写调试

在阅读手册《Rockchip_Developer_Guide_Linux_GMAC_CN.pdf》的第三节 “PHY 寄存器读写调试”时候的记录。

```bash
/sys/bus/mdio_bus/devices/stmmac-0:00
```

这个目录下：

```bash
root@RK356X:/sys/bus/mdio_bus/devices/stmmac-0:00# ls -al
total 0
drwxr-xr-x 3 root root    0 Jan  1 00:00 .
drwxr-xr-x 4 root root    0 Jan  1 00:00 ..
lrwxrwxrwx 1 root root    0 Jan  1 00:50 attached_dev -> ../../../net/eth0
lrwxrwxrwx 1 root root    0 Jan  1 00:50 driver -> '../../../../../../bus/mdio_bus/drivers/Generic PHY'
lrwxrwxrwx 1 root root    0 Jan  1 00:50 of_node -> ../../../../../../firmware/devicetree/base/ethernet@fe2a0000/mdio/phy@0
-r--r--r-- 1 root root 4096 Jan  1 00:50 phy_has_fixups
-r--r--r-- 1 root root 4096 Jan  1 00:50 phy_id
-r--r--r-- 1 root root 4096 Jan  1 00:50 phy_interface
-rw-r--r-- 1 root root 4096 Jan  1 00:50 phy_registers
drwxr-xr-x 2 root root    0 Jan  1 00:50 power
lrwxrwxrwx 1 root root    0 Jan  1 00:50 subsystem -> ../../../../../../bus/mdio_bus
-rw-r--r-- 1 root root 4096 Jan  1 00:00 uevent
```

那么这个目录作用是什么？下面的功能是什么？

### 1.sysfs

`/sys` 是 Linux 内核提供的 **sysfs 文件系统**。

它不是普通的数据文件，而是内核把硬件和驱动的信息映射出来的一种“虚拟文件系统”。

### 2./sys/bus

- 在这个目录下面，按照“总线”来组织设备
- `/sys/bus/mdio_bus` = 这是 **MDIO 总线**在 sysfs 下的表示

### 3.MDIO 总线

- MDIO 总线用来连接 MAC 和 PHY 芯片。其作用是方便 MAC 读取或配置 PHY 芯片。

### 4.`/sys/bus/mdio_bus/devices`

- 这就是内核发现的所有挂在`MDIO`总线上的设备。（PHY 芯片）
- 每个 PHY 都会以一种类似 `controller:phy_addr` 的形式出现在这里。

### 5.`stmmac-0:00` 的含义

- `stmmac` = **驱动名字**

- `-0` = **控制器编号**

  - 如果芯片上有多个 GMAC 控制器（比如 GMAC0、GMAC1），这里的 `0` 表示这是第 0 个 MAC 控制器。

- `:00` = **PHY 地址**

- 每个 PHY 芯片在 MDIO 总线上都有一个编号（0~31），就像 I²C 设备有地址一样。
   这里的 `00` 表示 PHY 地址是 `0`。

  组合起来，`stmmac-0:00` 就是：

  > **第 0 个 stmmac 控制器，通过 MDIO 总线发现的，地址为 0 的 PHY 芯片**。

### 6.总结

`/sys/bus/mdio_bus/devices/stmmac-0:00` 其实就是 **Linux 内核在 sysfs 里对某个以太网 PHY 芯片的抽象节点**，让你可以通过文件系统的方式去查看/配置它。

## Linux 内核初始化 **MAC + PHY 的流程**

### 1️⃣ MAC 驱动 probe 阶段

- 以 RK356X 为例，GMAC 控制器对应的驱动是 `stmmac`。

- 内核启动时，会扫描设备树（Device Tree）里的 GMAC 节点，例如：

  ```C
  &gmac0 {
      status = "okay";
      phy-handle = <&phy0>;
  };
  ```

- 驱动的 `probe` 函数会被调用

  - 申请和映射 MAC 的寄存器。
  - 初始化 DMA、描述符等。
  - 通过 `of_get_phy` 或 `mdio` API 找到挂在这个 MAC 上的 PHY。

### 2️⃣ MDIO 总线扫描 PHY

- MAC 驱动初始化完成后，会调用 `mdio_scan`：
  - 内核扫描 PHY 地址（通常是 0~31）上的所有设备。
  - 对每个找到的 PHY，创建对应的 `mdio_device` 结构。
  - 每个 `mdio_device` 在 sysfs 里就会出现一个目录 `/sys/bus/mdio_bus/devices/<bus>:<addr>`，比如 `stmmac-0:00`：
    - `stmmac-0` → 第 0 个 stmmac 控制器（MAC0）
    - `:00` → PHY 地址 0

### 3️⃣ PHY 驱动 probe 阶段

- 当 MDIO 总线发现 PHY 后，会根据 `compatible` 匹配 PHY 驱动。
- PHY 驱动的 `probe` 会被调用，完成：
  - PHY 寄存器初始化（如 Auto-Negotiation、速度/双工配置）。
  - 将 PHY 状态注册到 `net_device` 的 `phydev` 中。
  - sysfs 下的 `stmmac-0:00` 目录也会被创建，用于用户空间访问 PHY。

**Linux 内核在 MAC 初始化并扫描 PHY 的过程中，PHY 被识别并注册到 MDIO 总线后，sysfs 节点就出现了**。

# 8.27

## 将windows压缩文件解压到 linux上

具体步骤可以AI，现在提供思路：

1. **在 Windows 上**，将包含压缩包的目录设置为共享。

2. **在 Linux 上**，使用 `mount` 命令将该 Windows 共享目录挂载到本地。

3. **在 Linux 上**，进入挂载点，直接使用 `tar` 或 `unzip` 命令解压压缩包，解压后的文件将直接存放在 Linux 服务器上。

## RK3568 的 SPI 通信

要让 **RK3568** 通过 **SPI** 总线与 **AD9833** 通信，你需要从硬件到软件，一步步进行配置和调试。这通常涉及到设备树（Device Tree）的配置、内核驱动的加载以及用户层程序的编写。

下面是建议的排查和开发步骤：

### 1. 检查硬件连接

------

首先，确保 **RK3568** 和 **AD9833** 之间的 **SPI** 硬件连接是正确的。对照 **AD9833** 的数据手册，核对以下引脚连接：

- **SCLK (Serial Clock):** SPI 时钟线
- **SDI (Serial Data In):** SPI 主机输出，从机输入的数据线 (MOSI)
- **FSYNC/CS (Frame Sync/Chip Select):** 片选信号
- **GND (Ground):** 接地
- **VDD (Power Supply):** 电源

同时，也要确保 **AD9833** 的电源和接地连接是稳定的。

### 2. 配置设备树（Device Tree）

------

**Linux** 内核通过 **设备树（Device Tree）** 文件来识别和配置硬件。你需要修改 **RK3568** 对应的 `.dts` 或 `.dtsi` 文件，来告诉内核你连接了一个 **SPI** 设备。

- **找到 SPI 总线节点：** 在设备树文件中，找到 **RK3568** 上用于连接 **AD9833** 的 SPI 控制器节点。通常它会有一个兼容字符串，比如 `"rockchip,rk3568-spi"`。
- **添加 SPI 从设备节点：** 在该 SPI 控制器节点下，添加一个子节点来描述 **AD9833**。你需要定义以下几个关键属性：
  - `compatible`: 描述设备的兼容性，比如 `ad9833`。
  - `reg`: SPI 片选（Chip Select）号，通常是 `0` 或 `1`。
  - `spi-max-frequency`: SPI 总线通信的最大频率，根据 **AD9833** 的数据手册来设置。
  - `spi-mode`: SPI 模式，**AD9833** 支持 **SPI Mode 2** 或 **Mode 3**。

例如，你的设备树配置可能看起来像这样：

DTS

```C
&spi1 {
    status = "okay";

    ad9833@0 {
        compatible = "ad9833";
        reg = <0>;
        spi-max-frequency = <10000000>;
        // 可根据需要添加其他属性，如中断等
    };
};
```

------

### 3. 内核驱动和设备节点

------

完成设备树配置并重新编译内核后，你需要验证 **Linux** 系统是否正确识别了 **AD9833**。

- **检查设备节点：** 启动系统后，在 `/dev` 目录下查看是否有 `spidevX.X` 这样的设备节点，其中第一个 `X` 是 **SPI** 控制器编号，第二个 `X` 是片选号。例如，如果是在 **spi1** 的片选 **0** 上，那么设备节点应该是 `/dev/spidev1.0`。
- **查看内核日志：** 运行 `dmesg | grep spi` 命令，可以查看内核启动日志。如果设备树配置正确，你应该能看到类似 "spi_master: spi1 initialized" 或者与 **AD9833** 相关的日志信息。

如果没有生成 `/dev/spidevX.X`，可能是设备树配置有误，或者 **spidev** 驱动没有被编译进内核。你需要检查内核配置，确保 **`CONFIG_SPI_SPIDEV`** 选项已启用。

### 4. 用户层通信测试

------

有了 `/dev/spidevX.X` 这个设备节点后，你就可以通过用户层程序来访问 **AD9833** 了。最简单的方法是使用 **C/C++** 编程，调用 **Linux** 的 **SPI** API。

- **包含头文件：** 在你的程序中，需要包含 `<fcntl.h>`, `<sys/ioctl.h>`, `<linux/spi/spidev.h>` 等头文件。
- **打开设备节点：** 使用 `open("/dev/spidev1.0", O_RDWR);` 打开设备文件。
- **配置 SPI 模式和频率：** 使用 `ioctl` 系统调用来设置 **SPI** 通信的模式、每个字的位数以及最大频率。这非常重要，因为错误的配置会导致通信失败。
  - `ioctl(fd, SPI_IOC_WR_MODE, &mode);`
  - `ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits);`
  - `ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);`
- **编写 SPI 读写函数：** 使用 `ioctl` 的 `SPI_IOC_MESSAGE` 命令，来发送和接收数据。**AD9833** 的通信协议很简单，主要是发送控制字。你需要按照 **AD9833** 的数据手册，构建相应的 **16** 位控制字，并通过 **SPI** 发送出去。

**一个简单的测试思路：**

1. 发送 **RESET** 控制字 (`0x0100`)。
2. 发送频率寄存器 (`FREQ0`) 的高 **14** 位 (`0x4xxx`)。
3. 发送频率寄存器 (`FREQ0`) 的低 **14** 位 (`0x4xxx`)。
4. 发送控制寄存器 (`0x2xxx`)，使能 **DDS** 输出。

如果通信成功，你可以用示波器去观察 **AD9833** 的输出引脚，看是否有波形输出。

### 总结

------

整个排查流程可以概括为：**硬件连接** -> **设备树配置** -> **内核驱动检查** -> **用户层程序测试**。如果某一步骤失败，就停下来，用对应的工具（比如示波器、`dmesg`）去排查。

要实现最终目标，你可能需要编写一个简单的应用程序，根据你的需求，动态配置 **AD9833** 的频率、相位和波形。

# 8.29

## SPI 通信

现在配置完毕 DTS 后，能够在启动后找到`spidev0.0`节点。设备树配置和内核驱动都已成功加载，下一步最关键的就是进行实际的通信测试。

要想通信测试，就要写一个能够运行在 RK3568 上面的测试程序，就需要在 PC 上配置对应的交叉编译环境。

现在我们看下编译`kernel`的时候，输出结果：

```bash
crx@crx-PC:~/work/rk3568SDK$ ./build.sh kernel
processing option: kernel
============Start building kernel============
TARGET_ARCH          =arm64
TARGET_KERNEL_CONFIG =myzr_rk_defconfig
TARGET_KERNEL_DTS    =myzr-rk3568
TARGET_KERNEL_CONFIG_FRAGMENT =
==========================================
CROSS_COMPILE         =/home/crx/work/rk3568SDK/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-
TOOLCHAIN_PATH        =/home/crx/work/rk3568SDK/prebuilts/gcc/linux-x86/aarch64/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin
```

## buildroot

因为想在开发板的上加入 ssh 的功能，所以在 RK3568 的开发环境中，进入到 buildroot 中，启用了关于  OPENSSH 的相关套件。并且在生成的`.config`中，对应的配置均生效了：

```ini
BR2_PACKAGE_OPENSSH=y
BR2_PACKAGE_OPENSSH_CLIENT=y
BR2_PACKAGE_OPENSSH_SERVER=y
BR2_PACKAGE_OPENSSH_ENABLE_ROOT_LOGIN=y
BR2_PACKAGE_OPENSSH_KEY_UTILS=y
```

此时执行`./build.sh`，会输出关于 buildroot 的编译流程：

```bash
==========Start building buildroot==========
TARGET_BUILDROOT_CONFIG=rockchip_rk3568
=========================================
Top of tree: /home/crx/work/rk3568SDK
===========================================

#TARGET_BOARD=rk3568
#OUTPUT_DIR=output/rockchip_rk3568
#CONFIG=rockchip_rk3568_defconfig

===========================================
make: Entering directory '/home/crx/work/rk3568SDK/buildroot'
  GEN     /home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/Makefile
/home/crx/work/rk3568SDK/buildroot/build/defconfig_hook.py -m /home/crx/work/rk3568SDK/buildroot/configs/rockchip_rk3568_defconfig /home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/.rockchipconfig
BR2_DEFCONFIG='' KCONFIG_AUTOCONFIG=/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/build/buildroot-config/auto.conf KCONFIG_AUTOHEADER=/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/build/buildroot-config/autoconf.h KCONFIG_TRISTATE=/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/build/buildroot-config/tristate.config BR2_CONFIG=/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/.config HOST_GCC_VERSION="9" BASE_DIR=/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568 SKIP_LEGACY= BR2_DEFCONFIG=/home/crx/work/rk3568SDK/buildroot/configs/rockchip_rk3568_defconfig /home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/build/buildroot-config/conf --defconfig=/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/.rockchipconfig Config.in
#
# configuration written to /home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/.config
#
make: Leaving directory '/home/crx/work/rk3568SDK/buildroot'
2025-08-29T16:43:35 >>>   Finalizing target directory
2025-08-29T16:43:38 >>>   Sanitizing RPATH in target tree
2025-08-29T16:43:47 >>>   Copying overlay board/rockchip/common/base
2025-08-29T16:43:47 >>>   Copying overlay board/rockchip/common/powermanager
2025-08-29T16:43:47 >>>   Copying overlay board/rockchip/rk356x/fs-overlay/
2025-08-29T16:43:47 >>>   Copying overlay board/rockchip/common/wifi
2025-08-29T16:43:47 >>>   Executing post-build script ../device/rockchip/common/post-build.sh
2025-08-29T16:43:48 >>>   Generating root filesystem image rootfs.cpio
2025-08-29T16:44:20 >>>   Generating root filesystem image rootfs.ext2
2025-08-29T16:44:23 >>>   Generating root filesystem image rootfs.squashfs
2025-08-29T16:44:27 >>>   Generating root filesystem image rootfs.tar
Done in 58s
log saved on /home/crx/work/rk3568SDK/br.log. pack buildroot image at: /home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/images/rootfs.ext4
you take 0:58.50 to build builroot
Running build_buildroot succeeded.
Running build_rootfs succeeded.
```

此时将生成的目录文件，打包到开发板后，发现并不生效。

### 1.确认 `sshd` 是否编译进去了

在`buildroot/`目录下，进入 `output/rockchip_rk3568/target/usr/sbin/`，看看有没有 `sshd`：

```bash
crx@crxVMstation:~/work/rk3568SDK/buildroot$ ls output/rockchip_rk3568/target/usr/sbin/sshd
ls: cannot access 'output/rockchip_rk3568/target/usr/sbin/sshd': No such file or directory
```

可以看出并没有`sshd`。

根据资料查询，Buildroot 的输出目录是：

```bash
output/rockchip_rk3568/target/
```

这里就是未来 rootfs 的根目录（打包前的 staging area）。

# 8.30

## buildroot编译流程

如果我在 buildroot 目录中，执行

```bash
make arch=arm64 menuconfig
```

配置好了 openssh 后并保存，并且在 buildroot 的根目录下，检查`.config`可以看到相关 OPENSSH 的配置已经生效。

但是在执行 rk3568 的全流程编译脚本`build.sh`后，在开发板中并没有找到 ssh 配置。

为了检查是否 ssh 配置确实生效了，我们先去了`output`目录下面，找到对应 3568 芯片目录的`target`目录，搜索发现确实没有 ssh 的踪影。说明 ssh 并没有被编译到 buildroot 中。

此时我们就要看下，在 rk3568 的编译脚本中，如何才能实现将 buildroot 生成的配置启用生效。

### 检查编译输出

我们就先从编译输出入手。当我们执行`./build.sh`的时候，与 buildroot 相关的输出为：

```bash
==========Start building buildroot==========
TARGET_BUILDROOT_CONFIG=rockchip_rk3568
=========================================
Top of tree: /home/crx/work/rk3568SDK
===========================================

#TARGET_BOARD=rk3568
#OUTPUT_DIR=output/rockchip_rk3568
#CONFIG=rockchip_rk3568_defconfig

===========================================
make: Entering directory '/home/crx/work/rk3568SDK/buildroot'
  GEN     /home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/Makefile
/home/crx/work/rk3568SDK/buildroot/build/defconfig_hook.py -m /home/crx/work/rk3568SDK/buildroot/configs/rockchip_rk3568_defconfig /home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/.rockchipconfig
BR2_DEFCONFIG='' KCONFIG_AUTOCONFIG=/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/build/buildroot-config/auto.conf KCONFIG_AUTOHEADER=/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/build/buildroot-config/autoconf.h KCONFIG_TRISTATE=/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/build/buildroot-config/tristate.config BR2_CONFIG=/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/.config HOST_GCC_VERSION="9" BASE_DIR=/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568 SKIP_LEGACY= BR2_DEFCONFIG=/home/crx/work/rk3568SDK/buildroot/configs/rockchip_rk3568_defconfig /home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/build/buildroot-config/conf --defconfig=/home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/.rockchipconfig Config.in
#
# configuration written to /home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/.config
#
make: Leaving directory '/home/crx/work/rk3568SDK/buildroot'
2025-08-29T16:43:35 >>>   Finalizing target directory
2025-08-29T16:43:38 >>>   Sanitizing RPATH in target tree
2025-08-29T16:43:47 >>>   Copying overlay board/rockchip/common/base
2025-08-29T16:43:47 >>>   Copying overlay board/rockchip/common/powermanager
2025-08-29T16:43:47 >>>   Copying overlay board/rockchip/rk356x/fs-overlay/
2025-08-29T16:43:47 >>>   Copying overlay board/rockchip/common/wifi
2025-08-29T16:43:47 >>>   Executing post-build script ../device/rockchip/common/post-build.sh
2025-08-29T16:43:48 >>>   Generating root filesystem image rootfs.cpio
2025-08-29T16:44:20 >>>   Generating root filesystem image rootfs.ext2
2025-08-29T16:44:23 >>>   Generating root filesystem image rootfs.squashfs
2025-08-29T16:44:27 >>>   Generating root filesystem image rootfs.tar
Done in 58s
log saved on /home/crx/work/rk3568SDK/br.log. pack buildroot image at: /home/crx/work/rk3568SDK/buildroot/output/rockchip_rk3568/images/rootfs.ext4
you take 0:58.50 to build builroot
Running build_buildroot succeeded.
Running build_rootfs succeeded.
```

我们打开`build.sh`脚本，查看对应的编译脚本：

```sh
function build_buildroot(){
        check_config RK_CFG_BUILDROOT || return 0

        echo "==========Start building buildroot=========="
        echo "TARGET_BUILDROOT_CONFIG=$RK_CFG_BUILDROOT"
        echo "========================================="

        /usr/bin/time -f "you take %E to build builroot" \
                $COMMON_DIR/mk-buildroot.sh $BOARD_CONFIG

        finish_build
}
```

### 核心编译过程

脚本调用了核心命令 `$COMMON_DIR/mk-buildroot.sh $BOARD_CONFIG`。这个命令触发了 Buildroot 的 `make` 流程。

- **配置生成**：
  - `make` 命令首先使用 `defconfig_hook.py` 脚本，基于 `rockchip_rk3568_defconfig` 文件生成最终的 `.config` 文件。这个 `.config` 文件包含了我们在 `menuconfig` 中选择的所有选项，包括 OpenSSH 的配置。
- **软件包编译**：在您提供的日志中没有显示这个过程，但这是 Buildroot 最耗时的部分。它会自动下载、解压、配置并编译所有选中的软件包及其依赖库，比如 OpenSSH、OpenSSL 等，并将它们安装到 Buildroot 的输出目录中。



推测出，`rockchip_rk3568_defconfig`应该才是最终配置。修改后，果然编译了`OPENSSH`。但是烧录进开发板后，启动发现并没有成功。

