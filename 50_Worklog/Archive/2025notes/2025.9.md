# 9.1

今天主要解决的任务有：

- 服务器开发环境配置
- 研究如何让 buildroot 配置生效

## Linux 虚拟机 **永久挂载 Windows 的共享目录**

### 一、准备工作

1. 确认 Linux 已安装支持：

   ```bash
   sudo apt-get update
   sudo apt-get install cifs-utils
   ```

2. 确认目录存在：

   ```bash
   sudo mkdir -p /mnt/winshare
   ```

### 二、创建凭据文件

1. 新建一个凭据文件：

   ```bash
   sudo vim /etc/samba/credentials
   ```

2. 内容写入( Windows 密码)：

   ```bash
   username=Administrator
   password=123456
   ```

3. 修改权限，避免别人能读到密码

   ```bash
   sudo chmod 600 /etc/samba/credentials
   ```

### 三、修改 `/etc/fstab`

在 `/etc/fstab` 最后一行加上：

```bash
 //192.168.1.9/3.1-源码  /mnt/winshare  cifs  credentials=/etc/samba/credentials,iocharset=utf8,file_mode=0777,dir_mode=0777  0  0
```

- `192.168.1.9/3.1-源码`：是 Windows 共享目录的地址
- `/mnt/winshare`：linux上的目标挂载点

### 四、测试挂载

1. 让 fstab 生效：

   ```bash
   sudo mount -a
   ```

2. 查看是否挂载成功：

   ```bash
   df -h | grep winshare
   ```

### 五、下次开机自动挂载

现在就已经是永久挂载了，重启虚拟机后 `/mnt/winshare` 会自动挂载 Windows 的共享目录。

## AD9833时序

好的，我帮你整理一个 **完整、准确的 AD9833 调用时序说明**，结合手册和 Linux SPI 驱动的实现：

------

1️⃣ 引脚说明

| 引脚      | 功能                                                         |
| --------- | ------------------------------------------------------------ |
| **FSYNC** | 片选（CS），低电平有效。每次写入 16bit 命令/数据时，需要拉低后再拉高。 |
| **SCLK**  | SPI 时钟，下降沿采样数据（手册要求）。                       |
| **SDATA** | 数据输入（16bit），MSB 先发。                                |

------

### 2️⃣ 数据格式

- **每次 SPI 传输 16 位**（MSB first）
- 控制字 / 频率寄存器 / 相位寄存器都是 16bit，28bit 频率字需要拆成两次写入：
  1. 低 14 位写入 LSB（0x4000 | (freq & 0x3FFF)）
  2. 高 14 位写入 MSB（0x4000 | ((freq >> 14) & 0x3FFF)）
- 控制寄存器常用位：
  - **RESET** = 1 → 复位，输出空（中间电平）
  - **B28** = 1 → 允许一次写入完整 28bit 频率字
  - **MODE / OPBITEN** → 决定输出正弦/三角/方波

------

### 3️⃣ 写入时序

以写 **16bit 控制字** 为例：

```
FSYNC  ───┐             ┌───
          │             │
          └─────────────┘
SCLK   ──‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
          ↑↓ ↑↓ ↑↓ … 16 次
SDATA  → D15 D14 … D0
```

顺序说明：

1. **FSYNC 拉低** → AD9833 开始接收数据
2. **SCLK 上升沿/下降沿**：
   - AD9833 在 **SCLK 下降沿** 采样 SDATA
   - 数据 MSB 先发
3. **传完 16bit** → **FSYNC 拉高**，AD9833 锁存这 16bit 命令/数据

> ⚠️ 注意：每 16bit 数据都要单独 FSYNC 拉低/拉高。

------

### 4️⃣ 初始化流程（典型示例）

假设要输出 2kHz 正弦波：

1. **复位**：写控制寄存器 RESET=1

   ```text
   FSYNC↓ → 0x0100 → FSYNC↑
   ```

2. **写入频率字 FREQ0**：

   ```text
   FSYNC↓ → 0x4000 | (freq_lsb) → FSYNC↑
   FSYNC↓ → 0x4000 | (freq_msb) → FSYNC↑
   ```

3. **选择频率寄存器 / 设置波形**：

   ```text
   FSYNC↓ → 0x2000 → FSYNC↑
   ```

4. **退出复位（开始输出）**：

   ```text
   FSYNC↓ → 0x2000 （RESET=0）→ FSYNC↑
   ```

------

### 5️⃣ Linux SPI 配置

- **模式**：`SPI_MODE_1` → CPOL=0, CPHA=1（下降沿采样，空闲低电平）
- **数据宽度**：16bit
- **速率**：1MHz~5MHz 通常足够

```c
mode = SPI_MODE_1;
bits = 16;
speed = 1000000;
ioctl(fd, SPI_IOC_WR_MODE, &mode);
ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits);
ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);
```

------

✅ 总结

- **FSYNC** 控制每条命令的开始/结束
- **SCLK 下降沿** 采样数据
- **MSB 先发**，每 16bit 独立写入
- **写顺序**：复位 → 写频率 → 设置波形 → 退出复位

------



# 9.4

今天要解决的是，看 AD9833 手册：

- [ ] VOUT 能否输出固定电平

## NCO

NCO 是 AD9833 的核心部件，是将输入的频率字，合成为相位值。

在理解这个器件的内部原理之前，需要理解：

1. 信号的相位、频率是什么
2. 信号的初始相位是什么意思
3. 相位累加器：数字电路获取正弦函数在单位时间内相位变化的方法（相位随着时间线性变化，二进制累加）
4. 相位 → 幅度是如何转换的？

# 9.5

今天就可以整理一篇文章，就是根据 Chatgpt 生成的关于 AD9833 的原理理解`为什么先变成相位，再变成正弦`。

## MCLK vs SCLK

您提出的这个问题非常好，它触及了 AD9833 芯片的两个独立但同样重要的时钟概念：`MCLK` 和 `SCLK`。

您提到的 “这是什么时钟” 里的“这个”指的是上一个回答中提到的 `spi-cpha` 和 `spi-cpol` 所描述的时钟，**这个时钟是 SCLK**。

这两个时钟的作用是完全不同的：

- **SCLK (Serial Clock)**：这是 SPI 通信协议的**串行时钟**。它是由主设备（例如您的开发板）生成的，用于同步主设备和从设备（AD9833）之间的数据传输。SCLK 信号的边沿决定了数据何时被发送和采样。`spi-cpha` 和 `spi-cpol` 这两个参数正是用来配置 SCLK 的工作模式。
- **MCLK (Master Clock)**：这是 AD9833 芯片的**主时钟**或**参考时钟**。它通常是由外部晶振或一个独立的时钟源提供给 AD9833 的。MCLK 的频率决定了芯片内部的**相位累加器（NCO）**的更新速度，从而直接影响了最终输出波形的频率。您之前提到的频率公式 `fOUT = (FREQREG × fMCLK) / 2^28` 中的 `fMCLK` 就是这个时钟。

**简而言之：**

- **SCLK** 是用来**配置**芯片的，它控制着您通过 SPI 向 AD9833 写入指令和数据的过程。
- **MCLK** 是用来**生成**波形的，它决定了 AD9833 输出波形的频率。

这两个时钟是相互独立的。SCLK 的频率通常可以远高于 MCLK，以实现快速配置，而 MCLK 的频率则决定了 AD9833 的核心性能。

## SPI Mode

`SPI Mode`（SPI 模式）是 SPI（Serial Peripheral Interface，串行外围接口）通信协议中的一个概念，它定义了**主设备（Master）**和**从设备（Slave）**之间如何同步时钟和数据。

SPI 协议没有一个统一的通信模式，而是有四种不同的模式，由两个关键参数决定：

1. **时钟极性（CPOL）**：它决定了时钟在**空闲**时的电平。
   - `CPOL = 0`：空闲时钟为低电平（L）。
   - `CPOL = 1`：空闲时钟为高电平（H）。
2. **时钟相位（CPHA）**：它决定了数据在时钟周期的**哪个边沿**被采样。
   - `CPHA = 0`：在时钟的**第一个边沿**采样（CPOL=0 时是上升沿，CPOL=1 时是下降沿）。
   - `CPHA = 1`：在时钟的**第二个边沿**采样（CPOL=0 时是下降沿，CPOL=1 时是上升沿）。

这两种参数的组合产生了四种 SPI 模式，通常用 `SPI Mode X` 来表示，其中 X 可以是 0、1、2 或 3。

| **模式** | **CPOL** | **CPHA** | **描述**                                           |
| -------- | -------- | -------- | -------------------------------------------------- |
| Mode 0   | 0        | 0        | 空闲时钟为低电平，数据在第一个边沿（上升沿）采样。 |
| Mode 1   | 0        | 1        | 空闲时钟为低电平，数据在第二个边沿（下降沿）采样。 |
| Mode 2   | 1        | 0        | 空闲时钟为高电平，数据在第一个边沿（下降沿）采样。 |
| Mode 3   | 1        | 1        | 空闲时钟为高电平，数据在第二个边沿（上升沿）采样。 |

**为什么 SPI 模式很重要？**

因为主设备和从设备**必须使用相同的 SPI 模式**才能成功通信。如果模式不匹配，主设备将在错误的时机采样数据，导致接收到的数据完全错误。

## AD9833 配置 DTS 树

浅显地阅读完了一遍《AD9833手册》后，感觉有必要再次按照手册配置下对应spi总线 0 的 AD9833 设备的 DTS 数据。

对于 AD9833，我们需要配置以下几个核心属性：

1. **SPI 片选 (`reg`)**：这个属性指定了 AD9833 连接到 SPI 总线上的哪个片选（CS）引脚。如果连接到 `spi0` 总线，并且是第一个设备，通常其值为 `<0>`。
2. **时钟频率 (`spi-max-frequency`)**：定义了 SPI 总线与该设备通信的最高时钟频率。根据数据手册，AD9833 支持高达 40 MHz 的 SPI 时钟，但实际值应根据我们硬件设计来设定。这里我们是 25 MHz
3. **SPI 模式 (`spi-cpol`, `spi-cpha`)**：这决定了 SPI 通信的时钟极性（CPOL）和时钟相位（CPHA）。

# 9.7

今天任务就是理解代码是如何实现生成正弦波的。

## AD9833实现波形输出

现在AD9833是存在于 spi 控制器 0 ，且其片选信号为 0 的位置处。现在想让其生成一个 1KHz 的正弦波，应该关注手册的哪些数据？

# 9.8

当前放在眼前的任务是：

- [ ] AD9834驱动：已经有了AD9833底子，应该没什么问题。预估工时 3 天。
- [ ] CSAC驱动：需要重新理解关于 CSAC 关于驯服相关的章节。预估工时 3 天。
- [ ] ServoV6的实现。（Qtquick的学习每天能否进步一点点）

现在 ServoV6 存在的问题：

1. cmake能力较差。像是现在 test 的项目构建就很有问题，如何才能改进？使之更方便的使用 QtTest
2. 项目架构层级再次分析

## ServoV6思考

我想要的 ServoV6 是怎样的。

首先是Test架构混乱：

现在的 `tests/` 目录和 `CMakeLists.txt` 确实有几个痛点：

1. **测试只能一次运行一个** —— 因为 `test_main.cpp` 用了 `#define RUN_XXX` 方式硬切换。
2. **新增测试类很麻烦** —— 每次要改 `TEST_SOURCES` 和 `main()`。
3. **缺少 Mock 支持** —— P100S 电机测试只能跑在真机上。

## Test架构调整

现在的 `tests/` 目录和 `CMakeLists.txt` 确实有几个痛点：

1. **测试只能一次运行一个** —— 因为 `test_main.cpp` 用了 `#define RUN_XXX` 方式硬切换。
2. **新增测试类很麻烦** —— 每次要改 `TEST_SOURCES` 和 `main()`。
3. **缺少 Mock 支持** —— P100S 电机测试只能跑在真机上。

更合理的方案，核心思路是：

- **每个测试类一个独立的可执行文件**，这样 `ctest` 可以批量运行。
- **引入 target/test 组别**，方便分类（unit / integration / hardware）。
- **Mock/实机模式可切换**，通过 `-DSERVO_TEST_MODE=mock` 或 `real` 来控制。

## 访问者模式

当前项目中用到了访问者模式。但是具体是什么，我并不是很理解，所以借助[秒懂设计模式之访问者模式（Visitor Pattern）](https://zhuanlan.zhihu.com/p/380161731)学习下。

访问者模式感觉就是固定好成员变量元素后，灵活进行处理。访问者模式的原理分析

在这个具体的电机控制系统中，我们可以将访问者模式的关键角色进行对应：

- **被访问者（Visitee）**：这指的是你的**命令结构体（`MovementCommand.h`）**，也就是 `SetPositionSpeed`、`RelativeMove`、`GoHome` 等。这些是需要被处理的**数据对象**。
- **访问者（Visitor）**：这指的是 `CommandVisitor` 接口和它的具体实现 `MotorCommandExecutor`。**访问者定义了对每一种命令类型所执行的**操作**。
- **对象结构**：这指的是 `std::variant<...>`，它将所有命令类型封装成一个统一的 `Command` 类型。这是访问者模式中用于遍历所有被访问者的数据容器。

整个模式的工作流程可以概括为：

1. 一个 `Command` 对象，它实际上是 `std::variant`，持有某个具体的命令（比如 `SetPositionSpeed`）。
2. 当你想要执行这个命令时，你调用 `std::visit` 函数，并传入 `MotorCommandExecutor` 的实例和 `Command` 对象。
3. `std::visit` 会根据 `Command` 中实际持有的类型（`SetPositionSpeed`），自动调用 `MotorCommandExecutor` 中对应的 `visit(ILinearServoAdapter* adapter, const SetPositionSpeed& cmd)` 方法。
4. 在 `visit` 方法的实现中，你可以通过传入的 `adapter` 参数来调用真正的业务逻辑，比如 `adapter->setPositionSpeed(cmd.mm_per_sec)`。

这里还有一个巧妙的设计：`CommandVisitor` 的 `visit` 方法重载不仅依赖于命令类型，还依赖于**适配器类型**（`ILinearServoAdapter`、`IRotaryServoAdapter` 或 `IServoAdapter`）。这正是**双重分派（Double Dispatch）\**的应用，允许根据\**命令类型**和**适配器类型**这两个运行时决定的类型来选择正确的函数重载，实现了更细粒度的控制。

# 9.8

择日不如撞日。今天调整 Test 的目录结构。

## Tests调整

好吧，上午工作地点搬动到外面了，一上午都在搬家中度过。

## AD9834的思考

现在要做AD9834的相关学习。学习的目的就是掌握：如何让AD9834输出一个任意的波形数据。对于实现这个终极目标，首先要通读整篇文章。预计时间 3 h，现在从14：36开始。

### 原理

AD9834通过相位累加器不断累加相位步进，随后通过查表输出正弦。用时37分29秒。学到了：

- 数学上：

  $f = \frac{1}{2\pi} \cdot \frac{d\varphi}{dt}$

  频率就是相位随时间增长的速度。 所以，**如果我们能控制相位累加的速度，就等于控制了输出信号的频率**。

- 相位累加器：每个时钟周期（MCLK输入），就会加入 FTW 进行累计相位步进

- 查表：将相位信息转换为幅值信息

- DAC：将幅值信息转换为正弦波

从15：43开始，理解如何才能让AD9834输出一个频率为 1KHz 的正弦波。

### 输出方波

相位累加器输出的是 28 位的二进制数，表示角度。

如果取它的最高有效位（MSB）：

- 当相位在 $0→π$（0°~180°），MSB = 0
- 当相位在 $π→2π$（180°~360°），MSB = 1

于是，MSB 随着相位周期变化就形成了一个 **方波**。这就是 NCO 的 MSB 方波。

### AD9834控制寄存器

首先就是理解 9834 的控制寄存器各个位的功能。

- DB13：名称为B28。

  - B28 = 1：向某个频率寄存器写入两次数据。第一次写 14 个 LSB，第二次写 14 个 MSB。（但是不推荐，容易产生毛刺）
  - B28 = 0：向某个频率寄存器写入 14 个 MSB/LSB 数据。具体写入哪个，需要 DB12 辅助。

- DB12：名称为 HLB。（配合 DB13 = 0 使用，当 DB13 = 1时，此控制位会被忽略）

  - HLB = 1：写入频率寄存器的 14 个 MSB
  - HLB = 0：写入频率寄存器的 14 个 LSB

- DB11：名称 FSEL

  - FSEL = 1：选择 FREQ1 作为相位累加器输入
  - FSEL = 0：选择 FREQ0 作为相位累加器输入

- DB10：名称 PSEL。跟 DB11 类似，决定了 PHASE0/1 作为相位累加器输出。

- DB9：名称 PIN/SW。控制硬件/软件来选择频率和相位寄存器、复位和关断DAC。

  - PIN/SW = 1：使用 PIN 作为控制功能

  - PIN/SW = 0：使用软件控制位作为控制功能。此时 PIN 虽然不使用，但是需要接入稳定的高/低电平，杜绝悬空导致错误。

    > 一个引脚（或信号线）既没有连接到高电平（VDD），也没有连接到低电平（GND），也没有通过上拉/下拉电阻固定，而是处于“未定义”的状态。

- DB8：名称 RESET。复位内部寄存器。

  - RESET = 1：可将内部寄存器复位至0。
  - RESET = 0：禁用RESET。

  > 这里需要区分 RESET 的对象✅
  >
  > - 可寻址寄存器 = 频率/相位/控制（RESET 不会动它们）
  > - 不可寻址寄存器 = 相位累加器/DAC 输入寄存器（RESET 会清零它们）

- DB7：名称 SLEEP。
  - SLEEP = 1：禁用 MCLK。此时 NCO 不进行累加功能，因此 DAC 输出仍保持其预设值（NCO 停止，DAC 活动，输出 **会一直保持冻结相位对应的电压**）
  - SLEEP = 0：MCLK 使能
- DB6：名称 SLEEP12（功能与 SLEEP 引脚相同）
  - SLEEP12 = 1：关断片内 DAC
  - SLEEP12 = 0：DAC 使能
- DB5：名称 OPBITEN。是否通过SIGN BIT OUT引脚提供输出
  - OPBITEN = 1：使能SIGN BIT OUT引脚
  - OPBITEN = 0：SIGN BIT OUT引脚不提供任何输出（高阻抗）
- DB4：名称 SIGN/PIB 。控制 SIGN BIT OUT 的具体输出。
  - SIGN/PIB=1：比较器输出**由模拟信号过零点触发**的 0/1 方波（更模拟：相当于对模拟波形做“电平比较”）
  - SIGN/PIB=0：输出纯数字的过零方波 MSB 。（更数字：相当于直接做“数值过零检测”）
- DB3：名称 DIV2。
  - DIV2 = 1时，数字输出 被直接送至SIGN BIT OUT引脚。
  - DIV2 = 0时，数字输出/2 被直接送至SIGN BIT OUT
- DB1：名称MODE 。控制 IOUT/IOUTB。如果控制位OPBITEN = 1，此位应清0
  - 当MODE = 1时，SIN ROM被旁路，因而得到来自DAC的三角波输出。
  - 当MODE = 0时，SIN ROM用于将相位信息转换成幅度信息，进而在输出端提供正弦信号。

总结为：

| Bit           | 名称           | 功能说明                                                     |
| ------------- | -------------- | ------------------------------------------------------------ |
| **DB15:DB14** | **控制字识别** | 必须 = `00`，表示写控制寄存器（如果 = `01` 或 `10`，表示写频率寄存器；如果 = `11`，表示写相位寄存器）。 |
| **DB13**      | **B28**        | 控制写入频率寄存器的方式： - `1`：连续两次写入，先 14 LSB，再 14 MSB（推荐方式，避免毛刺）。 - `0`：只写一次，通过 DB12 决定写 MSB 还是 LSB。 |
| **DB12**      | **HLB**        | 仅在 `B28=0` 时有效： - `1`：写入 14 MSB - `0`：写入 14 LSB  |
| **DB11**      | **FSEL**       | 选择频率寄存器： - `1`：FREQ1 → 相位累加器输入 - `0`：FREQ0 → 相位累加器输入 |
| **DB10**      | **PSEL**       | 选择相位寄存器： - `1`：PHASE1 - `0`：PHASE0                 |
| **DB9**       | **PIN/SW**     | 控制 FSEL/PSEL/RESET/SLEEP 的选择来源： <br>- `1`：用芯片引脚（硬件控制）<br> - `0`：用寄存器位（软件控制）。注意：若不用引脚，需固定电平，避免悬空。 |
| **DB8**       | **RESET**      | 复位相位累加器和 DAC 寄存器（频率/相位寄存器内容不会丢失）： <br/> - `1`：复位有效，输出被强制到中间电平  <br/>- `0`：复位无效（正常工作） |
| **DB7**       | **SLEEP1**     | 控制内部 MCLK： <br/>- `1`：MCLK 禁用，NCO 停止累加，DAC 输出保持在冻结电平 <br/> - `0`：MCLK 使能，正常运行 |
| **DB6**       | **SLEEP12**    | 控制 DAC： <br/> - `1`：DAC 关闭，仅数字部分运行（可配合 OPBITEN 输出 MSB/比较器方波） <br/> - `0`：DAC 打开（正常输出正弦/三角波） |
| **DB5**       | **OPBITEN**    | 使能 SIGN BIT OUT 引脚： <br/> - `1`：SIGN BIT OUT 有效（输出由 DB4/DB3 控制的信号）  <br/>- `0`：SIGN BIT OUT 高阻态 |
| **DB4**       | **SIGN/PIB**   | 决定 SIGN BIT OUT 输出内容（当 OPBITEN=1）：  <br/>- `1`：比较器输出（由 DAC 模拟正弦波过零比较得到的方波）  <br/>- `0`：DAC 数据 MSB（或 MSB/2，由 DIV2 决定），纯数字方波 |
| **DB3**       | **DIV2**       | 配合 SIGN/PIB=0 使用：  <br/>- `1`：输出 DAC 数据 MSB  <br/>- `0`：输出 DAC 数据 MSB/2 |
| **DB2**       | **Reserved**   | 保留，写 0                                                   |
| **DB1**       | **MODE**       | 输出波形模式：  <br/>- `1`：绕过 SIN ROM，输出三角波  <br/>- `0`：经 SIN ROM 转换，输出正弦波 |
| **DB0**       | **Reserved**   | 保留，写 0                                                   |

✅ 总结：
 AD9834 控制寄存器其实就是在 **四个方向上切换功能**：

1. **写入模式**（B28，HLB）
2. **信号选择**（FSEL，PSEL，PIN/SW）
3. **运行状态**（RESET，SLEEP1，SLEEP12）
4. **输出模式**（OPBITEN，SIGN/PIB，DIV2，MODE）

明天开始，实现一个 1KHz 正弦波的功能。并且输出一个稳定电压。

# 9.10

## AD9834生成 1KHz正弦波

昨天虽然整理了上面那个控制寄存器的表，但是深感掌握地不明不白，今天就按照 AD9833，调试一下。

## AD9833生成正弦波的 SDATA

经过手册描述，生成一个 1KHz正弦波的步骤为（主时钟为 50 MHz）:

1. 计算 1KHz 对应要写的频率寄存器值 FREQ0REG = 268435（0x41893 = 0b 0100 0001 1000 1001 0011）
   - LSB = 0x1893
   - MSB = 0x0010
2. 分两次写入到 FREQ0 频率寄存器中。SDATA 输入依次为：
   - SDATA = `0x2000`：B28 = 1。将一个完整字通过两次连续写入载入频率寄存器。
   - SDATA = `0x5893`：D15 = 0 ，D14 = 1（1 << 14）| LSB
   - SDATA = `0x4010`：D15 = 0 ，D14 = 1（1 << 14）| MSB
3. 配置输出为正弦波
   - MODE = 0，OPBITEN = 0。

## AD9833使用 SPI 写数据

已知 AD9833 在 SPI 总线 0 的片选 0 上`/dev/spidev0.0`。要想与之通信，需要知道 AD9833 的：

1. SPI 通信协议：AD9833 在 SCLK 时钟下降沿时候，才会从 SDATA 中获取数据。空闲时候维持高电平。所以其 SPI 模式

# 9.11

今天就是实现AD9834频率可调的方波。

## AD9834方波

现在是13：48，通过阅读文档，理解：

- AD9834 硬件如何产生方波
- AD9834 输出方波的 SDATA 输入

### 方波产生来源

根据手册中对于寄存器位`SIGN/PIB`的描述：

- `SIGN/PIB` = 1：输出比较器的值。
- `SIGN/PIB` = 0：输出 DAC 的 MSB 

这里分别解释比较器的值和 DAC 的 MSB 从何而来：

- 比较器的输入：**VIN** 就是 **DAC** 产生的模拟正弦波。通过将这个正弦波送入比较器，芯片能够将其与一个内部参考电压进行比较，从而在输出端生成一个同频率的方波。这是一种高效地将正弦波转换为方波的方法。
- DAC 的 MSB ：NCO 产生相位信息后，由 SIN ROM 将相位转换为正弦波的幅值。而这个 SIN ROM 输出的幅值，最终会被输送到 DAC 进行数-模转换。而这个 MSB 就是 DAC 数据总线上的最高位。

### 使用场景差异

1. 比较器处理的正弦波方波（SIGN/PIB = 1）
   - **高精度、低抖动**的方波信号作为时钟源或同步信号
2.  DAC MSB 数字方波（SIGN/PIB = 0）
   - 数字同步或状态指示：用这个MSB信号来触发一个外部逻辑电路，或者作为一个简单的同步脉冲。

### SDATA 输入

要想实现 AD9834 的方波输出，前面的配置频率寄存器的步骤与产生正弦波类似：

1. 写控制寄存器：提示要向 FREQ0/1 中连续写入数据
2. 第一次将频率字的 LSB 写入频率寄存器
3. 第二次将频率字的 MSB 写入频率寄存器

但是输出波形的时候，就不同了：

- 写控制寄存器：解除休眠 + 方波输出

针对当前应用场景，我们要实现的是输出5KHz - 7KHz 的方波。AD9834 手册中，对于比较器部分的描述中，明确地写到了：

> 由于比较器输入端交流耦合，因此要作为零交越检波器正常工作，输入频率最小值通常应为3 MHz。

这意味着，该比较器无法可靠地将低于 3 MHz 的正弦波信号转换为方波。因此，要输出 **500 kHz 到 700 kHz** 的方波，是无法通过利用 AD9834 的内部比较器来实现的。

所以我们只能采用 **DAC 的 MSB 输出**（SIGN/PIB = 0 | OPBITEN = 1 | DIV2 = 1 | MODE = 0）。

# 9.15

现在任务是：

- 理顺何总说的，对于根据特定文件，让AD9834生成对应的方波（《天津大学海洋学院单波束测流需求》）

## 理解需求

> 发射端信号波形和频率可自设（包括但不限于CW、LFM、方波）且可读取外部波形(csv或wav文件)，发射端兼备功率放大和电压放大功能(作用距离50米)，550KHz-650Khz某一频段

### 发射端的功能需求

**波形可选**

- 支持多种波形：
  - **CW（连续波正弦）** → 固定频率正弦波
  - **LFM（线性调频/Chirp）** → 频率随时间线性变化的正弦波
  - **方波** → 二值波形
- 可能还有其他特殊波形（如三角波、任意波形），所以用“包括但不限于”

**频率可设**

- 用户/控制系统可以自由设置输出频率

- 对 LFM，还意味着可以设置 **起始频率、终止频率、扫频速率**

  | 参数            | 符号  | 说明                 | 单位 / 范例   |
  | --------------- | ----- | -------------------- | ------------- |
  | 起始频率        | $f_0$ | LFM 信号开始时的频率 | Hz            |
  | 终止频率        | $f_1$ | LFM 信号结束时的频率 | Hz            |
  | 扫频带宽        | B     | $B=f_1 - f_0$        | Hz            |
  | 脉冲宽度        | T     | 信号持续时间         | s             |
  | 扫频率 / 调频率 | K     | 频率变化率 $K=B/T$   | Hz/s          |
  | 初始相位        | $ϕ_0$ | 信号开始时的相位     | rad           |
  | 振幅            | A     | 输出幅度             | V、单位幅值等 |

**CSV** 和 **WAV** 的本质区别只是数据的封装方式：

- CSV（逗号分隔值）通常保存一张表格，你可以把它理解为「采样时间点 + 对应的电压/幅值」。
- WAV 是一种音频文件格式，里面封装了数字化后的波形数据。

## 确认GPIO是否启用

现在想确认 CPU 引脚 AB1 在开发板上到底配置成什么功能，核心就是查看设备树中的 pinctrl 配置。

首先确认其管脚复用：

```C
CIF_D3/EBC_SDDO3/SDMMC2_D3_M0/I2S1_SDO0_M1/VOP_BT656_D3_M1/GPIO3_D1_d
```

然后

1. 找到 AB1 对应的 pinctrl 节点。
2. 搜索 DTS 文件，看看哪些外设节点引用了这个 pinctrl 节点。
   - CIF 摄像头节点引用 `cif_dvp_bus8` → 如果启用，AB1 就是 CIF_D3。
   - SDMMC2 节点引用 SDMMC2_D3_M0 → 如果启用，AB1 就是 SDMMC2_D3。
   - I2S1 节点引用 I2S1_SDO0_M1 → 如果启用，AB1 就是 I2S1_SDO0。

> 核心就是找到 `pinctrl-0 = <&XXX>`，然后看该节点在 DTS 中对应哪个外设在使能。

### CIF 外设

搜索功能`cif_d3`，找到了

```dtd
cif_dvp_bus8: cif-dvp-bus8 {
	...
	/* cif_d3 */
	<3 RK_PD1 1 &pcfg_pull_none>,
   ...
};
```

- `3`: 代表这是 GPIO Bank 3。
- `RK_PD1`: 这是 `GPIO3_D1` 在芯片手册中的代号。`P` 代表第3个字母，也就是第4个（A, B, C, D），所以是D组，`1` 代表是D组的第2个引脚。

`lt8619c`（一个视频转换器）通过 `pinctrl` 属性引用并使用了 `cif_dvp_bus8` 这个引脚配置：

```C
&i2c2 {
  status = "okay";
  ...
  lt8619c: lt8619c@32 {

   pinctrl-0 = <&cif_dvp_clk &cif_dvp_bus16 &cif_dvp_bus8>;
  ...
```

在文件`rk3568-evb6-ddr3-v10.dtsi`的 `lt8619c` 节点中，这一行：

```
pinctrl-0 = <&cif_dvp_clk &cif_dvp_bus16 &cif_dvp_bus8>;
```

明确地将 `lt8619c` 这个设备与三个不同的引脚组关联起来。其中：

- `cif_dvp_clk`：用于配置时钟引脚。
- `cif_dvp_bus16`：用于配置16位总线引脚。
- **`cif_dvp_bus8`：用于配置8位总线引脚，也就是你之前提到的包含 `GPIO3_D1` 的引脚组。**

由于这个设备节点（`lt8619c`）的 `status = "okay";`，并且它引用了 `cif_dvp_bus8`，这证实了 `GPIO3_D1` 这个引脚确实被分配给了 `LT8619C` 这个设备，并作为 CIF_D3 功能使用。

### EBC_SDDO3引脚组

搜索`EBC_SDDO3`，可以看到`ebc_sddo3`节点是

```C
ebc_pins: ebc-pins {
	rockchip,pins =
	...
		/* ebc_sddo3 */
	<3 RK_PD1 2 &pcfg_pull_none>,
	...
```

设备树代码

```C
ebc: ebc@fdec0000 {
	compatible = "rockchip,rk3568-ebc-tcon";
	reg = <0x0 0xfdec0000 0x0 0x5000>;
	interrupts = <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
	clocks = <&cru HCLK_EBC>, <&cru DCLK_EBC>;
	clock-names = "hclk", "dclk";
	power-domains = <&power RK3568_PD_RGA>;
	rockchip,grf = <&grf>;
	pinctrl-names = "default";
	pinctrl-0 = <&ebc_pins>;
	status = "disabled";
};
```

这段设备树代码非常清晰地说明了 `ebc` 设备的当前状态。

------

`ebc` 设备的 `status = "disabled";` 这一行很重要。这表明，尽管设备树中定义了 `ebc` 设备及其引脚配置（包括 `ebc_sddo3`，即 `GPIO3_D1` 的功能之一），但该设备在系统启动时是被禁用的。因此，`GPIO3_D1` **并没有**被用于 EBC 功能。

### SDMMC2_D3引脚组

`SDMMC2_D3_M0`为关键字：

```C
sdmmc2m0_bus4: sdmmc2m0-bus4 {
	rockchip,pins =
		/* sdmmc2_d0m0 */
		<3 RK_PC6 3 &pcfg_pull_up_drv_level_2>,
		/* sdmmc2_d1m0 */
		<3 RK_PC7 3 &pcfg_pull_up_drv_level_2>,
		/* sdmmc2_d2m0 */
		<3 RK_PD0 3 &pcfg_pull_up_drv_level_2>,
		/* sdmmc2_d3m0 */
		<3 RK_PD1 3 &pcfg_pull_up_drv_level_2>;
};
```

在`rk3568-evb1-ddr4-v10.dtsi`中引用：

```C
&sdmmc2 {
	max-frequency = <150000000>;
	supports-sdio;
	bus-width = <4>;
	disable-wp;
	cap-sd-highspeed;
	cap-sdio-irq;
	keep-power-in-suspend;
	mmc-pwrseq = <&sdio_pwrseq>;
	non-removable;
	pinctrl-names = "default";
	pinctrl-0 = <&sdmmc2m0_bus4 &sdmmc2m0_cmd &sdmmc2m0_clk>;
	sd-uhs-sdr104;
	status = "okay";
};
```

`&sdmmc2` 设备节点引用了之前的 `sdmmc2m0_bus4` 引脚配置，从而将 `GPIO3_D1` 及其它引脚分配给了 SD 卡功能。

**将 SDMMC2 控制器启用，并为其分配了一组特定的引脚，其中就包括 `GPIO3_D1`。** 由于 `status` 被设置为 `"okay"`，这意味着 `GPIO3_D1` 实际上已经被用于 SD 卡接口，而不能作为其他功能（比如 CIF 或通用的 GPIO）使用。

# 9.16

## GPIO3_D1重复使用问题

上文可知：一个物理引脚（`GPIO3_D1`，对应 CPU 引脚 `AB1`）在两个不同的设备树文件 (`rk3568-evb6-ddr3-v10.dtsi` 和 `rk3568-evb1-ddr4-v10.dtsi`) 中被配置成了两种不同的功能（CIF 和 SDMMC2）

最终哪一种配置生效了？

跟myzr厂家沟通后，发现开发板只用到了以`myzr`开头的设备树文件。所以这两个配置并没有生效。



# 9.17

今天要做的就是：实现AD9834在 10ms 左右，调制 550KHz 到 650KHz 。

学完后，联系厂家维修电机的漂移问题，然后双电机调试。

## AD9834实现 LFM 信号

现在 AD9834 输出特定频率的方法，就是通过向相位累加器中不断写入固定的数据即可。

而相位累加器的固定输入，被称为频率字。我们可以通过控制寄存器，向 AD9834 的两个频率寄存器（FREQ0 和 FREQ1）来写入频率字，实现输出固定频率的信号。

要想实现输出线性调频的数据，我们需要让频率字线性变化。也就是说，要向频率寄存器中不断写入频率值。

## 当前存在的问题

现在面临的问题在于：

- 这是一个很精准的线性调频过程，输出10ms的调制，就要求AD9834在 10ms 之前和 10ms 之后无杂波
- 10ms的时间内完成调制

那就要知道，AD9834是怎么输出波形的。需要验证，是否设置波形后，就会立即输出对应的波形数据？跟SLEEP是否有关系。

# 9.18

今天继续解决昨天面临的问题：

- 确保 AD9834 在输出550KHz 之前无杂波，输出 650 KHz 之后无杂波
- 持续时间为 10 ms

# 9.19

今天阅读了[This Cute World](https://thiscute.world/)技术博客，被作者溢出博客的好奇心和折腾劲所打动。并且在进一步阅读文章的时候，看到[0xFFFF](https://0xffff.one/)

博客，看到了当年找到csdiy时候的感觉了。里面对于个人的不断追求，精益求精，真的非常贴合我的想法。

今天是周五了，也应该对本周的工作做一个总结了。

- [ ] 确认 AD5932 硬件规格，是否满足需求
- [ ] 确认 NixOS 与 Debian 哪个更符合长久开发编程环境

## 周记

- 周一：
  - 分析两个需求：任意波形生成并且可以从文件中读取并设置波形
  - 确认MYZR厂家的开发板的设备树中，GPIO3并未被占用
- 周二：感冒身体欠佳，简单学习了下CSV和WAV文件中存储信息的构造；工作之余烧录了一个 MDC 单板的 boot
- 周三：AD9834 开始实现线性调频，但是产生了不同的波；
- 周四：多次确认 AD9834 在 10 ms 内实现 550KHz - 650KHz 的线性调频是不可取的，所以确认要更换方案。经过初步研究，决定要换 AD5932 设备实现更可控的线性调频。

这周的优点：

- 认真阅读 AD9834 手册，并且实现了对应写入频率、实现方波输出的功能
- 熟练地掌握了如何检测某段时间、某段幅值的信号发生情况
- 不断尝试 SPI 最短写入时间和 LFM 最小步进的差距，最终确认 AD9834 无法实现要求
- 将笔记本电脑重装为 Debian13 系统，并且配置了中文输入法和 clash
- 作息优良，早睡早起

## 需求分析

因为之前 AD9834 无法完善地实现 LFM 线性调频的功能，所以经过 AI 协助，要确认使用另一个产品。

那么这个 AD5932 能否实现我们的需求呢？这里需要再重新确认下我们的需求。

### 需求

开始于10：30。

主要是 LFM 需求：

- 起始频率：500KHz
- 终止频率：700KHz
- 持续时间：10ms
- 步进：不限（越高越好）

## AD5932 手册概述

- 频率步进长度是可编程的：在一段时间内持续某种频率。

- 频率自动增加 / 或者由外部的 CTRL 引脚控制

- 线性调频的末尾，仍会输出末尾波形信号，直到设备被 reset

- 为了实现 LFM：

  - 输入开始频率
  - 频率步长
  - 步进次数
  - 驻留时间

  这样就可以实现输出了（频率可以被 CTRL 引脚控制）

- 通信方面：SCLK的速度至高到 40 MHz

- 供电方面：2.3V - 5.5V

- 省电方面：可以手动关闭内部不用的器件

## 英文阅读顺序

在阅读 datasheet 的时候，由于默认会用简略名词堆砌，缺乏明确修饰，会导致一些误解。例如 AD5932 的 datasheet：

> Enter the start frequency, the increment step size, the number of increments to be made, and the time interval that the part outputs each frequency

- increment step size → **频率的递增步长**
- time interval → **时间间隔**

这里 datasheet 省略了修饰词，只写 **increment step size**，确实有可能让人误解为”时间间隔“。这是由于： datasheet 风格（省略限定词）+ 你的直觉联想造成的

## AD5932 引脚介绍

现在来到与编程息息相关的部分：引脚功能描述。但是在此之前，需要理解以下背景知识：

- DVDD = 2.3 V to 5.5 V：芯片的数字电路可以在这个电压范围内正常工作
- AGND = DGND = 0 V：模拟地和数字地必须连接到同一地参考

下面是针对开发相关的引脚描述：（初步描述，因为对于很多不理解，先读个大概吧😉）

- MCLK：DDS的输出频率是 MCLK 的一个分数

- SYNCOUT：输出引脚；输出扫频状态信息（存疑）。**SYNCOUTEN 位设为 1**，它才会开始工作。

  > **作为扫频过程的“指示信号”**：
  >
  > - 选 EOS → 你能知道扫频什么时候结束。
  > - 选 Frequency Increment → 你能知道每次频率切换的瞬间。
  >
  > **常见用途**：
  >
  > - 做 **同步触发**（比如同步外部采集设备 ADC，每次频率变更时采样）。
  > - 做 **状态监控**（比如 MCU 通过中断口检测扫频完成，不用反复查询 AD5932）

-  MSBOUT ： 数字输出引脚；MSBOUTEN 控制位为 1 时，此输出引脚被启用

- INTERRUPT：数字输入。打断频率扫描的作用。会重置状态机，引脚电平置为中。 

- CTRL：数字输入。

  - 包含三个功能：初始化、开始以及外部触发频率增长。
  - 从低到高的触发方式
  - 功能-频率**内部自动**增长模式下：只触发一次
  - 功能-频率**外部**增长模式下：每次触发一次，频率增长一次

- SDATA：串行数据输入。16位，首先输入的是 4 位的地址，后面以此是 MSB 到 LSB 数据，即为位序传输（MSB-first）

- SCLK：下降沿的时候，芯片接收数据

- FSYNC：低电平时候芯片获取数据

-  STANDBY ：高电平时，禁用 MCLK，同时 DAC 和比较器也被断电。**先复位，再进入 STANDBY**，电流能降到大约 **20 µA**，这几乎就是“休眠电流”。**推荐的使用习惯**：在进入 STANDBY 之前，先复位（RESET），再拉高 STANDBY → 电流降到最小，适合电池供电或节能场景。

- VOUT：模拟输出接口。这里存在一个 200Ω 的电阻，所以不需要外接电阻了。

# 9.20

仔细研究了下AD5932的手册，满足生产需要应该是ok的。

# 9.22

继续阅读AD5932的手册，试着理解并实现回调函数。

现在是上午10：15分，重新阅读 5932 的编程章节。

## AD5932扫频

AD5932 没有单独的 `RESET bit`。

向控制寄存器写入任意值时，芯片会执行一次 **内部复位/重新开始扫描**。

### 开始频率

开始频率由一个 24 位的寄存器进行保存。

- B24 = 1：完整写开始频率寄存器，需要分两次写入：先写 LSB 后写 MSB。

- B24 = 0：单独写 LSB 或 MSB

### 频率步进

频率步进寄存器是 23 位的寄存器。并且频率步进既可以为正，也可以为负。

### 步数

5932没有设置结束频率，相应地，使用`开始频率 + 频率步进 × 步数` 来确定结束频率。

步数寄存器大小为 12 位。步数范围为 2 到 4095 。

### 频率持续时间

这个参数决定了扫频过程中，每个输出频率的持续时间。

并且为了适应不同的持续单位，可以设置为时钟的倍数（1、5、100和500倍）

## 激活扫描

CTRL 引脚从 0 - 1 的电平变化会激活扫频。但是频率的变化，既可以按照设置的频率持续时间自动跳转，也可以通过 CTRL 引脚手动控制。这就将频率的增长控制方式，分为了自动增加和手动增加这两种。

### 打断引脚

INTERRUPT 引脚负责打断正在生成的扫频。由低到高的电平，会终止正在生成的扫频流程，并将电平设置为中。

当 **STANDBY = High**（高电平）：

- 内部 **MCLK 停止**（不再累加时钟）。
- **参考电路、DAC、内部稳压器** 都关闭 → 降低功耗。
- DAC 输出保持在 **进入 standby 前的最后一个值**（不会清零或跳变）。

总结：

- **STANDBY 高电平** → 芯片进入省电模式（DAC 停在最后值，功耗最低 ~20 µA）。

- **退出 standby** → 时钟恢复，输出继续，但如果要换新数据，必须 reset 再启动。

- 所以它更像是一个 **“暂停+省电” 功能**，而不是彻底关机。

## AD5932的输出

### VOUT 的模拟输出

VOUT = 模拟输出引脚，可以输出正弦或三角波。

控制寄存器选择波形：

- `D9 = 1` → 正弦波（默认情况，经过 SIN ROM）。
- `D9 = 0, D10 = 1` → 三角波（绕过 SIN ROM，直接 DAC）。

不需要额外电阻，直接取 VOUT 就能用。

### MSBOUT 和 SYNCOUT

**MSBOUT**：输出反相的 MSB，得到数字方波 → 主要用作数字时钟源。

**SYNCOUT**：扫描状态输出

- 可以做“扫描完成信号”
- 或者做“频率递增指示脉冲”

## 回调函数

回调函数：**把一个函数的地址传递给另一个函数，这个函数在合适的时机再调用它**。

- 普通函数：主动调用某个函数，去实现功能
- 回调函数：回调函数将地址传递给另一个函数，以备后续使用

## AD5932 控制寄存器位说明（简版）

- **D11 (B24)**：频率字写入方式
  - `1` = 两次写入组成完整 24 位频率字（推荐方式，避免中间值）。
  - `0` = 24 位寄存器拆分为两个 12 位寄存器，可单独更新高 12 位或低 12 位。
- **D10 (DAC ENABLE)**：DAC 使能
  - `1` = DAC 打开（允许 VOUT 输出模拟波形）。
  - `0` = DAC 关闭（省电，适用于只用数字 MSBOUT 输出）。
- **D9 (SINE/TRI)**：输出波形选择（VOUT 引脚）
  - `1` = 正弦波（经过 SIN ROM）。
  - `0` = 三角波（绕过 SIN ROM，直接 DAC）。
- **D8 (MSBOUTEN)**：MSB 数字输出使能
  - `1` = 允许 MSBOUT 引脚输出反相信号（方波时钟源）。
  - `0` = MSBOUT 高阻态（禁用）。
- **D7, D6 (Reserved)**：保留位
  - 必须写 `1`。
- **D5 (INT/EXT INCR)**：频率递增触发方式
  - `1` = 外部触发（CTRL 引脚控制）。
  - `0` = 内部自动递增。
- **D4 (Reserved)**：保留位
  - 必须写 `1`。
- **D3 (SYNCSEL)**：SYNCOUT 输出模式（仅当 D2=1 有效）
  - `1` = SYNCOUT 在扫描结束时拉高，表示 End of Scan。
  - `0` = 每次频率递增时输出一个持续 4×TCLOCK 的脉冲。
- **D2 (SYNCOUTEN)**：SYNCOUT 引脚使能
  - `1` = 允许 SYNCOUT 引脚输出状态信号。
  - `0` = SYNCOUT 高阻态（禁用）。
- **D1, D0 (Reserved)**：保留位
  - 必须写 `1`。



# 9.23

## API层分析

API 层应该包含所有与 AD5932 **芯片功能**相关的函数，它们负责将应用层的请求（如设置频率、波形）转换为对驱动层的具体调用。

**API 层应包含的函数列表**：

- **`ad5932_reset`**: 用于复位 AD5932 内部状态机。
- **`ad5932_set_waveform`**: 用于设置输出波形类型（正弦波、三角波或方波）。
- **`ad5932_set_start_frequency`**: 用于设置频率扫描的起始频率。
- **`ad5932_set_delta_frequency`**: 用于设置频率扫描的增量频率。
- **`ad5932_set_num_increments`**: 用于设置频率扫描的步进数量。
- **`ad5932_set_increment_interval`**: 用于设置每次频率增量的间隔时间。
- **`ad5932_set_auto_increment`**: 用于将芯片设置为内部自动增量模式。
- **`ad5932_set_external_increment`**: 用于将芯片设置为外部触发增量模式。
- **`ad5932_set_syncout`**: 用于配置同步输出（SYNCOUT）引脚。
- **`ad5932_setup_lfm_sweep`**: 一个高级函数，将扫频参数（起始、结束频率、步数和驻留时间）转换为一系列对其他 API 函数的调用。
- **`ad5932_start_sweep`**: 用于启动频率扫描。
- **`ad5932_standby`**: 用于将芯片设置为待机模式。

## 频率增量

频率增量寄存器的大小为 23 位，所以需要两次 16 位的写才可以设置完毕。其设置方案为：

- 第一次：从 15 位到 0 位的数据为：0b0010 + 12位的 LSBs（即为频率增量寄存器的低 12 位）
- 第二次：从 15 位到 0 位的数据为（即为频率增量寄存器的高 11 位）：
  - 正增量：0b00110 + 11 位的 MSBs
  - 负增量：0b00111 + 11 位的 MSBs

所以需要基于这样的方案，提供一个写入频率增量寄存器的方案。

## 频率变化的次数

频率寄存器位数为 12 位，范围为 [2, 4095] 。

# 9.24

## 覆盖问题

### 问题描述

在实现`ad5932_set_auto_increment`函数的时候，突然意识到这个操作可能会覆盖之前的操作。

将芯片的扫频模式改为外部控制递增频率的时候，要向控制寄存器中的 D5 位写 1 。即为：

```C
AD5932_REG_CONTROL | AD5932_CTRL_BASE | AD5932_CTRL_EXT_INCR
```

然而这会导致控制寄存器中之前保存的命令，如果设置了其他位为 1 的话（例如`AD5932_CTRL_SYNC_EN`），就会被这个新的控制寄存器命令字给覆盖掉。这样会导致命令的覆盖，而导致混乱的时序问题。

这就暴露出另外一个问题了，就是面向驱动手册开发的话，就会导致跟实际业务可能有冲突。现在梳理一下用户层面的接口需求。

## 用户接口思考

暴露给用户的 AD5932 有三个核心功能：

1. 稳定输出波形
2. 扫频参数设置
3. 状态控制

下面分别介绍下具体细节。

### 稳定输出波形

AD5935 开发板提供给用户稳定输出波形的能力。输出波形的种类为：

- 正弦波
- 三角波
- 方波

用户选择波形后，输入目标频率，然后就可以获取稳定频率的波形数据。

### 扫频参数设置

AD5932 开发板也提供给用户扫频的功能。扫频功能分为两种：

1. 按照相同的时间间隔扫频
2. 输出N个波形后，再跳转到下一个频率的扫频

对于时间间隔扫频模式，用户需要输入：

- 扫频波形：正弦波、三角波和方波
- 起始频率
- 终止频率
- 扫频持续时间
- 扫频步数

对于输出N个波形后，再跳转到下一个频率的扫频模式，用户需要输入：

- 扫频波形：正弦波、三角波和方波
- 起始频率
- 终止频率
-  扫频总波形数
- 扫频步数

用户设置完毕后，通过“开始扫频”后，即可获取到 LFM 扫频波形。

### 状态控制

包含三个功能：

1. 开始扫频
2. 中断扫频
3. 获取扫频状态（检测是否扫频完成）

这就是应该暴露给用户层`include`的接口，而具体实现就是在`/app`中。而具体 AD5932 的接口实现，是在`/api`层。

按照用户需求以及TDD 驱动开发，我应该暴露什么接口给用户？

## 配置稳定波形输出接口分析

现在想要输出稳定波形，用户层`app/`需要这几个接口：

```C
// 波形类型
typedef enum {
    WAVEGEN_SINE     = 0,
    WAVEGEN_TRIANGLE = 1,
    WAVEGEN_SQUARE   = 2
} wavegen_wave_t

/**
 * @brief 输出稳定频率波形
 * 
 * @param wave_type 波形类型 (正弦/三角/方波)
 * @param frequency 输出频率 (Hz)
 * @return true 成功
 * @return false 失败
 */
bool wavegen_output_fixed_wave(wavegen_wave_t wave_type, uint32_t frequency);
```

## FPGA读写问题

在 AD5932 中，存在几个引脚是跟业务息息相关的：

-  INTERRUPT：终止扫频恢复初始电平 
-  SYNCOUT ：读取扫频结束信号
-  CTRL ：开始扫频
-  STANDBY ：暂停/恢复输出引脚。可以配合控制寄存器 reset 来实现低功耗模式

而要想实现这几个物理引脚的控制，需要读写 FPGA 来实现。所以需要预留 FPGA 接口。实现方案是：

1. 在协议层`protocol/`加入 FPGA 读写控制
2. 在5932驱动层`driver/`中，加入对于四个控制引脚的操作
3. 在`api/`层中，实现对应的引脚操作调用

现在由于无法实际控制 FPGA 的读写方式，所以就先在 `api`中写假的调用函数即可。

# 9.25

现在基本的频率输出的框架基本完成了。现在需要讨论下，扫频的处理方法。

## 扫频需求

AD5932 开发板也提供给用户扫频的功能。扫频功能分为两种：

1. 按照相同的时间间隔扫频
2. 输出N个波形后，再跳转到下一个频率的扫频

对于时间间隔扫频模式，用户需要输入：

- 扫频波形：正弦波、三角波和方波
- 起始频率
- 终止频率
- 扫频持续时间
- 扫频步数

对于输出N个波形后，再跳转到下一个频率的扫频模式，用户需要输入：

- 扫频波形：正弦波、三角波和方波
- 起始频率
- 终止频率
- 扫频总波形数
- 扫频步数

用户设置完毕后，通过“开始扫频”后，即可获取到 LFM 扫频波形。

所以这里扫频我们就做两个功能：

1. 配置扫频参数
2. 控制扫频开始

那么现在讨论下，应该给用户提供怎样的接口来屏蔽内部实现呢？并且如何将终止频率转换到 api 层的对应参数呢？

## 时间间隔扫频参数转换

**`wavegen_config_sweep_by_time_interval`**: 用于配置按时间间隔扫频的参数。

- `wave_type`：波形类型
- `start_frequency_hz`：起始频率（Hz）
- `end_frequency_hz`：终止频率（Hz）
- `sweep_duration_ms`：扫频总持续时间（毫秒）
- `num_increments`：扫频步数

### 扫频配置的三个核心参数

根据 AD5932 数据手册中的 "Frequency Profile" 部分，扫频的频率是由起始频率、增量步长和步数决定的 

我们需要将终止频率转换为 AD5932 芯片的 `delta_frequency`（增量步长）、`positive`（增量方向）和 `num_increments`（步数）。

转换公式如下：

- `delta_frequency_hz = |(end_frequency_hz - start_frequency_hz) / num_increments|`
- $positive=(fEND>fSTART)?True:False$

###  扫频总时间 → 时间间隔

接口是基于 **扫频总时间（sweep_duration_ms）**，所以我们还需要计算 **每步的时间间隔（t_step）**，然后写入 AD5932 的 **TINT 寄存器**。

$t_INT$ 寄存器位图（高位到低位）：

- D15 D14 = `0 1` （固定，手册示例如此）
- D13 = 0 → “固定数目的输出波形 cycles” 模式（基准为 1 / f_out）
   1 → “固定数目的 MCLK periods” 模式（基准为 1 / MCLK）
- D12 D11 → time-base multiplier:
  - `00` → ×1
  - `01` → ×5
  - `10` → ×100
  - `11` → ×500
- D10..D0 → 11-bit 值 N（以二进制编程，最小值为 2，最大为 2047）

实际持续时间公式（给定基准 unit 和 multiplier）：

$t_{\text{achieved}} = N \times ( \text{base\_unit} ) \times \text{multiplier}$

其中 $base_unit = 1/f_out$ （cycles 模式）或 1/MCLK （clock-periods 模式）。

现在基于 **扫频总时间（sweep_duration_ms）**，以及步数（num_increments）来确定这个寄存器的输入。

### 一波三折

经过与何总的讨论，放弃这个方案，选择给用户暴露简单的接口：

```C
/**
 * @brief 配置波形发生器进行频率扫描，按时间间隔递增频率。
 * 
 * @param wave_type 波形类型（例如：0正弦波、1三角波、2方波）。
 * @param start_freq_hz 起始频率，单位为赫兹。
 * @param delta_f_hz 每步频率递增值，单位为赫兹。
 * @param sweep_points 扫描的频点总数。
 * @param sweep_duration_us 扫描总时长，单位为微秒。
 */
void wavegen_config_sweep_by_time_interval(int wave_type, uint32_t start_freq_hz, uint32_t delta_f_hz, uint16_t sweep_points, uint32_t sweep_duration_us);
```

##  TINT（递增间隔寄存器）的设置

### 1.背景回顾

- TINT 控制每个扫频点的持续时间。
- 由三个参数决定：
  - **mode**（基于 MCLK 还是基于输出波形周期数）
  - **mclk_mult**（当 mode=1 时，时间基准放大倍数：1, 5, 100, 500）
  - **interval**（D0~D10，取值范围 2–2047）

时间计算公式（mode=1，基于 MCLK）：$t_{point} = \text{interval} \times \frac{mclk\_mult}{MCLK}$

总时间：$t_{total} = sweep\_points \times t_{point}$

------

### 2.已知条件

- MCLK = 50 MHz
- 用户输入：
  - `sweep_points` （步数）
  - `sweep_duration_us` （总时长，单位 μs）

目标：
 自动推导出 `(mode, mclk_mult, interval)` 使得$t_{total}≈sweep\_duration\_us$

------

### 3. 推导过程

1. 先算出单点时间需求：$t_{point\_target} = \frac{sweep\_duration\_us}{sweep\_points}$

2. 遍历候选 `(mclk_mult, interval)` 组合，算出实际单点时间：$t_{point} = \frac{interval \times mclk\_mult}{MCLK}$

3. 选择误差最小的组合（|t_point - t_point_target| 最小）。

# 9.26

