# 10月份日报

## 10.8

结束了7天的国庆长假。这两天去了月月的家里，跟把爸爸妈妈和姐姐姐夫认真聊了聊。

我能保证的，仅仅只有我的学习进度、锻炼进度和月月的相处。

加油。

- [x] 人文阅读
- [x] 缩短PA学习时间安排

## 10.10

### vim

> 1. 将68行到107行的数据中，形如`{}`的字段替换为`{ TODO(); }`
>
>    ```bash
>    :68,107s/{}/{ TODO(); }/g
>    ```
>
> 2. 删除68行到107行中的注释`//TODO()`
>
>    ```bash
>    69,107s/\/\/TODO//g
>    ```

## `add`

- [x] 调整riscv指令顺序与开放架构之道相同
- [x] 实现获取`B`类指令立即数的方法`immB()`0x800000a4
- [x] 实现`beq`指令0x80000010
- [x] 实现`bne`指令0x800000a4
- [x] 实现`lw`指令0x80000078
- [x] 实现`add`指令0x80000090
- [x] 实现`sub`指令0x80000094
- [x] 实现`sltiu`指令0x80000098

## 10.11

### `add-longlong-run`

- [x] 实现`sltu`指令0x800000a0	
- [x] 实现`xor`指令0x0x800000ac
- [x] 实现`or`指令0x800000b4

### `bit`

- [x] 实现`sh`指令$pc==0x800000bc
- [x] 实现`srai`指令$pc==0x80000028
- [x] 实现`andi`指令$pc==0x80000034
- [x] 实现`sll`指令$pc==0x8000003c
- [x] 实现`and`指令$pc==0x80000040
- [x] 实现`xori`指令$pc==0x800000c4

### `bubble-sort`

- [x] 实现`bge`指令$pc==0x80000040
- [x] 实现`bgeu`指令
- [x] 实现`blt`指令
- [x] 实现`bltu`指令

### `crc32`

- [x] 实现`lui`指令$pc==0x80000038
- [x] 实现`srli`指令$pc==0x8000005c
- [x] 实现`slli`指令$pc==0x800000a8

### `div`

- [x] 实现`mul`指令$pc==0x8000007c
- [x] 实现`div`指令$pc==0x800000a8

### `goldbach`

- [x] 实现`rem`指令$pc==0x8000007c

### `if-else`

- [x] 实现`slt`指令$pc==0x80000084

### `load-store`

- [x] 实现`lh`指令$pc==80000064（符号拓展，应该是从16位拓展到64位）

### `mersenne`

- [x] 实现`mulh`指令$pc==0x80000098
- [x] 实现`remu`指令$pc==0x8000018c
- [x] 实现`divu`指令$pc==0x80000198

### `movsx`

- [x] 实现`srai`指令$pc==0x80000098（符号拓展，应先将src1值位扩展后再移动）

### `mul-longlong`

这个文件似乎有问题:

当`i`和`j`均为0时，

```C
int test_data[0] = 0xaeb1c2aa；
long long ans[0] = 0x19d29ab9db1a18e4LL
long long result = mul(test_data[0],test_data[0]);//0x7736 200D DB1A 18E4
check(ans[0] == result);	
```

很明显两个数的高32位不同。

### `shift`

- [x] 实现`sra`指令$pc==0x800000a8
- [x] 实现`srl`指令$pc==0x800000e0

## 10.12

整理PA2.2需求

## 10.14

摆烂

## 10.15

开始面对PA2.2

专注当下自己的感受吧。

所实话，看到PA2.2的任务量，老是会情不自禁地担忧这个那个的。

先不管了，做出一版再说！这周五，结束PA2.2！

今天继续详细地梳理PA2.2的需求，然后记录在PA2文件中。看完了Lunamous老哥的皇家骑士团讲解，一小时四十分钟的视频，让我对这款游戏感到深深的敬意！

感谢热爱游戏的制作者！

##  阅读`程序, 运行时环境与AM`笔记

运行时环境的实现是和架构相关的。

### 让程序结束的难题

A类型ISA和类型ISA因为本身的指令集不同，所以导致实现程序停止的方法也不相同。那么如何让同一个程序在A和B架构下能正常停止，一般有两个选择：

1. 针对两个架构，写两套不同的代码
2. 在架构和程序之间加一层中间层，中间层定义一个程序终止接口`halt()`。A和B架构用各自的指令集实现对应的`halt()`方法，随后程序编写完毕后，调用中间层的`halt()`方法即可

无脑选2，因为1维护成本太高，2方式通过将程序和架构解耦，提升了程序的可维护性。

这个中间层就是库。运行程序所需要的公共要素被抽象成API, 不同的架构只需要实现这些API, 也就相当于实现了支撑程序运行的运行时环境,

### TRM

最简单的计算机称为"图灵机"(Turing Machine, TRM)，需要满足哪些条件:

- 结构上, TRM有存储器, 有PC, 有寄存器, 有加法器
- 工作方式上, TRM不断地重复以下过程: 从PC指示的存储器位置取出指令, 执行指令, 然后更新PC

### 抽象计算机AM

抽象计算机”（AM, Abstract Machine）是用来简化跨不同架构运行程序的复杂性的。

通过统一的抽象层API来屏蔽底层硬件架构的差异，从而让应用程序能够在不同架构上无缝运行。

AM根据程序的需求将库划分为

```
AM = TRM + IOE + CTE + VME + MPE
```

- TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力
- IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力
- CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力
- VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力
- MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力 (MPE超出了ICS课程的范围, 在PA中不会涉及)

利用计算机硬件的功能实现AM, 为程序的运行提供它们所需要的运行时环境.

而怎么理解下面这段话，就很有意思了😀

> 实现NEMU（硬件）和AM（软件）之间的**桥梁**来支撑程序的运行，是理解PA终极目标“理解程序如何在计算机上运行”的唯一选择。

- NEMU：是一个模拟硬件运行的工具，它可以模拟出真实的硬件环境（比如处理器、内存等），让我们在没有真实硬件的情况下也能运行和测试程序。通过使用NEMU，我们可以理解硬件层面上的运作机制。
- AM：是软件层面上为程序提供统一接口的环境。它让程序不需要直接接触硬件，而是通过一组抽象的API与底层硬件交互。AM相当于在硬件和应用程序之间搭建了一座桥梁，屏蔽了硬件的复杂性。
- **搭建桥梁**：要让程序能够顺利在硬件上运行，我们需要理解并搭建NEMU和AM之间的联系。具体来说，就是要理解程序如何通过AM调用硬件资源，NEMU如何模拟硬件响应程序的请求。

### NEMU运行程序的准备

程序要想运行在NEMU上，就需要使用NEMU提供的运行时环境。

例如程序想实现终止，则依赖于AM提供的`halt()`接口。而AM中`halt()`的具体实现则需要NEMU架构指令的编写。

而在GNU/Linux平台上编译能够在NEMU平台上运行的程序，就需要用到了交叉编译。步骤如下：

- 编译AM：封装成可以链接的静态库，供应用程序使用
- 编译应用程序源文件
- 编译程序依赖的运行库：确保所有应用程序依赖的库能够在目标 ISA 上运行
- 链接目标文件和库文件

阅读完毕Makefile之后，需要完成下面这个小问题。（对于我来说有点难度的）

> #####  通过批处理模式运行NEMU
>
> NEMU中实现了一个批处理模式, 可以在启动NEMU之后直接运行客户程序. 请你阅读NEMU的代码并合适地修改Makefile, 使得通过AM的Makefile可以默认启动批处理模式的NEMU.

解决思路：

- NEMU的批处理模式在`nemu/src/monitor/sdb/sdb.c`中定义

  ```C
  static int is_batch_mode = false;
  
  void sdb_set_batch_mode() {
    is_batch_mode = true;
  }
  ```

  并且在NEMU的简易调试器(Simple Debugger)主循环`sdb_mainloop()` (在`nemu/src/monitor/sdb/sdb.c`中定义)中，可以看到批处理模式如何影响执行程序的。

  ```C
  void sdb_mainloop() {
    if (is_batch_mode) {
      cmd_c(NULL);
      return;
    }
    //...
  }
  ```

- 根据上面提供的信息，要想"通过AM的Makefile可以默认启动批处理模式的NEMU"，就需要修改AM的Makefile中的启动NEMU的命令。

  直接在Makefile的编译选项`CFLAGS`中，加入批处理的宏`BATCH_MODE`

  ```makefile
  CFLAGS += -DBATCH_MODE
  ```

  这样即可根据`BATCH_MODE`是否定义来确定此程序是否为AM编译的。

  随后在函数`engine_start()`（在`nemu/src/engine/interpreter/init.c`定义）中，添加对于批处理模式的识别

  ```C
  void engine_start() {
  #ifdef CONFIG_TARGET_AM
    cpu_exec(-1);
  #else
    /* Receive commands from user. */
  #ifdef BATCH_MODE
    sdb_set_batch_mode();
  #endif
    sdb_mainloop();
  #endif
  }
  ```

  等后续编译完成后再来验证是否正确。

## 10.16

### 库函数

库函数和AM的差异:

库函数是架构无关的，在任何架构上都是通过相同的方式实现。而AM 是为具体架构设计的，通常每个架构都有自己的 AM 实现。

而库函数提供运行时环境，可以通过对AM的API进行进一步的封装, 向程序提供更方便的功能

那么如何区分一个函数应该归类为AM还是库函数呢？

答案是否依赖于具体硬件架构：如果函数涉及硬件访问（如设备寄存器、I/O 等），应该放入 AM；否则，将其归类为库函数。

具体案例看后面实践。

### 任务

- [x] RTFM`string`库函数的具体行为
- [x] 实现`abstract-machine/klib/src/string.c`中列出的字符串处理函数, 让`cpu-tests`中的测试用例`string`可以成功运行. 
- [x] RTFM`sprintf()`具体行为
- [x] 实现`abstract-machine/klib/src/stdio.c`中的`sprintf()`，实现`%s`和`%d`，并且通过单元测试`test_sprintf()`
- [x] 通过`hello-str`的测试

### 学习

- 以字节为单位索引区域`s`

  ```C
  unsigned char *p = s;
  ```

- 内存重叠：从后往前复制即可

  ```C
  unsigned char *d = dest;
  const unsigned char *s = src;
  
  *(--d) = *(--s);
  ```

- 将数字的个位转换为对应的字符串

  ```c
  char a = (num % 10) + '0';
  ```


## 10.18

今天是2024年10月18号，预计明年2月底的话，还剩120天近4个月的时间。

为什么到2月底呢，首先是为期一年的Gap时间已到，是时候检验真正的技术了。另一个则是我该为自己的承诺写下一个句号。

好，现在知道自己的准备时间后，写写自己已经完成的工作和要完成的东西吧，并且写写具体安排。

已经完成的：

- 完成了CS61A，完成时间为260h，学到了程序抽象的意义。

- 完成了csapp的lab一直到cachelab。卡了我许久，挺难受的。到现在用时296h

正在做的：

- 从今年的7月23号开始，重走南大的NEMU的PA任务，到现在用时180h。

比较有趣的是，之前我比较贪念每天的学习时长要足够，但其实平均下来，每日学习时间不超过3h。哈哈，其实慢工出细活，但是确实时间堆得不大够。

接下来，我想做的（以下均为理想情况:smile:）：

- [PA](https://nju-projectn.github.io/ics-pa-gitbook/ics2023/index.html)：截至时间为11月15号（30天）
- [CS144](https://csdiy.wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/?h=cs144)：11月15号-12月15号（30天）
- [MIT 6.S081](https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/?h=mit+6.s081)：12月15号-2025年1月25号（40天）
- [CMU 15-445：](https://csdiy.wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/15445/?h=15+445+cmu)1月25号-2月25号（30天）
- [MIT6.824](https://csdiy.wiki/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MIT6.824/?h=): 2月25号-5月1号（60天+换工作ing）

今天索性看到了[鱼皮老板的视频](https://www.bilibili.com/video/BV1Tjm5YLER4/?spm_id_from=333.337.search-card.all.click&vd_source=842936ebeedd7cce8bb2e1922b41edf1)，从一开始的java入门，到现在管理自己的十几人小团队，不得不佩服大佬的时间管理和牛逼的决心和勇气。

而我，作为一周目的天命人，有且仅有唯一的一次机会去倾注心血浇灌自己的计算机之路。能否大刀阔斧地前进呢？

雄关漫道真如铁，而今迈步从头越！

悠哉游哉，开搞开搞~

###  bug诊断的利器 - 踪迹

#### 指令执行的踪迹 - itrace

- [x] 踪迹功能 -- NEMU如何记录`inst_fetch()`取到的每一条指令的

  首先看下`build/nemu-log.txt`在执行默认程序的时候，记录的内容

  ```bash
  ^[[1;34m[src/monitor/monitor.c:29 welcome] If trace is enabled, a log file will be generated to record the trace. This may lead to a large log file. If it is not necessary, you can disable it in menuconfig^[[0m
  ^[[1;34m[src/monitor/monitor.c:32 welcome] Build time: 17:00:42, Sep 10 2024^[[0m
  0x80000000: 00 00 02 97 auipc t0, 0
  0x80000004: 00 02 88 23 sb  zero, 16(t0)
  0x80000008: 01 02 c5 03 lbu a0, 16(t0)
  0x8000000c: 00 10 00 73 ebreak
  ^[[1;34m[src/cpu/cpu-exec.c:130 cpu_exec] nemu: ^[[1;32mHIT GOOD TRAP^[[0m at pc = 0x8000000c^[[0m
  ```

  而这个记录功能，就在cpu执行一条指令的函数`exec_once()`中实现的

  ```C
  static void exec_once(Decode *s, vaddr_t pc) {
    s->pc = pc;
    s->snpc = pc;
    isa_exec_once(s);
    cpu.pc = s->dnpc;
  #ifdef CONFIG_ITRACE
    /*
    	实现的具体逻辑
    */
  #endif
  #endif
  }
  ```

  cpu执行完一条指令并更新pc后，便会根据是否设置`CONFIG_ITRACE`来做已执行指令的记录功能。

  我们单独看下具体的记录逻辑

  ```C
  #ifdef CONFIG_ITRACE
    char *p = s->logbuf;
    // log记录刚才执行指令的pc值
    p += snprintf(p, sizeof(s->logbuf), FMT_WORD ":", s->pc);
    int ilen = s->snpc - s->pc;  					// 指令的字节数
    int i;
    uint8_t *inst = (uint8_t *)&s->isa.inst.val;  // 按照字节顺序访问此指令
    for (i = ilen - 1; i >= 0; i --) {
      p += snprintf(p, 4, " %02x", inst[i]);		// 按照字节顺序打印此指令的十六进制值
    }
  
    // log加 space_len 个空格的间隔
    int ilen_max = MUXDEF(CONFIG_ISA_x86, 8, 4);
    int space_len = ilen_max - ilen;
    if (space_len < 0) space_len = 0;
    space_len = space_len * 3 + 1;
    memset(p, ' ', space_len);
    p += space_len;
    
    // log加入反汇编的结果
    /* 参数包括
    
    	p: 指向日志缓冲区的指针
      s->logbuf + sizeof(s->logbuf) - p: 指定可用的缓冲区大小
      MUXDEF(CONFIG_ISA_x86, s->snpc, s->pc): 指定程序计数器
      (uint8_t *)&s->isa.inst.val：指向当前指令的代码
      ilen:指令的字节数
    */
    void disassemble(char *str, int size, uint64_t pc, uint8_t *code, int nbyte);
    disassemble(p, s->logbuf + sizeof(s->logbuf) - p,
        MUXDEF(CONFIG_ISA_x86, s->snpc, s->pc), (uint8_t *)&s->isa.inst.val, ilen);
  #endif
  ```

  对于其中的

  ```c
  void disassemble(char *str, int size, uint64_t pc, uint8_t *code, int nbyte);
  ```

  这是一个函数声明，意味着 `disassemble` 函数在其他地方已经定义。此处的声明告诉编译器该函数的参数和返回类型，但并不提供其实现。

  而当编译器看到一个函数调用时，它会检查传递给该函数的参数类型是否与函数声明中定义的参数类型匹配。如果不匹配，编译器会发出错误提示。这有助于捕获潜在的错误，减少运行时错误的可能性。

- [x] 如何自定义输出trace？

  回顾`si`和`c`均会调用函数`cpu_exec(n)`来实现对应的功能，而差异就在`n`的大小上。

  执行一条指令`si`的时候，会打印当前执行的指令，而使用`c`执行完毕程序所有指令的时候，反而不会输出指令。

  我们探究下指令的数量如何影响trace的输出。

  1. 调用函数`cpu_exec()`：

     ```c
     g_print_step = (n < MAX_INST_TO_PRINT);
     ```

     `n`若小于`MAX_INST_TO_PRINT`，则`g_print_step`被赋值为`1`.

     `n`若大于`MAX_INST_TO_PRINT`，则`g_print_step`被赋值为`0`.

     这里可以看出，`c`会执行`cpu_exec(-1)`，而`-1`的无符号数要大于`MAX_INST_TO_PRINT`，所以会导致这个值始终为0.

  2. 调用`trace_and_difftest()`

     ```C
     if (g_print_step) { IFDEF(CONFIG_ITRACE, puts(_this->logbuf));
     ```

     这样就可以得出指令的数量`n`会影响trace的输出了。

  这是一个自定义输出trace的方法，其他方法日后用到再试。

#### 指令环形缓冲区 - iringbuf

- [x] 如何判断？

  我们看下`cpu_exec()`在执行指令的时候，对于异常状态的处理

  ```c
  // .... 
  case NEMU_END: case NEMU_ABORT:
        Log("nemu: %s at pc = " FMT_WORD,
            (nemu_state.state == NEMU_ABORT ? ANSI_FMT("ABORT", ANSI_FG_RED) :
             (nemu_state.halt_ret == 0 ? ANSI_FMT("HIT GOOD TRAP", ANSI_FG_GREEN) :
              ANSI_FMT("HIT BAD TRAP", ANSI_FG_RED))),
            nemu_state.halt_pc);
  // ....
  ```

  可以看出当前状态如果不是`NEMU_ABORT`，同时`nemu_state.halt_ret`不为0时，则会打印`HIT BAD TRAP`

  所以这个条件就是程序出错的条件。

- [x] 如何获取最近执行的若干条指令？

  在riscv-32的体系结构中，每条指令长度为4个字节。所以得知当前pc值，就可以得到上一条指令的pc值；反之，也可以得到下一条指令的pc值。得知指令的pc值后，就可以通过与`itrace`相同的办法输出这些指令了。

- [x] 环形缓冲区的数据结构属性是什么？

  带头和尾节点的链表。

- [x] 环形缓冲区的需求梳理

  如果客户程序出错，则输出环形缓冲区的内容

  如果客户程序正常，则维护环形缓冲区的内容

  根据执行指令的pc值维护缓冲区：

  - 获取当前指令信息
  - ~~获取后面的指令信息~~
  - 信息加入到环形缓冲区的尾部

- [x] 实现环形缓冲区的数据结构

  满员后，新增数据在尾部，移除的数据在前方，典型的队列

  实现思路是定义一个文件`iringbuf.c`单独存放与环形缓冲区的代码。截至晚上23点35分，写完并且测试完毕。

## 10.21	

- [x] 如何[配置](https://nju-projectn.github.io/ics-pa-gitbook/ics2023/1.3.html#%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E5%92%8C%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA)的CONFIG_ITRACE？

  通过配置`nemu/Kconfig`即可设置

#### NEMU的配置系统

开发者可以编写"配置描述文件"来描述：

- 配置选项的属性, 包括类型, 默认值等
- 不同配置选项之间的关系
- 配置选项的层次关系

#### 内存访问的踪迹 - mtrace

- [x] 在`paddr_read()`和`paddr_write()`中进行记录内存访问的踪迹
- [x] 配置Kconfig及相关文件，实现通过menuconfig来打开或者关闭mtrace.
- [ ]  （选择）实现mtrace输出的条件-监视点？

#### 函数调用的踪迹 - ftrace

需求梳理：

- 在`exec_once()`中，判断命令是否为函数相关的指令（实现`is_call_instruction`和`is_ret_instruction`）
- 如果判断为真，则打印调用或者返回的信息

- [x] 在riscv32中，函数调用和返回相关的指令是什么？

  - 调用指令：jal
  - 返回指令：jalr
  - 栈操作：sw和lw

- [x] ELF文件中符号表(symbol table)提供的函数信息有什么？

  提供了有关程序中函数和变量的重要信息。包括符号的名称、类型、绑定类型等。

- [x] 给定一个位于代码段的地址, 如何得知它位于哪一个函数呢? 

  通过符号表查询出各个函数的起始地址和占位大小，得到各函数的地址区间，判断此代码段是哪一个函数区间

- [x] 什么才能算作一个符号呢？

  - 全局变量
  - 全局函数
  - 静态变量和函数
  - 未定义符号

  这些符号因为具有链接和调试的需求，所以会出现在符号表中。

  而局部变量和静态函数则不需要出现在符号表中。

- [ ] 在Linux下编写一个Hello World程序, 编译后通过上述方法找到ELF文件的字符串表, 你发现"Hello World!"字符串在字符串表中的什么位置? 为什么会这样?

面向简历的ftrace项目的相关思考：

`cpu-exec.c`要实现的功能：

- `exec_once()`中，判断是否跟踪函数调用

  定义宏`FTRACE`。`FTRACE`如果为真，则跟踪函数调用；否则不跟踪。

- `exec_once()`中，判断指令是否调用/返回函数

  - `is_call_instruction`：是否为调用指令
  - `is_ret_instruction`：是否为函数返回指令

- 如果判断为真，则获取调用函数的地址、返回函数的地址

  - `get_call_address`：获取调用函数的目标地址
  - `get_ret_address`：获取返回函数地址（`ret`执行后，记录当前PC即可）	

- 拼装信息

  获取到上面步骤的函数地址后，需要根据地址信息获取对应函数的名称

  - `get_function_name_by_address`：根据地址信息获取对应函数的名称

## 10.22

其他需要考虑的问题

- [ ] 如何解析ELF文件？

  `man 5 elf`

- [ ] 如何从ELF文件中读取符号表和字符串表，作为后续使用？

- [ ] Makefile是如何组织程序运行起来的？

- [ ] NEMU如何在编译程序的时候，生成的ELF文件？（am-kernels/tests/cpu-tests/）

函数实现：

`nemu/src/isa/riscv32/inst.c`：

- [x] `is_call_instruction`：是否为调用指令
- [x] `is_ret_instruction`：是否为函数返回指令

`/nemu/src/cpu/ftrace/ftrace.c`

- [x] `init_ftrace`：初始化ftrace
- [x] `assemble_node_info`：将指令转换为ftrace节点信息
- [x] `trace_function_call_and_ret`：记录调用或返回指令
- [x] `print_ftrace`：输出ftrace
- [x] `destroy_ftrace`：删除ftrace

## 10.23

上面已经能获取函数的地址，那么接下来就需要根据代码段的地址，定位位于哪一个函数

此定位函数的功能为：

- 获取各个函数的地址区间（结构体保存函数信息：函数名，起始地址和结束地址）
- 判断目标地址位于哪一个函数区间
- 输出对应的函数名称

其伪代码为：

```c
char *get_function_name_by_address(符号表中所有函数信息, 目标地址){
	遍历符号表所有项 {
		if ( 起始地址 <= 目标地址 <= 结束地址) return 函数名称;
	}
	// 未查询到函数
	return NULL;	
}
```



而获取符号表信息和获取字符串表的字符，均依赖于我们对于elf文件的处理。这里需要首先学习下c语言如何解析elf文件。

这里立一个flag，这周看完前三章的《程序员的自我修养》

学习下c语言如何解析elf文件。而学习的侧重点为：

- 如何访问符号表？
- 如何访问字符串表？

## 10.24

直接学习别人的[优秀博客](https://www.cnblogs.com/nosae/p/17066439.html)

现在的问题：

- 因为对于makefile的不熟悉，无法理解如何在NEMU启动的时候，读取elf文件
- itrace、mtrace实现非常混乱-对于代码的分层不够理想- 对pa代码理解不够

为了统一管理与`CONFIG_ITRACE`有关的代码，现在将ftrace放入`nemu/src/utils/itrace.c`中进行管理

`itrace.c`的接口文档

- [x] `struct SymbolEntry`：存放优化后的符号便信息的结构体（包括符号名称，符号类型，符号开始地址和所占空间）

- [x] `void parse_elf(const char *elf_file)`：解析elf文件
- [x] `char *get_function_name_by_addres(paddr_t addr)`：查询地址`addr`的函数名称

切勿钻牛角尖。

切勿复杂化。

因为自己对于Makefile组织文件的背后机制不明确，导致走了很多弯路。我甚至不知道，将ftrace放在哪一层。

kiss！

截至10.24晚上21：39，完成ftrace编写。

回复邮件：

> ok，我借鉴了下楼主你的ftrace代码实现，按照自己的理解完成了这部分内容。
> 谢谢楼主，这次的**ftrace事故**帮助我找到了自己开发时候的问题：
>
> 1. 对NEMU的运行参数不了解：我甚至不知道monitor的parse_args启动条件，是在哪里定义实现的，就更不必说如何获取elf文件了
> 2. 喜欢闭门造车，这个ftrace问题卡了我三天我才找的博客去解决自己的问题，真的太难受了😥
>
> 面对这些问题，我应该做出一些改变。这些，就让我慢慢思考吧~
> 总之，非常感谢楼主的博客！帮了我太多了！！

由于自己对于NEMU的Makefile学习不够深入，对于很多细节不够了解，导致做了3天也没整出个所以然来。这里就贴一下这位大佬的[实现](https://www.cnblogs.com/nosae/p/17066439.html#%E5%AE%9E%E7%8E%B0ftrace)，基于自己的理解，写一写自己的实现之路。

ftrace因为涉及到监控指令执行，所以需要放在`monitor`中去实现。

在`nemu/src/monitor/`下，新建专门处理与ftrace有关的文件`ftrace.c`

- 监视器用来解析ELF文件的函数
- 译码器用来记录函数调用和返回指令信息的函数

```C
static uint32_t call_depth = 0;
static uint32_t trace_func_call_flag = 0; // Flag to determine whether to trace function calls

void parse_elf(const char *elf_file) {
  if (elf_file == NULL) {
    return;
  }
  Log("The elf file is %s\n", elf_file);
  trace_func_call_flag = 1;
  FILE *file = fopen(elf_file, "rb");
  assert(file != NULL);

  init_symtab_entrys(file);
}
void trace_func_call(paddr_t pc, paddr_t target) {
  if (trace_func_call_flag == 0) return; //No elf file
  ++call_depth;

  if (call_depth <= 2) return; // ignore _trm_init & main

  char *name  = get_function_name_by_addres(target);
  // Example output: 0x800001f8:     call [f0@0x80000010]
  ftrace_write(FMT_PADDR ": %*scall [%s@" FMT_PADDR "]\n",
    pc,
    (call_depth-3)*2, "",
    name?name:"???",
    target
  );
}

void trace_func_ret(paddr_t pc) {
  if (trace_func_call_flag == 0) return; //No elf file
  if (call_depth <= 2) return; // ignore _trm_init & main

  char *name = get_function_name_by_addres(pc);
  ftrace_write(FMT_PADDR ": %*sret [%s]\n",
    pc,
    (call_depth-3)*2, "",
    name?name:"???"
  );
    
  --call_depth;
}
```

基本函数框架确定后，下一步就需要在`nemu/src/monitor/monitor.c`中，加入解析ELF文件的函数`parse_elf`

```c
static char *elf_file = NULL;

void parse_elf(const char *elf_file);

static int parse_args(int argc, char *argv[]) {
  const struct option table[] = {
    {"elf"      , required_argument, NULL, 'e'},
  };
  int o;
  while ( (o = getopt_long(argc, argv, "-bhl:d:p:e:", table, NULL)) != -1) {
    switch (o) {
      case 'e': elf_file = optarg; break;
      default:
        printf("\t-e,--elf=FILE           elf file to be parsed\n");
    }
  }
  return 0;
}
            
void init_monitor(int argc, char *argv[]) {
  /* Initialize elf. */
  parse_elf(elf_file);
}
```

由于运行`nemu`的命令和参数是在Makefile中生成的，因此修改`$AM_HOME/scripts/platform/nemu.mk`，给`NEMUFLAGS`变量添加`-e`参数，运行模拟器时就会加上这个参数，从而一步步传入`parse_args`中进行解析

```c
NEMUFLAGS += -l $(shell dirname $(IMAGE).elf)/nemu-log.txt
NEMUFLAGS += -e $(IMAGE).elf
```

ftrace的最后一步便是在译码阶段，判断为调用或返回指令时候，调用ftrace记录函数（译码实现在`nemu/src/isa/riscv32/inst.c`）

```c
static int decode_exec(Decode *s) {
  //.....
  INSTPAT_START();
  INSTPAT("??????? ????? ????? ??? ????? 11011 11", jal     , J, { R(rd) = s->pc + 4; s->dnpc = s->pc + imm; IFDEF(CONFIG_ITRACE, {
    if (rd == 1) {  					// x1($ra): stores return value
      trace_func_call(s->pc,  s->dnpc);
      }
    })
  });

  INSTPAT("??????? ????? ????? 000 ????? 11001 11", jalr    , I, { R(rd) = s->pc + 4; s->dnpc = (src1 + imm) & ~1; IFDEF(CONFIG_ITRACE, {
    if (s->isa.inst.val == 0x00008067) { // ret: jalr x0, 0(x1)
      trace_func_ret(s->pc);
    }
  }
  )});
  INSTPAT_END();
  R(0) = 0; // reset $zero to 0
  return 0;
}
```

实现`ftrace.c`剩余的[辅助函数](https://github.com/CharlieCRX/pa/blob/pa2/nemu/src/monitor/ftrace/ftrace.c)后，ftrace实现的框架就可以运行了。

因为涉及到ELF文件的处理，所以这里按照`man 5 elf`的信息，写了一个[小程序](https://github.com/CharlieCRX/pa/blob/pa2/nemu/src/monitor/ftrace/test.c)来处理ELF文件，有兴趣的可以来看下。

## 10.25

[04 框架代码选讲1 编译运行](https://www.bilibili.com/video/BV12axjejEWV/?spm_id_from=333.999.0.0&vd_source=842936ebeedd7cce8bb2e1922b41edf1)

学习记录：

- 学习YEMU的项目构建
- NEMU的make run命令输出结果
- NEMU的makefile中各个`.mk`文件功能
- `make -nB`的结果，去掉所有目录，新增目录等功能（vim操作）
  - `:g/fixdep/d`
  - `:g/mv/d`
  - visual模式下，选中列并删除
  - 删除所有目录，仅保留文件0
  - 将空格嘎寺为换行符替换
- gcc的`-I`选项:`-I` 选项可以告诉编译器去哪个目录寻找这些头文件

- 编程 ≠ 闷头写代码（血泪教育）
- 使用工具也是编程的一部分

## 10.28

本周计划：

- [ ] 阅读`AM`的makefile
- [ ] 完成PA2所有任务



- 什么是NEMU的`native`？

  - 用Linux提供的默认运行时环境实现的AM API。用来提供真实正确的测试环境。

- 阅读相关Makefile, 尝试理解`abstract-machine`是如何生成`native`的可执行文件的

  ```makefile
  ifeq ($(wildcard $(shell which $(CC))),)
    $(info #  $(CC) not found; fall back to default gcc and binutils)
    CROSS_COMPILE :=
  endif
  ```

  如果没有指定交叉编译器就会这样做。

- 为什么定义宏`__NATIVE_USE_KLIB__`之后就可以把`native`上的这些库函数链接到klib? 这具体是如何发生的? 尝试根据你在课堂上学习的链接相关的知识解释这一现象.

- 如何编写可移植的程序？

  - 避免假设指针大小：

    ```C
    // 不推荐
    int arr[sizeof(int)]; 
    
    // 推荐
    int arr[sizeof(int *)]; // 使用指针大小
    ```

  - **避免隐式类型转换**：确保指针的类型转换是明确的，以避免潜在的问题

    ```c
    void *generic_ptr = malloc(sizeof(int));
    int *int_ptr = (int *)generic_ptr; // 明确转换
    ```

  - `size_t`是无符号类型数据。足够大以表示任何对象的大小。

### Differential Testing

DiffTest的思想理论基础： 找一个正确的实现, 跟它对比结果.

而DiffTest应用于NEMU的实践则是：NEMU相当于模拟出了一个RISC-V 32的硬件系统。所以在NEMU中运行的riscv32指令，必然在相应的RISCV32架构真机上，得到相同的结果。

而真机和NEMU执行指令的结果，又可以被状态机理论抽象为一个状态二元组`S = <R, M>`。这样执行指令后，观察两个系统的状态是否一致，即可得知是否指令执行后得到了正确的结果。

思考：真机上如何才能正确运行编译到`riscv32-nemu`架构的AM程序？

> 答：
>
> 首先理解：编译到`riscv32-nemu`架构的AM程序。
>
> NEMU 是一个模拟器，专门实现了 RISC-V 32 的指令集，而 AM 则是在这个基础上为程序提供统一的运行时环境。AM 的实现依赖于 NEMU 提供的硬件功能，允许程序在不同的 RISC-V 32 实现上运行。
>
> 这句话的意思，就是在`riscv32-nemu`架构的硬件基础上实现的AM库，并通过此AM库提供运行环境的程序。这里想编译此程序，需要有两个前提：一个是实现了`riscv32-nemu`架构的NEMU硬件模拟器；另一个则是基于此架构实现的AM。
>
> 综上理解：只有真机使用RISCV32的ISA并且基于此架构实现了AM库，才能正确运行`riscv32-nemu`架构的AM程序。而在这里REF
>
> 真机则是另一个模拟RISCV32架构的全系统模拟器。

- 实现`isa_difftest_checkregs()`函数, 把通用寄存器和PC与从DUT中读出的寄存器的值进行比较

  ```c
  bool isa_difftest_checkregs(CPU_state *ref_r, vaddr_t pc) {
  	rettunr false;
  }
  ```

  ~~如何根据当前pc获取NEMU寄存器的值？~~这里的`ref_r`是参考程序的cpu状态。

- RTFSC, 从中找出寄存器的成员按照某种顺序排

## 10.29

- 连接其的各个自动字段的意义是什么？（`.text`）

###  理解volatile关键字

```c
void fun() {
  extern unsigned char _end;  // _end是什么?
  volatile unsigned char *p = &_end;
  *p = 0;
  while(*p != 0xff);
  *p = 0x33;
  *p = 0x34;
  *p = 0x86;
}
```

用`-O2`编译代码后的反汇编结果

```assembly
Disassembly of section .text:

0000000000001040 <main>:
    1040: f3 0f 1e fa           endbr64
    1044: c6 05 cd 2f 00 00 00  movb   $0x0,0x2fcd(%rip)        # 4018 <_end>
    104b: 48 8d 15 c6 2f 00 00  lea    0x2fc6(%rip),%rdx        # 4018 <_end>
    1052: 66 0f 1f 44 00 00     nopw   0x0(%rax,%rax,1)
    1058: 0f b6 02              movzbl (%rdx),%eax
    105b: 3c ff                 cmp    $0xff,%al
    105d: 75 f9                 jne    1058 <main+0x18>
    105f: c6 05 b2 2f 00 00 33  movb   $0x33,0x2fb2(%rip)        # 4018 <_end>
    1066: 31 c0                 xor    %eax,%eax
    1068: c6 05 a9 2f 00 00 34  movb   $0x34,0x2fa9(%rip)        # 4018 <_end>
    106f: c6 05 a2 2f 00 00 86  movb   $0x86,0x2fa2(%rip)        # 4018 <_end>
    1076: c3                    ret
    1077: 66 0f 1f 84 00 00 00  nopw   0x0(%rax,%rax,1)
    107e: 00 00
0000000000001170 <func>:
    1170: f3 0f 1e fa           endbr64
    1174: c6 05 9d 2e 00 00 00  movb   $0x0,0x2e9d(%rip)        # 4018 <_end>
    117b: 48 8d 15 96 2e 00 00  lea    0x2e96(%rip),%rdx        # 4018 <_end>
    1182: 66 0f 1f 44 00 00     nopw   0x0(%rax,%rax,1)
    1188: 0f b6 02              movzbl (%rdx),%eax
    118b: 3c ff                 cmp    $0xff,%al
    118d: 75 f9                 jne    1188 <func+0x18>
    118f: c6 05 82 2e 00 00 33  movb   $0x33,0x2e82(%rip)        # 4018 <_end>
    1196: c6 05 7b 2e 00 00 34  movb   $0x34,0x2e7b(%rip)        # 4018 <_end>
    119d: c6 05 74 2e 00 00 86  movb   $0x86,0x2e74(%rip)        # 4018 <_end>
    11a4: c3                    ret

```

这段反汇编代码分析：

- 代码首先将 `_end` 地址（`0x4018`）处的值设置为 `0`
- 之后的 `while` 循环检查 `_end` 的值是否为 `0xff`，如果不是则继续等待。
- 接下来的 `movb` 指令将 `0x33`、`0x34` 和 `0x86` 分别写入 `_end` 地址处

然后尝试去掉代码中的`volatile`关键字, 重新使用`-O2`编译后的反汇编结果

```assembly
Disassembly of section .text:

0000000000001040 <main>:
    1040: f3 0f 1e fa           endbr64
    1044: c6 05 cd 2f 00 00 00  movb   $0x0,0x2fcd(%rip)        # 4018 <_end>
    104b: eb fe                 jmp    104b <main+0xb>
    104d: 0f 1f 00              nopl   (%rax)
    
0000000000001140 <func>:
    1140: f3 0f 1e fa           endbr64
    1144: c6 05 cd 2e 00 00 00  movb   $0x0,0x2ecd(%rip)        # 4018 <_end>
    114b: eb fe                 jmp    114b <func+0xb>
```

这样就会导致无限循环。

`volatile` 关键字在 C 和 C++ 中用于修饰变量，主要作用是告诉编译器该变量的值可能会在程序的其他部分被意外改变，因此编译器不应该对它进行优化。

可以看出，`volatile`关键字的存在，让编译后的程序，任何时候访问该变量`_end`时都必须直接从内存中读取。

> 那么思考一下, 如果代码中`p`指向的地址最终被映射到一个设备寄存器, 去掉`volatile`可能会带来什么问题?
>
> 设备寄存器即使改变了其中的值，从而满足了循环结束条件`*p == 0xff`，也不会被检测到。因为这段检测比较代码直接被优化掉了。
>
> 例如`p`指向的是显卡温控寄存器。温控设备会在监测到显卡温度为90摄氏度以后，在温控寄存器中生成一个`0xff`的警告信息。而我们的这段代码正好就是为了检测到显卡温度超标后，进行一系列的冷却措施。如果不用`volatile`关键字修饰指向温控寄存器的指针`p`，那么显卡就算是烧掉，CPU也不会知道。

## 10.30

- IOE(I/O Extension)：因为设备访问的具体实现是架构相关的，设备访问这一架构相关的功能, 应该归入AM中.

### 宏`AM_DEVREG`解析

```c
#define AM_DEVREG(id, reg, perm, ...) \
  enum { AM_##reg = (id) }; \
  typedef struct { __VA_ARGS__; } AM_##reg##_T;
```

- `enum { AM_##reg = (id) };`：

  代码定义了一个枚举类型，其中包含一个值 `AM_##reg`，其值为传入的 `id`。`##` 是预处理器操作符，用于连接标识符。例如，如果 `reg` 是 `UART_CONFIG`，则生成的枚举项为 `AM_UART_CONFIG`，其值为 `1`。

- `typedef struct { __VA_ARGS__; } AM_##reg##_T;`:

  这行代码定义了一个结构体类型，其中包含了可变参数部分 `__VA_ARGS__`，并将该结构体命名为 `AM_##reg##_T`。这样，如果 `reg` 是 `UART_CONFIG`，则生成的结构体名为 `AM_UART_CONFIG_T`。

**具体例子分析：**

```c
AM_DEVREG( 1, UART_CONFIG,  RD, bool present);
```

参数

- ID：`1`
- 寄存器名称：`UART_CONFIG`
- 权限：`RD`
- 可变参数：`bool present;`

生成的代码

```C
enum { AM_UART_CONFIG = 1;}
typedef struct { bool present; } AM_UART_CONFIG_T;
```

**总结**：

- `AM_DEVREG` 宏用于定义设备寄存器的 ID 和结构体，简化了代码的书写
- 在宏定义中可以用`##`运算符把前后两个预处理Token连接成一个预处理Token
- 在宏定义中，可变参数的部分用`__VA_ARGS__`表示，实参中对应`...`的几个参数可以看成一个参数替换到宏定义中`__VA_ARGS__`所在的地方
- 在宏定义中，`#`号作为一个预处理运算符,可以把记号转换成字符串

### 宏`AM_KEYS`解析

```c
#define AM_KEYS(_) \
  _(ESCAPE) _(F1) _(F2) _(F3) _(F4) _(F5) _(F6) _(F7) _(F8) _(F9) _(F10) _(F11) _(F12) \
//....

#define AM_KEY_NAMES(key) AM_KEY_##key,
enum {
  AM_KEY_NONE = 0,
  AM_KEYS(AM_KEY_NAMES)
};
```

`AM_KEYS(AM_KEY_NAMES)`展开后为：

```c
AM_KEY_NAMES(ESCAPE) AM_KEY_NAMES(F1) AM_KEY_NAMES(F2) AM_KEY_NAMES(F3)...
```

`AM_KEY_NAMES(name)`展开后：

```
AM_KEY_ESCAPE , AM_KEY_F1 , AM_KEY_F2 , AM_KEY_F3 ,...
```

综上枚举展开后为

```c
enum {
  AM_KEY_NONE = 0,
  AM_KEY_ESCAPE，
  AM_KEY_F1，
  AM_KEY_F2，
  AM_KEY_F3，
  ...
};
```

### klib的`io_read()`

```c
#define io_read(reg) \
  ({ reg##_T __io_param; \
    ioe_read(reg, &__io_param); \
    __io_param; })
```

- `reg##_T __io_param;`:
  - `reg##_T` 使用了预处理器的连接符 `##`，它将参数 `reg` 和 `_T` 连接起来，形成一个新的类型名。
  - 例如传入`UART_CONFIG`，这行代码变为`AM_UART_CONFIG_T __io_param;`。而`AM_UART_CONFIG_T `在上文中是一个寄存器的结构体，这样就相当于定义了一个`AM_UART_CONFIG_T`结构体变量`__io_param`
  - `__io_param` 是一个局部变量，用于存储从寄存器读取的数据。
- `ioe_read(reg, &__io_param);`:
  - 调用`ioe_read()`，从编号为`reg`的寄存器中读出内容到缓冲区`&__io_param`中。
- `__io_param;`：
  - 这是宏的返回值。最后一行的 `__io_param` 的值将作为整个宏调用的结果返回。

**使用示例：**

```c
enum { 
	AM_UART_CONFIG = 1;
}

typedef struct {
	bool present; 
} AM_UART_CONFIG_T;

static void __am_uart_config(AM_UART_CONFIG_T *cfg)   { cfg->present = false; }

typedef void (*handler_t)(void *buf);

static void *lut[128] = {
	[AM_UART_CONFIG ] = __am_uart_config,
};

void ioe_read (int reg, void *buf) { ((handler_t)lut[reg])(buf); }

#define io_read(reg) \
  ({ reg##_T __io_param; \
    ioe_read(reg, &__io_param); \
    __io_param; })

int main(){
    AM_UART_CONFIG_T uart_data = io_read(AM_UART_CONFIG);
    //...
}
```

则`main`函数中的`io_read(AM_UART_CONFIG)`会被翻译为

1. 首先展开`io_read(AM_UART_CONFIG)`

   ```
    AM_UART_CONFIG_T uart_data = {
    	AM_UART_CONFIG_T __io_param;
    	ioe_read(AM_UART_CONFIG, &__io_param);
    	__io_param;
    }
   ```

2. 接下来就是展开`ioe_read(AM_UART_CONFIG_T, &__io_param)`

   在这个函数中，`reg` 是 `AM_UART_CONFIG`（值为 1），所以 `lut[1]` 会查找到 `__am_uart_config` 函数。

   ```c
    AM_UART_CONFIG_T uart_data = {
    	AM_UART_CONFIG_T __io_param;
    	{ 
    		((handler_t)lut[AM_UART_CONFIG_T])(&__io_param); 
    	};
    	__io_param;
    }
   ```

3. 再将里面的`lut[AM_UART_CONFIG_T]`展开为`__am_uart_config`

   ```c
    AM_UART_CONFIG_T uart_data = {
    	AM_UART_CONFIG_T __io_param;
    	{ 
    		((handler_t) __am_uart_config)(&__io_param); 
    	};
    	__io_param;
    }
   ```

4. 最后调用函数`__am_uart_config(&__io_param)`

   ```c
    AM_UART_CONFIG_T uart_data = {
    	AM_UART_CONFIG_T __io_param;
    	{ 
    		__io_param->present = false; 
    	};
    	__io_param;
    }
   ```

5. 返回值

   最后，宏的返回值是 `__io_param`，即 `uart_data` 将被赋值为 `__io_param`，该结构体的 `present` 字段被设置为 `false`。

疑问：

- `(handler_t)`的使用方法
- `static void *lut[128]`是什么数组

**总结**：

1. `handler_t` 定义：

   ```c
   typedef void (*handler_t)(void *buf);
   ```

   这表示`handler_t`是一个指向函数的指针类型。

   在 `ioe_read` 函数中，使用 `((handler_t)lut[reg])(buf);` 的目的是调用存储在 `lut` 数组中的函数指针。数组 `lut` 中的每个元素都应该是一个指向符合 `handler_t` 类型的函数。

2. `static void *lut[128]` 是一个静态数组，用于存储指向不同处理函数的指针，便于根据寄存器标识快速查找和调用相应的处理函数

### 串口

**NEMU串口如何输出字符**

首先看下，在`AM`中，输出一个字符做了什么？

1. `am-kernels/kernels/hello/hello.c`：调用`AM`的`TRM`部分定义的`putch()`函数输出字符

2. `abstract-machine/am/src/platform/nemu/trm.c`：调用针对`riscv`架构的数据写入指令`outb()`

   ```c
   void putch(char ch) {
     outb(SERIAL_PORT, ch); // SERIAL_PORT = (DEVICE_BASE + 0x00003f8) 
     //abstract-machine\am\src\platform\nemu\include\nemu.h
   }
   ```

   而`SERIAL_PORT`（在`abstract-machine\am\src\platform\nemu\include\nemu.h`定义）为

   ```c
   #define DEVICE_BASE 0xa0000000
   #define SERIAL_PORT = (DEVICE_BASE + 0x00003f8) 
   ```

3. `am/src/riscv/riscv.h`：定义`outb()`为

   ```c
   void outb(uintptr_t addr, uint8_t  data) { *(volatile uint8_t  *)addr = data; }
   ```

   即将`addr`处的一个字节保存数据`data`

所以运行在特定架构`riscv32-nemu`的`AM`中，调用函数`putch()`输出一个字符的结果，是将一个字符保存到地址为`0x0xa00003f8`的空间中。

然后我们再看下NEMU对于串口硬设备的管理（在`nemu/src/device/serial.c`中定义）

从串口初始化函数`init_serial()`可以得知的几个信息:

- 注册`0x3F8`处长度为8个字节的端口
- 注册`0xa00003F8`处长度为8字节的MMIO空间
- 两个注册都会映射到串口的数据寄存器`serial_base`

串口初始化函数，说明串口数据寄存器，会被映射到内存地址为`0xa00003F8`处。而此地址恰好是基于`riscv32-nemu`的AM输出字符时，将字符保存起来的地址。

综上所述，在NEMU运行的程序，输出一个字符的步骤为：

- 调用AM的`TRM`模块提供的字符输出函数`putch()`
- `putch()`的实现依赖于架构`riscv32-nemu`，具体实现就是通过`outb()`将字符保存到串口数据寄存器中

而串口数据寄存器拿到字符后，则会执行相应的逻辑将字符打印。这就是输出一个字符的流程。

**可变参数函数的处理**

```c
#include <stdio.h>
#include <stdarg.h>

// 示例函数，计算传入的整数之和
int sum(int count, ...) {
    va_list args;       // 定义可变参数列表
    va_start(args, count); // 初始化 args，count 是最后一个固定参数

    int total = 0;
    for (int i = 0; i < count; i++) {
        total += va_arg(args, int); // 获取下一个参数，类型为 int
    }

    va_end(args); // 清理 va_list
    return total;
}

int main() {
    int result = sum(4, 1, 2, 3, 4); // 计算 1 + 2 + 3 + 4
    printf("Sum: %d\n", result); // 输出结果
    return 0;
}
```

- 使用 `va_start(args, count);` 初始化 `args`，以便可以从函数参数中获取可变参数。`count` 是最后一个固定参数。
- 使用循环和 `va_arg(args, int)` 获取可变参数。`va_arg` 将返回下一个参数，参数类型由第二个参数指定（在这里是 `int`）。
- 使用 `va_end(args);` 清理 `va_list`，释放相关资源。

**关于sprintf()和printf()的功能思考**

```c
int sprintf(char *out, const char *fmt, ...);
```

- 处理格式化字符串
- 将格式化字符串传入到`out`区域
- 返回字符的数量

```c
int printf(const char *fmt, ...);
```

- 处理格式化字符串
- 将格式化字符串传入到串口
- 返回字符的数量

所以两者耦合的部分是处理格式化字符串的处理的代码和获取字符的数量代码。

处理格式化字符串的代码可以抽象为一个函数：

```c
int process_format_string(char *out, const char *fmt, va_list args);
```

此函数输入字符串输出的缓冲区指针`out`，格式化字符串`fmt`以及对应的可变参数`args`；输出处理格式化逻辑后的字符串的长度。函数具体实现放在[这里](https://github.com/CharlieCRX/pa/blob/pa2/abstract-machine/klib/src/stdio.c)

## 10.31

### 时钟

解析`nemu\src\device\timer.c`

- `init_timer()`将时钟设备注册到映射结构体数组`map[]`中。注册后的时钟设备的映射参数:
  - `name`：时钟设备映射的名字`rtc`
  - `low`：映射的起始地址，为`CONFIG_RTC_MMIO`(0xa0000048)
  - `high`：映射的结束地址，为`CONFIG_RTC_MMIO + 8`(0xa000004f)
  - `space`：映射的目标空间为时钟数据寄存器`rtc_port_base`
  - `callback`：回调函数`rtc_io_handler`
- `rtc_io_handler()`：读取AM系统64位的启动时间，并将其写入到`rtc_port_base`的8个字节中。

当CPU访问地址`[0xa0000048, 0xa000004f]`的时候（调用`map_read()`），会调用函数`rtc_io_handler()`，然后时钟数据寄存器`rtc_port_base`将启动时间记录下来，相当于访问时钟进行状态的更新。

当程序获取系统启动时间流程：

1. 调用klib中提供的`io_read()`宏，访问时钟设备`AM_TIMER_UPTIME`保存的启动时间信息。

2. `io_read`使用AM提供的设备访问函数`ioe_read()`，访问编号为`AM_TIMER_UPTIME`所代表的时钟设备

   ```c
   enum { AM_TIMER_UPTIME = 6};
   typedef struct { uint64_t us; } AM_TIMER_UPTIME_T
       
   uint64_t io_read(AM_TIMER_UPTIME) 
     ({ AM_TIMER_UPTIME_T __io_param; 
       ioe_read(AM_TIMER_UPTIME, &__io_param); 
       __io_param; })
   ```

3. `ioe_read()`调用时钟对应的函数`__am_timer_uptime`（在`abstract-machine\am\src\platform\nemu\ioe\timer.c`定义）

   ```c
   void __am_timer_uptime(&__io_param) {
       __io_param->us = 0; //TODO
   }
   ```

基于`riscv32-nemu`的AM，可以通过MMIO的方式，在内存`0xa0000048`处访问到映射到时钟数据寄存器的数据。

需要注意三个点为

1. nemu的时钟设备用两个32位的寄存器`rtc_port_base[2]`保存一个64位的时间数据

   ```c
   uint64_t us = get_time();
   rtc_port_base[0] = (uint32_t)us;	// 0xa0000048 存放us低32位
   rtc_port_base[1] = us >> 32;		// 0xa000004C 存放us高32位
   ```

   所以我们可以读取两次4字节的数据，然后组装时间数据。

2. 基于riscv的数据读取长度为4个字节的指令为`inl`（在`abstract-machine\am\src\riscv\riscv.h`定义）

   ```c
   static inline uint32_t inl(uintptr_t addr) { return *(volatile uint32_t *)addr; }
   ```

3. 时钟数据寄存器映射到内存的地址为`CONFIG_RTC_MMIO`（在`abstract-machine\am\src\platform\nemu\include\nemu.h`定义）

   ```c
   #define RTC_ADDR        (DEVICE_BASE + 0x0000048)
   ```

基于上面的认识，实现`AM_TIMER_UPTIME`的功能：

```c
void __am_timer_uptime(AM_TIMER_UPTIME_T *uptime) {
  uint64_t us = 0;
  uint32_t us_high = inl(RTC_ADDR + 4);
  uint32_t us_low  = inl(RTC_ADDR);
  us = (uint64_t)us_low | ((uint64_t)us_high << 32);
  uptime->us = us;
}
```

运行测试（分析参数`mainargs`如何影响程序执行的？）

```makefile
make ARCH=riscv32-nemu run mainargs='t'
```

运行后发现有浮点溢出，经过检查发现更新时钟数据寄存器的细节：

```c
static void rtc_io_handler(uint32_t offset, int len, bool is_write) {
  assert(offset == 0 || offset == 4);
  if (!is_write && offset == 4) {
    uint64_t us = get_time();
    rtc_port_base[0] = (uint32_t)us;
    rtc_port_base[1] = us >> 32;
  }
}
```

### 键盘

`abstract-machine/am/include/amdev.h`中为键盘的功能定义了一个抽象寄存器:

- `AM_INPUT_KEYBRD`, AM键盘控制器, 可读出按键信息. `keydown`为`true`时表示按下按键, 否则表示释放按键. `keycode`为按键的断码, 没有按键时, `keycode`为`AM_KEY_NONE`

当CPU访问键盘数据寄存器的流程是什么？（与时钟类似）

1. 调用klib中提供的`io_read()`宏，访问AM键盘控制器`AM_INPUT_KEYBRD`中保存的按键信息

2. 宏展开使用AM提供的设备访问函数`ioe_read()`，访问编号为`AM_INPUT_KEYBRD`所代表的键盘控制器

   ```c
   enum { AM_INPUT_KEYBRD = (8) }; 
   typedef struct { bool keydown; int keycode; } AM_INPUT_KEYBRD_T;
       
   uint64_t io_read(AM_INPUT_KEYBRD) 
     ({ AM_INPUT_KEYBRD_T __io_param; 
       ioe_read(AM_INPUT_KEYBRD, &__io_param); 
       __io_param; })
   ```

3. `ioe_read()`调用获取键盘控制器信息的函数`__am_input_keybrd`（在`abstract-machine\am\src\platform\nemu\ioe\input.c`中定义）

我们要想实现读取键盘的数据，就要看下基于NEMU架构的键盘数据寄存器是怎么实现的（在`nemu\src\device\keyboard.c`中定义）

```c
static uint32_t *i8042_data_port_base = NULL;

static void i8042_data_io_handler(uint32_t offset, int len, bool is_write) {
  assert(!is_write);
  assert(offset == 0);
  i8042_data_port_base[0] = key_dequeue();
}
```

当访问键盘数据寄存器的时候，键盘控制器会在读命令的状态下，从维护的按键队列中读取一个4字节的数据。而

键盘事件的维护是通过键盘控制器的函数`send_key()`实现的：

```c
#define KEYDOWN_MASK 0x8000

void send_key(uint8_t scancode, bool is_keydown) {
  // NEMU在正常状态`NEMU_RUNNING`运行并且键入的扫描码`scancode`在键盘映射表`keymap`中对应有效的键值。
  if (nemu_state.state == NEMU_RUNNING && keymap[scancode] != NEMU_KEY_NONE) {
    // 构造一个扩展的扫描码 am_scancode
    uint32_t am_scancode = keymap[scancode] | (is_keydown ? KEYDOWN_MASK : 0);
    // 写入键盘事件队列
    key_enqueue(am_scancode);
  }
}
```

- `scancode`：表示键事件的原始扫描码。
- `is_keydown`：布尔值，指示此事件是按下（true）还是抬起（false）
- 构造拓展的扫描码
  - `keymap[scancode]` 取出对应的键值
  - 如果 `is_keydown` 为 `true`，则按下的键会被加上这个掩码，表示这是一个按下事件；如果为 `false`，则是抬起事件。
  - 使用位运算将 `KEYDOWN_MASK`（用于标识按键按下的状态，在NEMU中为`0x8000`）与 `keymap[scancode]` 结合。

这样键盘数据寄存器中保存的一个键盘事件，就是一个拓展后的4字节扫描码数据。按照构造扫描码的逻辑，通过一个键盘事件，获取键值`keycode`和判断是否按键按下的信息逻辑为：

```c
// 获取一个键盘事件
uint32_t k = key_dequeue();

bool keydown = (k & KEYDOWN_MASK ? true : false);
uint32_t keycode = k &  ~KEYDOWN_MASK;
```

### VGA	

从NEMU进行vga设备的初始化流程：

```c
#define SCREEN_W 400
#define SCREEN_H 300

static uint32_t screen_width() {
  return SCREEN_W;
}

static uint32_t screen_height() {
  return SCREEN_H;
}

static uint32_t screen_size() {
  return screen_width() * screen_height() * sizeof(uint32_t);
}

void init_vga() {
  // 初始化VGA显示控制器数据，将 vgactl 的控制寄存器映射到内存地址[0xa0000100,0xa0000108]
  vgactl_port_base = (uint32_t *)new_space(8);
  vgactl_port_base[0] = (screen_width() << 16) | screen_height();
  
  add_mmio_map("vgactl", CONFIG_VGA_CTL_MMIO, vgactl_port_base, 8, NULL);

  // 分配显示内存.将 vmem 映射到内存地址[0xa1000000， 0xa1000008]
  vmem = new_space(screen_size());
  add_mmio_map("vmem", CONFIG_FB_ADDR, vmem, screen_size(), NULL);
  init_screen();
  memset(vmem, 0, screen_size());
}
```

本节要实现两个关于GPU的抽象寄存器（与NEMU输出设备VAG关联）：

- `AM_GPU_CONFIG`, AM显示控制器信息, 可读出屏幕大小信息`width`和`height`. 
- `AM_GPU_FBDRAW`, AM帧缓冲控制器, 可写入绘图信息, 向屏幕`(x, y)`坐标处绘制`w*h`的矩形图像. 图像像素按行优先方式存储在`pixels`中, 每个像素用32位整数以`00RRGGBB`的方式描述颜色. 若`sync`为`true`, 则马上将帧缓冲中的内容同步到屏幕上.

首先分析`AM_GPU_CONFIG`寄存器需要的数据在VGA的哪些寄存器中：

```C
typedef struct { bool present, has_accel; int width, height, vmemsz; } AM_GPU_CONFIG_T;
```

- `width`：  屏幕宽度	-->  VGA显示控制器寄存器`vgactl_port_base`的`screen_width`
- `height`：屏幕高度        --> VGA显示控制器寄存器`vgactl_port_base`的`screen_height`
- `vmemsz`：显存大小        --> 显存`vmem`的`screen_size`

```c
void __am_gpu_config(AM_GPU_CONFIG_T *cfg) {
  *cfg = (AM_GPU_CONFIG_T) {
    .present = true, .has_accel = false,
    .width = 0, .height = 0,
    .vmemsz = 0
  };
}
```

再分析`AM_GPU_FBDRAW`的逻辑，看下VGA同步寄存器在哪里：

```C
#define SYNC_ADDR (VGACTL_ADDR + 4)

void __am_gpu_fbdraw(AM_GPU_FBDRAW_T *ctl) {
  if (ctl->sync) {
    outl(SYNC_ADDR, 1);
  }
}
```

结合VGA部分刷新屏幕的代码`vga_update_screen`：

```c
void vga_update_screen() {
  // TODO: call `update_screen()` when the sync register is non-zero,
  // then zero out the sync register
}
```

可以推断出VGA同步寄存器存在于VGA显示控制器上，且位于高4字节。映射于内存位置为`[0xa0000104,0xa0000108]`。
