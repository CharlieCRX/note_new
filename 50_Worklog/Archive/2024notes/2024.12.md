# 12月

按图索骥

## 12.2

- `LD_PRELOAD`机制动态加载共享库`native.so`
- 

# navy native报错问题

在[Navy作为基础设施](https://nju-projectn.github.io/ics-pa-gitbook/ics2023/3.5.html#navy%E4%BD%9C%E4%B8%BA%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD)一节，按照材料在`bmp-test`中以native的架构编译，报错：

```bash
crx@ubuntu:bmp-test$ make ISA=native run
# Building bmp-test-run [native]
+ CC main.c
# Building libbmp-archive [native]
+ AR -> build/libbmp-native.a
# Building libndl-archive [native]
+ AR -> build/libndl-native.a
+ LD -> build/bmp-test-native
make -C /home/crx/study/ics2023/navy-apps/libs/libos ISA=native
make[1]: Entering directory '/home/crx/study/ics2023/navy-apps/libs/libos'
make[1]: 'build/native.so' is up to date.
make[1]: Leaving directory '/home/crx/study/ics2023/navy-apps/libs/libos'
fopen /home/crx/.Xauthority
fopen /home/crx/.Xauthority
fopen /usr/share/X11/locale/locale.alias
fopen /usr/share/X11/locale/locale.dir
fopen /usr/share/X11/locale/C/XLC_LOCALE
fopen /usr/share/X11/locale/locale.alias
fopen /usr/share/X11/locale/locale.dir
fopen /usr/share/X11/locale/C/XLC_LOCALE
fopen /usr/share/X11/locale/locale.alias
fopen /usr/share/X11/locale/locale.alias
fopen /usr/share/X11/locale/locale.dir
fopen /usr/share/X11/locale/en_US.UTF-8/XLC_LOCALE
fopen /usr/share/X11/locale/compose.dir
fopen /usr/share/X11/locale/en_US.UTF-8/Compose
fopen /usr/share/X11/locale/compose.dir
fopen /usr/share/X11/locale/en_US.UTF-8/Compose
fopen /home/crx/.config/ibus/bus/24fa3038f5d44ec3af0cbf8818f6394d-localhost-10
fopen /share/pictures/projectn.bmp
Redirecting file open: /share/pictures/projectn.bmp -> /home/crx/study/ics2023/navy-apps/fsimg/share/pictures/projectn.bmp
fp is a82b7e00
canvas width:128, height:128
fopen /proc/dispinfo
bmp-test-native: /home/crx/study/ics2023/navy-apps/libs/libndl/NDL.c:65: NDL_GetDisplayInfo: Assertion `fp' failed.
Aborted (core dumped)
make: *** [/home/crx/study/ics2023/navy-apps/scripts/native.mk:9: run] Error 134

```

报错很明显指向了`navy-apps/libs/libndl/NDL.c`中的`NDL_GetDisplayInfo()`函数。查看此函数

```C
void NDL_GetDisplayInfo(int *width, int *height) {
  FILE *fp = fopen("/proc/dispinfo", "r");
  assert(fp);

  // 建立两个键值对存放高度和宽度
  KeyValuePair pairs[2];
  //...
```

报错原因就是没有读取到`/proc/dispinfo`。

那么native中如何读取文件`/proc/dispinfo`的呢？

## native.so

看材料对于库函数的引用规则：

> 我们在Navy中提供了一个特殊的ISA叫`native`来实现上述的解耦, 它和其它ISA的不同之处在于:
>
> - 链接时绕开libos和libc(Newlib), 让应用程序直接链接Linux的glibc
> - 通过一些Linux native的机制实现`/dev/events`, `/dev/fb`等特殊文件的功能 (见`navy-apps/libs/libos/src/native.cpp`)

从材料中可以看出，native程序中，`NDL_GetDisplayInfo()`函数会绕开Navy提供的libc，转而使用linux的glibc的库函数`fopen()`。

我们看下关于native的makefile`navy-apps/scripts/native.mk`，看看当我们使用`ISA=native`编译程序的时候，程序是怎么编译起来的

```makefile
LD = $(CXX)

### Run an application with $(ISA)=native

env:
	$(MAKE) -C $(NAVY_HOME)/libs/libos ISA=native

run: app env
	@LD_PRELOAD=$(NAVY_HOME)/libs/libos/build/native.so $(APP) $(mainargs)

gdb: app env
	@gdb -ex "set environment LD_PRELOAD $(NAVY_HOME)/libs/libos/build/native.so" --args $(APP) $(mainargs)

.PHONY: env run gdb

```

这个`native.mk`的工作为：

- 将`LD`变量设置为`$(CXX)`，即将 C++ 编译器（`g++`）作为链接器

- `env` 规则：构建native的共享库`native.so`

  在`$(NAVY_HOME)/libs/libos`下执行`make`，并将`ISA=native`作为参数传递。

  构建`native`共享库的相关Makefile（在`navy-apps/libs/libos/Makefile`中定义）

  ```makefile
  ifeq ($(ISA), native)
  build/native.so: src/native.cpp
  	mkdir -p build/
  	g++ -std=c++11 -O1 -fPIC -shared -o build/native.so src/native.cpp -ldl -lSDL2
  ```

- `run`规则：用于运行应用程序，同时将 `LD_PRELOAD` 环境变量设置为 `$(NAVY_HOME)/libs/libos/build/native.so`，从而加载该共享库。这里用到了 `LD_PRELOAD` 机制，动态地加载共享库 `native.so`

这样native通过将`native.cpp`的编译结果作为动态链接库，从而绕开了libos和libc.

## fopen的流程

在`NDL_GetDisplayInfo()`中调用的`fopen()`，也是由`native.so`提供的。看下native如何实现的`fopen()`

```C
FILE *fopen(const char *path, const char *mode) {
  char newpath[512];
  if (glibc_fopen == NULL) {
    glibc_fopen = (FILE*(*)(const char*, const char*))dlsym(RTLD_NEXT, "fopen");
    assert(glibc_fopen != NULL);
  }
  return glibc_fopen(redirect_path(newpath, path), mode);
}
```

那么在`NDL_GetDisplayInfo`中，调用`fopen`访问文件`/proc/dispinfo`的时候，到底发生了什么？

```C
FILE *fp = fopen("/proc/dispinfo", "r");
```

此时调用动态库`native.so`中的`fopen()`函数

```C
glibc_fopen("/proc/dispinfo", "r");
```

好吧，将`NDL_GetDisplayInfo`中的`fopen`改为`open`后，即可调用成功

```c
void NDL_GetDisplayInfo(int *width, int *height) {
  int fd = open("/proc/dispinfo", O_RDONLY);
  assert(fd != -1);
  printf("NDL_GetDisplayInfo fd is %d\n", fd);

  KeyValuePair pairs[2];
  char line[256];
  ssize_t bytes_read = read(fd, line, sizeof(line) - 1);
  assert(bytes_read != -1);
  printf("Read line: %s\n", line);


  str_to_pairs(line, pairs);
  *width = get_width(pairs);
  *height = get_height(pairs);
  printf("NDL_GetDisplayInfo ok!\n");
  
}
```

但是这样虽然成功获取了屏幕大小，但是图像展示不出来。

## 12.3

不入虎穴，焉得虎子？

不要做无脑的人，要懂得客观情况和主观意识相结合。

## NDL_DrawRect

这个函数的声明是

```C
// 向画布`(x, y)`坐标处绘制`w*h`的矩形图像, 并将该绘制区域同步到屏幕上
// 图像像素按行优先方式存储在`pixels`中, 每个像素用32位整数以`00RRGGBB`的方式描述颜色
void NDL_DrawRect(uint32_t *pixels, int x, int y, int w, int h);
```

按照需求，我们可以很简单地实现这个函数

```C
void NDL_DrawRect(uint32_t *pixels, int x, int y, int w, int h) {
  // 实现居中画布
  if (x == 0 && y == 0) {
    center_canvas_on_screen(&x, &y, &w, &h);
  }
  uint32_t *line = pixels;
  // 固定画布高度，将画布的每行存储到显存中
  for (int j = 0; j < h; j++) { 
    // 确定画布每一行的初始像素 在屏幕中的偏移
    int offset = sizeof(uint32_t) * (x + (y+j)*screen_w);
    assert(lseek(fbdev, offset, SEEK_SET) != -1);

    size_t bytes_written = write(fbdev, line, w * sizeof(uint32_t));
    assert(bytes_written == w*sizeof(uint32_t));
    line += w;
  }
}
```

因为显存是行优先存储到文件`dev/fb`中的，所以这里存储图像像素的时候，也需要按照行优先存储的方式保存。例如屏幕尺寸为`400 x 300 x 32`的话，那么第二行的第三个像素在显存文件的偏移`offset`为

```C
int offset = (400 + 3) * sizeof(uint32_t);
```

- `(400+3)`：代表了第二行第三个像素在行排列的像素点中的位置。这里蕴含着二维平面到一维向量之间的转换。
- `sizeof(uint32_t)`：仅仅有位置还是不够的。因为一个像素占用空间为32位，只有`像素位置x像素大小`才是像素点一维化的偏移。

因为一直不能在native上运行`bmp-test`，我现在已经战略性放弃这个问题了。

## NSlider

### SDL_UpdateRect()

实现

```C
void SDL_UpdateRect(SDL_Surface *s, int x, int y, int w, int h) {
  NDL_DrawRect(s->pixels, x, y , w, h);
}
```

按照README提示

```tex
1. copy slides.pdf to `slides/`
2. run `convert.sh`
3. modify the variable `N` in `src/main.cpp` to the total number of the slides
```

运行`convert.sh`报错为

```bash
crx@ubuntu:slides$ sh convert.sh
convert.sh: 3: convert: not found
rm: cannot remove '/home/crx/study/ics2023/navy-apps/fsimg/share/slides/*': No such file or directory
mv: cannot stat '*.bmp': No such file or directory
```

找不到命令`convert`:这个错误表示系统找不到 `convert` 命令，它是 ImageMagick 工具包的一部分。需要安装 ImageMagick 来解决这个问题。使用以下命令按安装

```bash
sudo apt install imagemagick
```

下载完毕后

```bash
crx@ubuntu:slides$ sh convert.sh
convert-im6.q16: attempt to perform an operation not allowed by the security policy `PDF' @ error/constitute.c/IsCoderAuthorized/426.
convert-im6.q16: no images defined `slides.bmp' @ error/convert.c/ConvertImageCommand/3229.
rm: cannot remove '/home/crx/study/ics2023/navy-apps/fsimg/share/slides/*': No such file or directory
mv: cannot stat '*.bmp': No such file or directory
```

需要修改 ImageMagick 的安全策略，允许 PDF 格式的转换

1. 打开 ImageMagick 的安全策略文件（通常位于 `/etc/ImageMagick-6/policy.xml` 或 `/etc/ImageMagick-7/policy.xml`）

   ```bash
   sudo vim /etc/ImageMagick-6/policy.xml
   ```

2. 在文件中找到类似以下的条目：

   ```xml
   <policy domain="coder" rights="none" pattern="PDF" />
   ```

   这行禁止了对 PDF 文件的操作。

3. 将其修改为允许 PDF 文件操作：

   ```xml
   <policy domain="coder" rights="read | write" pattern="PDF" />
   ```

4. 退出并保存

最终运行成功

### SDL_WaitEvent()

现在遇到的问题是，按上键会报错。

## 12.4

- 解决`SDL_WaitEvent()`向前按键报错问题
- 实现MENU
- 实现NTerm
- 实现Flappu Bird
- 实现PAL
- 实现am-kernels

1. `SDL_WaitEvent()`向前按键报错问题

   问题是只要获取之前打开过的图片，就会报错：

   ```bash
   // 第一张图
   SDL_LoadBMP: fname = /share/slides/slides-0.bmp
   BMP_Load: fd is 9
   
   // 按下down键的第二张图
   BSDL_WaitEvent: kd DOWN
   SDL_LoadBMP: fname = /share/slides/slides-1.bmp
   BMP_Load: fd is 6
   SDL_WaitEvent: ku DOWN
   
   // 返回第一张图
   SDL_WaitEvent: kd UP
   SDL_LoadBMP: fname = /share/slides/slides-0.bmp
   BMP_Load: fd is 9
   assertion "pixels" failed: file "/home/crx/study/ics2023/navy-apps/libs/libbmp/src/SDL_bmp.c", line 9, function: SDL_LoadBMP
   ```

   这里的问题是通过修改`BMP_Load()`在关闭打开的文件之前，将之前文件的操作位置偏移设置为0

   ```C
   void* BMP_Load(const char *filename, int *width, int *height) {
     ....
     fseek(fp, 0, SEEK_SET);
     fclose(fp);
     ...
   }
   ```

   猜测是`fclose`并没有将操作位置设置为0，从而导致读出来的字节为空。经过STFM，发现`fclose`确实不会将文件指针位置设置为0。其主要作用是

   - 关闭文件
   - 将内存中的缓冲内容写入磁盘
   - 释放与文件相关的资源（文件描述符）

   所以如果需要下次打开文件，依然从头开始读取数据的话，就需要在调用 `fclose()` 之前使用 `fseek()`

2. 实现MENU

   - `SDL_FillRect()`: 往画布的指定矩形区域中填充指定的颜色

     这个问题需要考虑当

## 12.5

现在暂停下PA3的开发进度，让我慢下来看看在开发过程中，什么比较耗费我的时间。

1. 理解材料
2. 理解代码
3. 实现代码
4. debug

首先我将会通过现阶段重新回顾PA3材料和部分代码，然后根据自己的日志，看下自己的时间记录.在遍历自己学习道路的过程中，为了让自己保持清醒，需要在遍历途中一直问自己：

- 这里讲了什么？我学到了什么？
- 这里难在哪里？需要背景知识补充吗？

OK，现在先将目光转向[PA3.1](https://nju-projectn.github.io/ics-pa-gitbook/ics2023/3.1.html)， 实现自陷操作`yield()`

### PA3.1（用时）

这部分和CSAPP的“异常”章节十分重合，可以搭配CSAPP来学习

#### 最简单的操作系统

- 批处理的作用是自动加载程序
- 批处理的两个功能：
  - 用户程序结束，跳转到OS
  - OS可以加载用户程序
- 程序之间的执行流切换
- 等级森严的制度：硬件的保护机制

开头楔子介绍批处理的出现解放了劳动力。然后论述批处理的主要两个功能就是：

- 用户程序结束，跳转到OS
- OS加载用户程序

就是这样的两个情况，就抽象出了批处理的这个操作。

而我们如果想要实现批处理，本质上是通过实现程序之间的执行流切换。这里用到了执行流的背景概念。简单理解就是CPU执行程序内的指令序列的时候，一个执行序列就是一个执行流。PC通过指向不同指令的地址，从而让CPU取到不同的指令并执行。

而材料也提出，批处理系统实现的不同程序之间的执行流切换，不能简单地用call和jal指令。而需要一种受限制的执行流切换方式来实现程序之间的执行流切换。这种限制方式普通的程序不能实现。

然后提出为了限制执行流的切换，硬件提供了保护机制的相关措施来支持此功能。例如在riscv硬件中，设置了M,S,U三种权限等级，来限制每一个层级的操作。高等级M可以访问低等级S、U的所有资源。如何判断一个指令是否处在这个等级之内的方法也很简单：设置一个特权寄存器，每次执行特权指令的时候，进行权限等级判断即可。

而在NEMU中，我们简化了这种硬件保护的机制，默认所有进程都运行在M最高级上。（用时30分钟）

####  穿越时空的旅程

到了这部分的时候，背景知识的重要性就比较大了。需要将PA材料中介绍的背景知识理解了，才能看懂这部分要做什么。

背景知识：

- 异常响应机制-举例RISCV3硬件的`ecall`
- riscv32触发异常后硬件的异常响应过程
- OS实现异常处理后如何恢复程序的状态
- 加入异常响应机制后的状态机如何扩充？
  - 扩充系统寄存器SR
  - 虚构的指令`raise_intr`代表什么意思？
  - `raise_intr`在riscv32硬件的操作流程

那么我们总结下这部分的内容。

为了限制执行流的切换，硬件提供了保护机制。但是硬件也给软件提供了一个受限制的入口来进行执行流的切换操作。这个受限制的入口就是自陷指令。

程序执行了自陷指令后，硬件会通过异常响应机制来来处理这个请求。而riscv32硬件的异常响应机制为：

- mepc保存PC
- mcause设置异常号
- mtvec取出异常入口地址addr
- PC <- addr

以上操作都是硬件自动完成。跳转到OS实现异常处理，处理完毕后，可以返回到触发异常之前的状态。riscv32中是通过mret来实现的。

之前的程序状态机是`S = <R,M>`，但是现在加入了异常响应机制后，需要扩充之前的状态机。

- 寄存器`R`：加入了系统寄存器`SR`,现在`R = {GPR, PC, SR}`。
- 内存不需要操作
- 状态`S`：加入了异常状态。而对状态的判断函数为`fex: S -> {0, 1}`，给定状态机的任意状态`S`，`fex(S)`都可以唯一表示当前PC指向的指令是否可以成功执行。指令执行失败(fex(S) = 1), 其行为等价于执行了虚构的`raise_intr`指令

而`raise_intr`指令的操作。就是硬件提供的异常响应机制。放在riscv32中，此指令包含了三个功能

```C
SR[mepc] <- PC
SR[mcause] <- 异常号
PC <- SR[mtvec]
```

OK，本次分析就到这里，用时1.5小时。

现在回顾下刚才PA3.1部分的学习，如果想学明白，理解透彻，需要注意的点是什么？

- 背景知识的掌握：包括执行流、异常响应机制、状态机等。这部分内容就是硬知识，是读懂这部分材料的必要概念或者前置。
- 前置知识的掌握：NEMU的CPU寄存器如何扩充（代码的掌握）

可以发现，到现在为止，我们还没开始动代码。一直停留在概念上。当时遇到这个难懂的材料的时候，涉及到许多概念的时候，我该怎么才能熟悉内容呢？

- 首先是破除材料的难点。难点包括涉及的概念（例如这一节的批处理、异常响应机制、加入异常响应机制后的状态机的转移图以及状态判断函数`fex()`的作用）和案例。这阶段的目标就是将材料中的概念理解。具体操作是：对于新的概念和描述，先记录下来
- 第二步，重读记录下来的概念，达到概念理解的状态。此时应该配合材料去理解这个概念。完成这一步后，材料中最难的背景知识部分应该是解决的差不多了
- 第三步，带着已经理解的概念重读材料，并用简洁的话将材料提炼出来。此时的要求是，一个段落最多一行描述即可。描述可以继续沿用第一步使用的笔记——将每段最重要的那段话拿出来记录。如果有能力，可以试着总结为一两句话。这一步骤的理由是，已经熟悉了概念，所以材料读起来应该是没什么困难了。这一步的目的就是提纲挈领，建立一个知识架构，为下面的知识细节补充提供框架。要求很简单，就是总结为一句话，如果总结不了，那应该就是不理解这一段的意思。
- 第四步，重读记录的框架材料和概念，再次理解这部分内容。本阶段的要求是，回答一个问题：这章讲了一个什么故事？
- 第五步，重回材料，重新阅读...

那好，现在就规定，阅读复杂材料的时候，需要按照这4个提醒事项：

1. 记录和拆解新概念。（避免思考，只是觉得不理解就摘即可）
2. 重读并理解新概念，并用自己的话描述概念
3. 将材料的每一段概括为一句话
4. 回答本章节讲了一个什么故事

今天学，明天用，当周结算

哈哈哈，感觉现在理论很充沛，那么现在我应该实践一下，检验我的理论是否能应对的了实际环境情况。那么现在就应对这个问题，学习下CSAPP的异常章节吧！接受实践的洗礼吧！

## 12.6

SDL_PollEvent:获取事件，并存储在结构体SDL_Event

- 如果当前没有任何事件, 就会立即返回0
- 如果存在事件，从队列中取出事件并将其存储到传入的 `SDL_Event` 结构体中，然后返回 `1`
- 将事件存储到结构体的方法与`SDL_WaitEvent()`类似

SDL_GetTicks：获取从SDL库初始化到现在所用的毫秒数。如果返回值达到49天（32位的最大值`0xffffffff`），则会回绕为0

- 将`NDL_GetTicks()`的返回结果对`0xffffffff`取余数即可

但是实现后，发现Nterm界面是这样的：

![18d517b3934d643e8df1854f07bc8167](E:\backup\programFile\qq\2807504409\nt_qq\nt_data\Pic\2024-12\Ori\18d517b3934d643e8df1854f07bc8167.png)

哈哈哈哈，报错了啊。为了确保我的实现没问题，我将正确实现过的大佬代码复制到这里，但是展示效果依然这样子。

老办法，还是从PA2的VGA部分入手，慢慢检查错误吧。

![image-20241206101300592](E:\backup\software\typora_image\image-20241206101300592.png)

首先先看运行`display-test`的时候，native和我们自己实现的riscv32-nemu之间的区别。可以发现，native界面中的下方和右侧均有黑色边框，而我们自己实现的并没有。

查找问题：from10:15

初始化VGA信息`init_vga()`

```C
void init_vga() {
  vgactl_port_base = (uint32_t *)new_space(8);

  vgactl_port_base[0] = (screen_width() << 16) | screen_height();

#ifdef CONFIG_HAS_PORT_IO
  add_pio_map ("vgactl", CONFIG_VGA_CTL_PORT, vgactl_port_base, 8, NULL);
#else
  add_mmio_map("vgactl", CONFIG_VGA_CTL_MMIO, vgactl_port_base, 8, NULL);
#endif

  vmem = new_space(screen_size()); // 400 * 300 = 1,D4C0
  add_mmio_map("vmem", CONFIG_FB_ADDR, vmem, screen_size(), NULL);
  IFDEF(CONFIG_VGA_SHOW_SCREEN, init_screen());
  IFDEF(CONFIG_VGA_SHOW_SCREEN, memset(vmem, 0, screen_size()));
}
```

这里卡我的地方：

- `new_space()`以及用到的宏

```C
#define PAGE_SHIFT        12
#define PAGE_SIZE         (1ul << PAGE_SHIFT) //4096
#define PAGE_MASK         (PAGE_SIZE - 1)
static uint8_t *p_space = NULL;


uint8_t* new_space(int size) {
  uint8_t *p = p_space;
  // page aligned;
  size = (size + (PAGE_SIZE - 1)) & ~PAGE_MASK; // 确保 size 是 PAGE_SIZE 的整数倍
  p_space += size;
  assert(p_space - io_space < IO_SPACE_MAX);
  return p;
}
```

- C语言的位运算：`PAGE_SIZE`以及size计算方法

  ```C
  #define PAGE_SIZE         (1ul << PAGE_SHIFT)
  size = (size + (PAGE_SIZE - 1)) & ~PAGE_MASK;
  ```

- `p_space`和`io_space`的作用

  ```C
  #define IO_SPACE_MAX (2 * 1024 * 1024)
  static uint8_t *io_space = NULL;
  static uint8_t *p_space = NULL;
  
  void init_map() {
    io_space = malloc(IO_SPACE_MAX);
    assert(io_space);
    p_space = io_space;
  }
  
  uint8_t* new_space(int size) {
    uint8_t *p = p_space;
    // page aligned;
    size = (size + (PAGE_SIZE - 1)) & ~PAGE_MASK; // 确保 size 是 PAGE_SIZE 的整数倍
    p_space += size;
    assert(p_space - io_space < IO_SPACE_MAX);
    return p;
  }
  ```

- `add_pio_map`API

  ```C
  /* device interface */
  void add_mmio_map(const char *name, paddr_t addr, void *space, uint32_t len, io_callback_t callback) {
    assert(nr_map < NR_MAP);
    paddr_t left = addr, right = addr + len - 1;
  
    // 设备注册的内存地址独立于运行程序的内存地址
    if (in_pmem(left) || in_pmem(right)) {
      report_mmio_overlap(name, left, right, "pmem", PMEM_LEFT, PMEM_RIGHT);
    }
  
    // 各个设备的所在内存空间相互独立
    for (int i = 0; i < nr_map; i++) {
      if (left <= maps[i].high && right >= maps[i].low) {
        report_mmio_overlap(name, left, right, maps[i].name, maps[i].low, maps[i].high);
      }
    }
  
    maps[nr_map] = (IOMap){ .name = name, .low = addr, .high = addr + len - 1,
      .space = space, .callback = callback };
    Log("Add mmio map '%s' at [" FMT_PADDR ", " FMT_PADDR "]",
        maps[nr_map].name, maps[nr_map].low, maps[nr_map].high);
  
    nr_map ++;
  }
  ```

- `paddr_t`

  ```C
  typedef MUXDEF(PMEM64, uint64_t, uint32_t) paddr_t;
  ```


## 12.9

new life

异常控制流

- 控制流就是CPU执行指令的序列
- 一般的控制流转移：局限于一个程序内的跳转和调用返回指令
- 异常控制流转移：处理复杂场景的控制流转移
- 从低到高的异常控制流：底层的硬件+os实现异常机制，高级异常包括进程切换、信号和非本地跳转

异常：

- 将系统事件交给内核处理的过程
- 方法：系统按照事件编号去找对应的异常处理函数

中断

- 又称为异步异常。不是执行的程序引起的事件，而是外部事件。但是可以屏蔽

同步异常

- 执行的程序导致的事件，分为陷阱、故障和终止
- 陷阱：故意的异常；故障：可能恢复的错误；终止：不可恢复的错误
- 陷阱包括系统调用和断点

系统调用

- 每个系统调用都有唯一的ID，例如x86-64的`read`系统调用的ID为0

进程：

- 进程就是在内存中的程序，貌似独享CPU和内存
- 上下文切换：切换进程之前，保存当前进程的寄存器状态以便于恢复
- 两个获取进程信息的函数：获取当前进行的PID`getpid()`和获取父进程PID的`getppid()`
- 进程被终止的三个情况：收到终止信号、main函数返回和调用`exit`函数
- 创建进程：fork，执行一次，返回两次
- 进程图：需要理解fork和代码和图示
- 父进程可以回收子进程`wait` 或 `waitpid`
- 子进程想载入其他程序，可以使用`execve`

第一部分用时30mins

信号

- 定义：内核提醒当前进程后台进程执行完毕的通知机制
- 用途：处理后台执行完毕的进程
- 常用信号代表：`SIGSEGV`编号11，代表段冲突
- 进程接收信号后的操作：1.忽略；2.终止进程（ctrl+c）；3.将信号交给特定信号处理函数（singnal handler）处理
- 一种类型的信号只能有一个待处理
- 进程属于进程组：`getpgrp()` - 返回当前进程的进程组；`setpgrp()`-设置当前进程的进程组
- 信号有默认动作，但是`signal` 函数可以修改默认的动作

并行和并发区别

- 多个程序一个CPU上同时（伪）执行：并发
- 多个程序在多个CPU上同时（真）执行：并行

非本地跳转：

- 本地跳转：在程序种使用goto语句进行跳转
- 非本地跳转：从一个函数跳转到另一个函数
- 方法：使用 `setjmp` 或 `longjmp` 
- `setjmp`：保存当前函数的上下文。返回值为0。
- `longjmp`：恢复由`setjmp`维护的上下文，这样程序就会从调用`setjmp`处重新开始执行
- 实践：跳转到其他的栈帧

用时25mins

晚间总结：

今天csapp学习了异常的相关概念。

程序内的执行流切换无非两种，一种是分支和跳转；另一种是调用和返回。但是为了响应某些的事件，例如键盘输入和ctrl+c终止程序；以及程序的缺页错误或者段错误，就需要另一种执行流切换的方式。这种特殊处理叫做异常。

异常是将事件交给内核处理的过程，实现的层级从低到高包含异常、进程切换、信号和非本地跳转。

首先异常的分类。异常事件按照是否出现于当前执行的程序内来区分同步异常和异步异常。同步异常是程序内的操作导致的，包括内陷、故障和错误。内陷是程序故意操作的，例如系统调用以及中断。而故障和错误则是无意的。故障出现后，内核可能恢复程序的故障状态，再次执行程序。但是错误出现了，程序会被终止。

另一个则是异常的处理过程。每一个异常都有一个异常号，内核的异常处理函数，会根据出现的异常号来做相应的操作。

进程是一种抽象，在运行的程序看来，自己拥有CPU和内存的使用权。进程切换的时候，需要保存当前程序的上下文，以便未来恢复程序的状态。这里介绍了几个函数：

- 获取进程信息：`getpid()`和`getppid()`
- 创建子进程：`fork()`
- 终止进程：`exit()`
- 在此进程上直接执行另一个进程`execve`

这里也介绍了进程图，但是需要配合`fork()`函数的行为来理解。

两个部分介绍完了，下一个异常就是信号了。信号是后台程序执行完毕后，内核给当前进程的一种通知。信号可以被进程忽略。进程收到信号后，有三种操作：

- 忽略
- 终止
- 交给信号处理函数处理信号

另一个异常就是非本地跳转。本地跳转就是程序在一个函数内的goto语句。非本地跳转实现了两个函数之间的跳转。这里讲了两个函数以及行为。

- `setjmp()`：执行后，会保存当前函数的状态
- `longjmp()`：执行后，会恢复由`setjmp`保存的状态，实现栈的切换。

还讲了伪并行-并发和真正的并行区别，就是同时运行的进程，如果只有一个CPU来处理，那就是并发；如果多个核心分别运行多个进程，则为并行。

晚上再学习下，进程里面相关函数的API以及进程图的概念

1. `fork()`：创建新进程，返回两次。对于父进程，返回子进程的PID，对于子进程，返回0.

   ```C
   if ((pid = fork()) < 0) {
       fprintf(stderr, "fork error: %s\n", strerror(errno));
       exit(0);
   }
   ```

   `strerror(errno)`：`strerror(errno)` 返回与当前错误码 `errno` 相关的错误信息字符串。`errno` 是一个全局变量，它存储的是上一个系统调用或库函数调用失败时的错误码。

   ```C
   void unix_error(char *msg) /* Unix-style error */
   {
       fprintf(stderr, "%s: %s\n", msg, strerror(errno));
       exit(0);
   }
   
   // 上面的片段可以写为
   if ((pid = fork()) < 0)
       unix_error("fork error");
   ```

   进一步包装`fork()`，使之自带错误处理

   ```C
   pid_t Fork(void) {
     pid_t pid;
     if ((pid = fork()) < 0) {
       unix_error("Fork error");
     }
     return pid;
   }
   ```

   `fork()`是系统调用，系统调用都有返回值。可以根据系统调用的返回值是否大于0判断系统调用是否成功。具体到C语言中，`<string.h>`库的`strerror()`函数可以将错误码包装为字符串输出。

   `<errno.h>`中的`errno`保存了最近一次系统调用或库函数调用的错误码。

   通过`strerror(errno)`可以很优雅地将系统调用的错误码转换为字符串输出。

2. 进程图

   - 关键指令用点表示
   - 变量值标记边
   - `a->b`表示a事件出现在b之前

3. `int setjmp(jmp_buf env)`和`void longjmp(jmp_buf env, int val)`

   - `setjmp()`：第一次调用返回0。如果从`longjmp`跳转回来，则返回`longjmp()`的第二个参数`val`

   ```C
   jmp_buf env;
   
   void func1() {
     printf("Inside func1\n");
     longjmp(env,  1);
   }
   
   void func2() {
     printf("Inside func2\n");
     func1();
   }
   
   void test_jmp() {
     int ret = setjmp(env);
     if (ret == 0) {
       // 第一次调用返回值为0
       printf("setjmp returned 0, calling func2\n");
       func2();
     } else {
       // 通过 longjmp 跳转回来时，ret 将为非零值
       printf("Returned from longjmp, ret = %d\n", ret);
     }
   }
   ```

## 12.10

抑制自己主动思维。

### 快速编译csapp程序步骤

发现csapp程序编译较为麻烦，特地写个脚本来处理。

现在要实现通过`c file.c`来执行两个过程：

```bash
# 1. 根据c文件名生成对应的输出文件 
gcc -I/home/crx/study/csapp/code/include /home/crx/study/csapp/code/src/csapp.c file.c -o file

# 2. 执行输出文件
./file
```

通过chatgpt的方案是，使用脚本来根据输入文件名自动生成输出文件名。

1. 创建`compile-csapp.sh`脚本

   ```
   vim ~/bin/compile-csapp.sh
   ```

2. 编辑脚本文件

   ```bash
   #!/bin/bash
   
   # 检查是否提供了源文件作为参数
   if [ $# -eq 0 ]; then
     echo "Usage: c <source_file>"
     exit 1
   fi
   
   # 获取文件名，去掉扩展名 .c
   filename=$(basename "$1" .c)
   
   # 编译源文件并链接
   gcc -I/home/crx/study/csapp/code/include /home/crx/study/csapp/code/src/csapp.c "$1" -o "$filename"
   
   # 执行生成的可执行文件
   ./"$filename"
   ```

   - `“#!”`是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。
   - `$#` 是脚本接收到的参数个数

3. 放权限

   ```bash
   chmod +x ~/bin/compile-csapp.sh
   ```

4. 确保`~/bin`在`PATH`中

   为了让系统能够识别`c`命令并执行，需要确保`~/bin`目录在`PATH` 环境变量中。

   打开 `~/.bashrc` 文件：

   ```bash
   vim ~/.bashrc
   ```

   将指令`c`与脚本`compile-csapp.sh`链接

   ```bash
   alias c="~/bin/compile-csapp.sh"
   ```

5. 刷新`./bashrc`

   ```bash
   source ~/.bashrc
   ```

此时在`/home/crx/study/csapp/code/ecf`目录执行`c fork.c`

```bash
crx@ubuntu:ecf$ c fork.c 
parent: x=0
child : x=2

crx@ubuntu:ecf$ c
Usage: c <source_file>
```

可以看到已经实现了我们想要的结果。

csapp进程部分函数学习：

创建和终止进程

- `void exit(int status)`：函数以status作为退出状态终止进程。例如

  ```C
  if (pid == 0) {
    printf("child! x = %d\n", x++);
    exit(0);
  }
  ```

- `pid_t fork(void)`：子进程返回0，父进程返回子进程的PID，如果出错返回-1.父进程和子进程是并发的

- `pid_t waitpid()`

## 12.11

做笔记的要点：

- 笔记是为了以后方便回顾的：要分层和简洁

学习C库函数

1. fgets

   ```C
   char *fgets(char *s, int size, FILE *stream)
   ```

   从`stream`中获取最多`(size - 1)`个字节的字符串，并将其保存在字符串`s`中。EOF保存在最后一个字符串中

   ```C
   #include <csapp.h>
   #define MAX_LEN 20
   void test_fgets() {
     char buf[MAX_LEN];
     while(1) {
       Fgets(buf, MAX_LEN, stdin);
       printf("input :%ssize is %ld\n", buf, strlen(buf));
   
       if(feof(stdin)) {
         exit(0);
       }
     }
   }
   
   int main() {
     test_fgets();
     return 0;
   }
   ```

   运行此程序的时候，发现

   ```bash
   crx@ubuntu:test$ c shell-test.c 
   abc123
   input :abc123
   size is 7
   1123
   input :1123
   size is 5 #-------此时按下ctrl + D，但还是输出了下面的内容
   input :1123
   size is 5
   ```


## 12.12

csapp的操作进程部分学习：

主要是对于`shellex.c`的理解。

1. fgets

   ```C
   char *fgets(char *buf, int len, FILE *stream);
   ```

   行为：从`stream`中至多读取`(len - 1)`个字符到缓冲区`buf`中。当遇到`EOF`和新行的时候才会停止读取。

   细节：

   - 记录换行符：没超出最大`len`限制，`buf`会记录换行符
   - 超出`(len - 1)`长度：截断

   返回值：返回字符串`buf`

2. feof

   ```C
   int feof(FILE *stream);
   ```

   行为：从`stream`中检验`EOF`标识符。如果文件设置了`EOF`，则返回非零值。

   原理：`FILE`的结构中，有一个变量记录文件的结束标志`EOF`.与ASCII字符终止符区别`\0`

   - EOF不存储在文件或流中，但是`\0`存储在字符串中
   - 意义不同：文件末尾和字符终止

3. strlen

   ```C
   size_t strlen(const char *s);
   ```

   返回字符串的字符数量，不包括`\0`

4. 跳过特定字符

   ```C
   char buf[] = "abc123abc";
   while(*buf && (*buf == 'a')) {
     buf++;
   }
   ```

5. strchr

   ```C
   char *strchr(const char *s, int c);
   ```

   行为：返回字符串s中，指向第一个字符c的指针

   返回值：如果没有返回NULL

6. 条件判断中的赋值行为

   ```C
   if (delim = strchr(buf, ' ')) {
   //...
   }
   ```

   `if`会根据赋值的结果`delim`来判断

7. 获取由空格分隔的命令行参数

   ```C
   while(delim = strtok(buf, ' ')) {
     argv[argc++] = buf;
     *delim = '\0';
     buf = delim + 1;
     while(*buf && (*buf == ' ')) {
       buf++;
     }
   }
   argv[argc] = NULL;
   ```

信号部分

1. 待处理信号集合实现
2. 信号处理函数`signal`的用途
3. 阻塞信号函数sigprocmask函数如何阻塞`SIGINT`信号

今晚：

1. 解决信号部分三个难题1h
2. 重写`shellex.c` 1h
3. 总结进程和信号的逻辑框架 1h
4. 学习之道第四章 30mins

**信号的分类**

按照日常微信消息来分类信号。

- 已读不回：被进程有意阻塞的信号(blocked)
- 正在回：正在处理的信号
- 还没来得及回：待处理信号(pending)

保存方式：

- pending：k信号待处理，k位置1
- blocked：k信号被阻塞，k位置1

**信号的默认行为**

- 进程终止
- 进程终止并转储内存
- 进程停止等待重启（`SIGCONT`）
- 进程忽略此信号

**修改信号默认行为**

自定义signal函数

```C
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

函数行为：若成功则返回一个指向`handler`函数的指针，来处理信号。失败则返回 `SIG_ERR`

自定义行为（修改handler）

- `SIG_IGN`：不处理`sigum`信号
- `SIG_DFL`：将`signum`信号的行为转换为默认行为

**阻塞信号**

函数sigprocmask

```c
int sigprocmask(int how, const sigset_t *set, sigset_t *oldest);
```

### 信号总结

1. 信号是内核提供给进程的消息，从而让进程做出特定的反应
3. 信号的来源有两种：一种是被动的，例如系统事件的发生；另一种是进程主动生成的。
4. 内核负责发送信号。如果信号未被进程处理，还会保存信号到待处理信号。
5. 进程接收信号。进程接收信号后，如果没有特殊处理，则会按照信号的默认行为操作；如果自定义了信号处理函数，则交给信号处理函数处理。

## 12.13

csapp学习shellex

1. 避免使用参数字符串

   先用strcpy备份一个字符串，修改备份字符串

   ```C
   strcpy(buf, cmdline);
   ```

2. 在`if`判断语句中使用赋值语句，节省空间

   ```C
   if ( (pid = Fork()) == 0 ) {}
   ```

3. 回顾waitpid行为

   ```C
   pid_t waitpid(pid_t pid, int *statusp, int option);
   ```

   默认挂起父进程，等待子进程终止则返回其pid，如果出错则返回-1

   - 指定等待对象
   - 修改默认行为option
     - WNOHANG：无终立返
     - WUNTRACTED：挂父等子停或终
     - WCONTINUED：挂父等子终或重启（`SIG_CONT`信号）
     - WNOHANG | WUNTRACTED：立即返回。停止或终止，立即返回pid；否则返回0
   - 获取返回的子进程退出状态
     - 是否合法退出：WIFEXITED
     - 合法退出的状态：WEXITSTATUS
   - 检查错误
     - 没有子进程，errno = ECHILD，返回-1
     - 被中断，errno = EINTER, 返回-1

4. 处理附着在fgets字符串末尾的`\n`

   ```C
   buf[strlen(buf) - 1] = ' ';
   ```

   目的是确保输入参数以空格分隔.

   考虑如果将字符串的末尾改为`\0`。若输入参数为`bin\ls`，此时字符串会被改为`bin\ls\0`。然后在后续处理中：

   ```C
   while((delim = strchr(buf, ' '))) {
   ```

   因为没有空格，这样会导致含有一个参数的字符串解析失败。

   如果输入两个参数，如果最后一个参数末尾不带空格，同样地不会被处理到。这样参数总会丢失最后一个参数。

   所以在利用`strchr`定位空格位置来间接定位参数后续逻辑下，只能将字符串末尾的换行符初始化为空格

5. strchr

   ```C
   char *strchr(const char *s, int c);
   ```

   这里要用正确的方法获取第一个空格位置：

   ```C
   while(delim = strchr(buf, ' ')){}
   ```

6. 判断一个指向字符串数组的元素是否为字符`&`

   ```C
   if (*argv[argc - 1] == '&')
   ```


### signal1.c

1. 问题：现在在主函数main中，安装了信号处理函数。

   ```C
   signal(SIGCHLD, handler1);
   ```

   当执行到信号处理后面的指令时候，这时候系统发送了一个`SIGCHILD`信号，这时候进程会响应信号还是继续执行下面的指令？

   答案：当信号发送到进程时，会停止进程的执行，调用信号处理函数。处理程序执行完毕，再将控制权交给main进程被中断位置处，继续执行指令。

2. 为什么三个子进程终止的信号，但是只被捕获了两次？

   答案：

   - linux隐式阻塞机制：内核会阻塞当前处理信号处理程序正在处理的信号类型的待处理的信号。

总结下今天的csapp学习：

1. 编程技巧：如果后续字符串要被修改，先备份字符串
2. 信号的细节：待处理信号，处理程序会阻塞正在处理的同类型信号；编写安全信号处理函数的规则。

有待改进的地方：

- 几乎不阶段总结。导致新概念不能被即使复习。

让我觉得有挑战的地方：

- 构建逻辑：感觉还是有压力
- 代码逻辑：阅读代码嘛，依旧是有压力。压力来源于对代码的不熟悉。语法和逻辑熟悉了的话，其实很简单。

## 12.14

因为新知识概念和细节太多，今天尝试每35分钟就总结一下。

回顾：为什么三个终止的子进程，只回收了两个？

答：因为第三个信号丢失了。

首先父进程异常处理程序捕获第一个子进程终止信号`SIGCHLD`并处理。

然后第二个子进程终止信号`SIGCHLD`发送过来，此时信号会被内核放在父进程的待处理队列和阻塞队列中。

第三个信号过来后，由于待处理队列中存在同类`SIGCHLD`待处理信号，所以第三个信号会被丢弃。

异常处理程序执行完毕第一个信号后，内核从阻塞队列释放信号`SIGCHLD`，然后将第二个子进程终止信号从待处理信号队列中拿出交给异常处理程序处理。

- 隐式阻塞机制：内核默认阻塞当前异常处理程序正在处理信号类型的待处理信号

学习：

1. 利用sigprocmask来显式阻塞信号SIGINT信号
2. 子进程调用execve的时候，子进程的PID不会改变，终止后的信号也能被父进程捕获。

# 12.16-12.20本周计划

- 完成shelllab
- 完成系统级IO章节学习并梳理框架

## 12.16

### 改进脚本

改进脚本compile-csapp.sh，现在执行脚本后，会将编译结果存入到`build`目录下。脚本如下

```bash
#!/bin/bash
# 创建编译目录
dir="build"
mkdir -p "$dir"

# 检查是否提供了源文件作为参数
if [ $# -eq 0 ]; then
  echo "Usage: c <source_file>"
  exit 1
fi

# 获取文件名，去掉扩展名 .c
filename=$(basename "$1" .c)

# 编译源文件并链接
gcc -I/home/crx/study/csapp/code/include /home/crx/study/csapp/code/src/csapp.c "$1" -o "$dir/$filename"

# 执行生成的可执行文件
./"$dir/$filename"
```

### shellex.c组块

第二个番茄时钟：13：51  - 14：26

1. 要实现一个获取用户输入参数并执行的shell程序
2. 要想实现shell程序,就需要获取用户输入，然后计算用户输入即可
3. 要想计算用户输入，首先需要将输入的字符串转换为参数列表，随后执行参数
4. 要想执行参数，先判断是否内置命令，如果是，则执行内置命令；否，则创建一个子进程并执行这个参数，并且父进程需要等待子进程终止
5. 要让父进程等待子进程终止，就需要判断子进程的执行是后台执行还是前台执行。如果后台执行，则返回子进程的pid和命令行字符串即可；如果前台执行，则需要挂起父进程直到子进程终止。

总计用时1h（太困了，中途断了半小时）

卡点：

- API行为不熟悉：waitpid、execve、fgets
- 组块不熟悉：创建参数数组
- 执行逻辑不熟悉：eval

复习卡点处：

1. waitpid

   ```C
   pid_t waitpid(pid_t pid, int *statusp, int option);
   ```

   默认：`waitpid(-1, NULL, 0)`挂父等子终。子进程存在且终止，返回PID；错误（没有子进程或者被中断等）则返回 **-1**，并且 `errno` 会被设置为相应的错误码

   等待对象、获取已返回子进程的退出状态、修改默认行为。

2. execve

   ```C
   int execve(const char *filename, const char *argv[], const char *envp[]);
   ```

   返回值：执行成功不返回；执行失败设置errno为报错信息并且返回-1

3. fgets

   ```C
   char *fgets(char *s, int size, FILE *stream);
   ```

   返回值：成功返回指向`s`的指针，否则返回NULL

4. 创建参数数组

   参数字符串例如`“/bin/ls -al”`，将其按照空格分割为参数字符串数组

   ```C
   while (*buf && (*buf == ' ')) {
     buf++;
   }
   
   int argc = 0;
   while((delim = strchr(buf, ' ')) != NULL) {
     argv[argc++] = buf;
     delim = '\0';
     buf = delim + 1;
     while (*buf && (*buf == ' ')) {
       buf++;
     }
   }
   argv[argc] = NULL;
   ```

### signal2.c组块

第三个番茄时钟：14：47 - 15：22

1. 逻辑组块：父进程设置一个SIGCHLD处理程序，然后创建三个输出后立即返回的子进程，随后等待用户输入。用户输入完毕，则进入无限循环，等待处理程序回收子进程。

2. API：read，getpid

   read

   ```C
   ssize_t read(int fd, void *buf, size_t count);
   ```

   行为：从一个文件描述符fd中读取count个字节的数据，并将其保存在buf中

   返回值：返回读取的字节数量；读取错误为-1，并且可以读取errno（函数`strerror()`）

   getpid：

   ```c
   pid_t getpid(void);
   ```

   获取当前进程pid

3. 安全处理程序规则：保护全局变量的使用（保存和恢复errno、操作原子性：violatile和sig_atomic_t）

   ```C
   void handler2(int sig){
     int olderrno = errno;
     ...
     errno = olderrno;
   }
   ```

### signalprob0.c组块

4个番茄钟：15:35 - 16:10

1. kill

   ```C
   int kill(pid_t pid, int sig);
   ```

   行为：将信号sig传递给进程pid.

   - pid == 0:给进程组所有进程发送
   - pid <0, pid = |pid|

   返回值：成功返回0，错误则为-1

2. fork

   ```C
   pid_t fork(void)
   ```

   父进程调用后会返回子进程的pid，可以按照此pid操作子进程

   ```C
   if ((pid = Fork()) == 0) {
     while(1) {};
   }
   
   Kill(pid, SIGUSR1);
   Waitpid(-1, NULL, 0);
   ```

   这里父进程就会将信号`SIGUSR1`发送给子进程，然后挂起父进程等待子进程终止。

3. 原子操作全局变量

   ```c
   Sigfillset(&mask);
   Sigprocmask(SIG_BLOCK, &mask, &prev_mask);
   Sio_putl(--counter);
   Sigprocmask(SIG_SETMASK, &prev_mask, NULL);
   ```

### procmask2.c组块

1. 处理程序保护并恢复errno

   ```C
   int olderrno = errno;
   ...
   errno = olderrno;
   ```

2. 信号处理函数回收子进程删除job之前，阻塞所有信号

   ```c
   Sigfillset(&mask_all);
   while((pid = waitpid(-1, NULL, 0)) > 0) {
     Sigprocmask(SIG_BLOCK, &mask_all, &prev_all);
     deletejob(pid);
     Sigprocmask(SIG_SETMASK, &prev_all, NULL);
   }
   ```

3. 创建一个只有SIGCHLD的信号集合

   ```c
   Sigemptyset(&mask_one);
   Sigaddset(&mask_one, SIGCHLD);
   ```

4. 子进程执行新程序前，解除子进程对SIGCHLD信号的阻塞的原因

   答：因为避免execve执行的新程序处理SIGCHLD信号。关键概念就是**信号屏蔽字继承：** 父进程中的信号屏蔽字会被子进程继承，意味着如果父进程在调用 `execve()` 之前阻塞了某些信号，那么子进程也会阻塞相同的信号。

## 12.17

### 复习

1. shellex如果参数为空的处理eval和parseline

   eval根据返回参数列表的第一个元素是否为空来判断。如果为空，不做处理

   ```C
   if (argv[0] == NULL) {
     retutn;
   }
   ```

   parseline在判断最后的参数是否为`&`时，根据argc判断参数是否为空。如果为空，则提示后台处理。

   ```C
   if (argc == 0) {
     return 1;
   }
   ```

2. 子进程执行新程序的失败处理 

   ```C
   if ((pid = Fork()) == 0) {
     if (execve(argv[0], argv ,environ) < 0) {
       printf("%s Command not found\n", argv[0]);
       exit(0);
     }
   }
   ```

**signal.c**

1. 在信号处理程序中，为什么要`sleep(1)`

   ```C
   void handler2(int sig) 
   {
       int olderrno = errno;
   
       while (waitpid(-1, NULL, 0) > 0) {
           Sio_puts("Handler reaped child\n");
       }
       if (errno != ECHILD)
           Sio_error("waitpid error");
       Sleep(1);
       errno = olderrno;
   }
   ```

   破案了。没有任何意义，只是模拟信号处理函数的一些可能的操作而已。

## 12.18

怎么都是复习啦。

今日任务

- [x] 整理IO部分框架
- [x] 复习信号部分的基本操作

### 复习

#### procmask2.c的job竞争

逻辑分块：

信号处理程序部分

1. 安全处理程序

   ```C
   int olderrno = errno;
   //....
   errno = olderrno;
   ```

2. 删除job不中断

   ```c
   Sigfillset(&mask_all);
   while((pid = waitpid(-1, NULL, 0)) > 0) {
     Sigprocmask(SIG_BLOCK, &mask_all, &prev_all);
     deletejob(pid);
     Sigprocmask(SIG_SETMASK, &prev_all, NULL);
   }
   ```

3. 循环回收子进程

   ```C
   while((pid = waitpid(-1, NULL, 0)) > 0) {
   ....
   }
   if (errno != ECHILD) {
     unix_error("waitpid error");
   }
   ```

父进程

1. 确保父进程添加job后再回收子

   ```C
   Sigprocmask(SIG_BLOCK, &mask_one, &prev_one); // Block SIGCHLD
   if ((pid = Fork()) == 0) {
     ....
   }
   Sigprocmask(SIG_BLOCK, &mask_all, NULL);
   addjob();
   Sigproccmask(SIG_SETMASK, &prev_one, NULL);
   ```

2. 子进程执行新程序之前，解除SIGCHLD信号阻塞

   ```C
   if((pid = Fork()) == 0) {
     Sigprocmask(SIG_SETMASK, &prev_one, NULL);
     execve("/bin/date", argv, NULL);
   }
   ```

3. 信号初始化

   ```C
   sigset_t mask_all, mask_one, prev_one;
   
   Sigfillset(&mask_all);
   Sigemptyset(&mask_one);
   Sigaddset(&mask_one, SIGCHLD)；
   Signal(SIGCHLD, handler);
   ```

系统级IO框架整

## 12.19

shlab开始

下午15：04开始第一个番茄钟

阅读shellLab实验材料：

单词部分

- skeleton
- sanity
- approximate
- denote
- offend

概念：

- 进程组

要求：函数的完形填空

知识背景：

- job：解释命令的子进程，可能有多个子进程
- pipe功能：修改文件描述符
- 如果后台运行：程序会继续执行等待下一个新的命令行，后台可以运行多个job
- 前台运行，则需要挂父等子终waitpid，因此前台只有最多一个job
- job控制：改变job中的进程状态。
- sigint终止前台job的进程以及子进程（区别进程组），如果没有则不会做任何操作。
- SIGTSTP停止前台job进程，直到出现一个SIGCONT信号

tsh行为：

- prompt：`tsh> ` 
- 输入字符串被空格分隔
- 不需要支持管道或I/O重定向（不涉及文件描述符）
- 存在`&`则后台运行
- 打印job信息时，JID需要带有前缀`%`。例如`%5`代表`JID 5`
- 回收所有僵尸进程。如果job被没有捕获的信号终止，tsh需要识别并打印job的PID和该信号的简单描述

built-in行为：

- quit：终止shell（当前进程及其所有前后台进程以及子进程）
- jobs：输出所有后台运行的job
- bg：入参为JID或者PID均可。为SIGCONT重启job，并将其运行在后台。
- fg：入参行为如上，但是运行在前台

## 12.20

unix I/O

1. 追踪指定系统调用函数

   ```bash
   strace -e trace=write ./cpstdin
   ```

2. 获取文件类型的宏

   ```c
   stat.st_mode;
   
   S_ISREG(m);
   S_ISDIR(m);
   S_ISSOCK(m);
   ```

3. 检查文件的访问权限

   ```c
   stat.st_mode & S_ISUSR;
   ```

4. 获取文件信息

   ```C
   struct stat stat;
   Stat("filename", &stat);
   ```


计算机网络：

- 码元离散值和携带信息量的关系
- 曼彻斯特编码
- 同步和异步传输的差别//

## 12.15

虽然手残疾了，但是依然要写点什么

