# just do it日报

# Just Do It.

## 2024.1.22

今日任务：

- [x] 练字半小时

- [x] 数学大纲

- [x] 洗牙

- [x] csapp重做习题

- [x] cs61a查看网站

- [x] 打字练习20分钟

  <img src="C:\Users\crx\AppData\Roaming\Typora\typora-user-images\image-20240122194408527.png" alt="image-20240122194408527" style="zoom:33%;" />

### `size_t`的用法

补充C基础。

之前一直不是很了解为什么`show_bytes`要用`size_t`作为长度单位，代码实例：

```c
typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len) {
    size_t i;
    for (i = 0; i < len; i++)
	printf(" %.2x", start[i]);    //line:data:show_bytes_printf
    printf("\n");
}
```

然后在《C Primer Plus》中找到了`size_t`的用途。

`sizeof`函数返回的是一个无符号整数，但是并未确定其变量类型。所以不同机器用`sizeof`可能要用unsigned int、unsigned long甚至是unsigned long long类型的变量来存储。

这样会导致的问题首先就是，你想用`printf`打印`sizeof`的表达式，你需要了解自己计算机系统用什么类型数据存储`sizeof`。并且不利于后续的移植开发。

所以C直接定义了一个`sizeof`返回的类型`size_t`，专门用来保存sizeof函数产生的无符号整数变量。此时printf函数使用`z`修饰符表示打印相应的类型。

还是得以权威的工具书为指导啊，查了半天人家几句话就讲明白了。

### 关于Byte Ordering

首先理解最高位字节：一个数据用n位的二进制表示为[wn-1, wn-2, ... , w1,w0]。那么wn-1就是二进制的最高位而w0为最低位。假设n为8的倍数，那么[wn-1, wn-2, ... , wn-8]就是最高位字节。

如果一个系统从数据的最高位字节开始存储，一直存到数据的最低位字节，那么这个系统就是“大端”存储类型。所以如果想要检测下自己的系统是哪种类型存储数据的，最简单的方法就是按字节输出int类的变量0x12345678。

如果输出结果为12 34 56 78，那么大端存储。如果结果为78 56 34 12，那么小端存储。

## 1.23

今天突然想回去，但是csapp。有没有一种可能，就是csapp并不影响你回去？是的，只需要有电脑就好了。

## 1.25

今日学习下cs61a的课程大纲，了解下课程的培养目标。

然后就是csapp的题目，按照进度安排，这周五做完第二章题目的话，现在还有几个题？

需要做10个题目，才能基本完成这周的计划，这样周末完成第二章大作业。（2.63-2.73）

我觉得不算难，主要是考虑时间别太多，直接看答案解析这一遍，然后再自己考虑解决方法。

### cs61a的课程大纲

We consider a series of techniques for controlling program complexity, such as functional programming, data abstraction, and object-oriented programming.

Homeworks are weekly assignments meant to help you apply the concepts learned in lecture and section on more challenging problems.

The purpose of homework is for you to learn the course material, not to prove that you already know it.（很喜欢的一句话(●'◡'●) ）

**If you are stuck on a problem, come get help instead of copying the answer from someone else or the Internet; you'll still get credit and won't be flagged for cheating**

Problem solving practice is the key to progress in computer science.

### csapp

现在时间来到了下午14:27，现是时候做几个c题目来熟络熟络筋骨了。

ok，第一个2.63就卡了我好久。主要是因为算术右移的那个函数，确定是否执行算术右移的时候出问题了：取得最高位，如果是1则需要执行算术右移（前面补1），否则不需要补1。

```C
int sra(int x, int k) {
    int complement_quantity = sizeof(int) << 3 - k;
    int xsrl = (unsigned) x >> k;

    //get the sign bit :10000... or 000000...
    int sign_bit = (1 << (complement_quantity - 1)) & xsrl;

    //reverse_sign_value:will get 0 if sign_bit != 0
    int reverse_sign_value = !sign_bit - 1;
    
    int mask = -1 << complement_quantity;
    
    return xsrl | reverse_sign_value & mask;
}
```

取得的最高位`sign_bit`并不是一个单独的位，所以根据这个值是否为空来判断是否执行补1操作的话，需要利用逻辑操作和-1的奇思妙想。

挺有意思，我一开始想用`!!sign_bit`的方法得到是否跟mask进行或操作，当`sign_bit`为0，则`!!sign_bit`值为0；当`sign_bit`不为0，则`!!sign_bit`值为1。这样跟mask操作也不是很方便，所以才想到了-1的操作。

现在已经17：12分了，仅做第一个题，有点挫败的。

ok，现在吃了老妈做的木耳芹菜山药炒肉后，满血复活了。

在做两个题目，现在遇到一个题目超级有意思，虽然以我现在的能力解决不了，但是将答案研究一遍还是能做到的。

上题目：

![image-20240125184322375](C:\Users\28075\AppData\Roaming\Typora\typora-user-images\image-20240125184322375.png)

题目的梗概就是：用书中的规则（不能用循环、判断等），写一个函数，入参一个x。当x的二进制表示中1的数量为奇数个，则函数返回1，否则返回0。

这里我想循环计数1的想法被规则打破了：不能用循环和条件判断。

在我反复确认无法以现阶段的能力解决后，我决定看答案，研究他们是怎么解决这个炙手山芋的。上代码：

```C
int odd_ones(unsigned x){
    x ^= x >> 16;
    x ^= x >> 8;
    x ^= x >> 4;
    x ^= x >> 2;
    x ^= x >>1;
    x &= 0x1;
    return x;
}
```

牛逼，当时觉得这代码真tm优雅，几行就解决问题了，这能行？

研究完以后，真牛逼，这能行！

他巧妙地用异或操作，将整个数的奇偶性逐渐控制到了最低位。第一次，作为一个32位的数据，右移16位后与原数据做异或操作。高16位和低16位作异或操作，这样会导致低16位数据中成对的1消失。

而消失掉重复1后的低16位数据，保留了原32位数据的奇偶性（虽然数量不一致，但是只要整体的奇偶性不变就可以）。

这样重复执行下去，就会让低8、4、2、1位保留原32位的奇偶性，最终原数据的奇偶性就会体现在最低位上。

所以这个题目，就没使用统计数量，而是用的异或的性质：同类相消，将影响奇偶的份子去除掉。最终实现了获取整个数据的奇偶性。

## 1.26

今日早起练字，很不错的开局。今天是鸭旺口集，一会去买点水果。

现在就是将cs61a的lab研究一下。

需要买的东西：

- [ ] 插排收纳

按照cs61a的手册完成了第一节课的环境布置。下午写一下csapp第二章的homework（某些题目真的挺难，但是为了变得更强，请just do it！）

今天真牛逼，做了5个题目，做到了2.70。准备睡觉了。

## 1.27

cs61a：

When stuck on a problem, try to explain the area in which you are stuck.

Do the readings before lecture! (but what should i read?slide or oneline book?)

When preparing for the midterms and final, do past exam questions! Lecture, lab, and discussion provide a great introduction to the material, but the only way to learn how to solve exam-level problems is to do exam-level problems.

ok，发现了2024年春季新版的cs61a，而且是两周前开的课，直接跟进新课程的进度。

好吧，现在发现需要用到python编写函数的语法，可是我不会~需要补一下知识了。

## 1.28

昨天下午给小伙子开了一下午家长会，听了海川中学的宣讲，感觉这个学校是办正事的，不知道小伙子中考能去哪里？

今天开始cs61a的课本教材，然后到10点左右坐车去万虹广场跟大家聚一下。

[1.2  Elements of Programming](https://www.composingprograms.com/pages/12-elements-of-programming.html)里面对于代码的可读性阐释：A programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about computational processes. Programs serve to communicate those ideas among the members of a programming community. Thus, programs must be written for people to read, and only incidentally for machines to execute.

代码作为交流思想的工具，不仅仅只是指挥电脑实现具体功能，而且是思想传递的媒介。所以代码不仅仅需要能跑起来，而且需要读得懂。

## 1.29

昨天孙某韦某见面会，回来帅总亲切让我们滚。

今天回顾昨天的知识：

python函数相对于数学中缀表达式的三个优点：

1. 函数可以有任意个参数（因为数学公式中参数一旦多起来，就很难去得到这个表达式的原本意图）
2. 函数可以任意嵌套
3. 函数免去了各种奇怪上下标、公式符号的限制，简单明了。

今天学的知识：

引用库的方法：from modules import functions，等以后对于python的语法了解清晰后，可以用官方文档[python3Library](https://docs.python.org/3/library/index.html)来寻找自己想要的函数。

赋值语句居然是一个简单的抽象，它将等号右边复杂的表达式，与左边的简单变量名联系起来，我们可以直接用简单变量名（类似于area），就可以获取对应复杂操作的值（retrieving those values by name）。赋值语句在右边表达式计算尚未完成之前，是不能跟左边变量名进行连接的。所以py的交换两个数的值可以用一个函数

跑步完毕，回来做饭。

下午csapp。

## 1.30

早晨起来后，先过了一遍csapp的课后题目。

现在记录下2.70的题目：

```C
// Write code for the function with the following prototype:
/*
* Return 1 when x can be represented as an n-bit, 2’s-complement
* number; 0 otherwise
* Assume 1 <= n <= w
*/
int fits_bits(int x, int n);
```

对于这个题目，需要思考下步骤。

题目要求：如果这个数据能被n位的二进制补码表示，则返回1。

一个int类型的数怎么才能被n位的二进制补码表示呢？

举例1，x = [001001]，能否被n = 4的二进制补码表示？不能，因为n = 4的时第4位为符号位，如果此时数据的第四位恰好为1，则4位的二进制补码数据则会与原数据值不相同。

举例2，x = [001001]，能否被n = 3的二进制补码表示？不能，因为3位的二进制补码肯定不能正确展示原长度为4的数据。

在这里定义一下原数据的最高位1的位置为w。想用n位的二进制补码正确表示原数据，就需要n >= 1 + w;

但是这里并不能用判断，这就需要从另一个角度去考虑。

如果这个数据能被n位的二进制补码表示，那么它跟原数据有什么关联吗？

1. 原数据 == 被二进制补码表示的数据（n > w）
2. 原数据左移(32 - n)位，然后再算术右移（32 - n）位，原数据不变。（这样就包括了第一步的判断相等的问题）

代码：

```C
#include <stdio.h>
#include <assert.h>
/*
* Return 1 when x can be represented as an n-bit, 2’s-complement
* number; 0 otherwise
* Assume 1 <= n <= w
*/
int fits_bits(int x, int n){
  int w = sizeof(int) << 3;
  return x == (x << (w - n) >> (w - n));
}
int main(){
  assert(fits_bits(0x1234, 16));
  assert(!fits_bits(0x90, 8));
  assert(fits_bits(0x90, 9));
  assert(!fits_bits(0x7F, 7));
  assert(fits_bits(0x7F, 8));
  return 0;
}
```

明天赶集了，今天能稍微赶赶进度吗？

csapp这几道题，难度真的不低，这都是第三次做了，还是用了我两个小时（我期待1h以内就能完成的）。

然后卡我的时间较多的地方简单在这做下记录：

1. 边界问题：获取第k位的数据（x & (1 << (k - 1))）
2. 题型见的少，没有思路：像是能否用n位的二进制补码表示这个数据（只能是多做多思考😉 ）

ok，开始cs61a的道路，今天看看能否将`1.3  Defining New Functions`和`1.4  Designing Functions`看完并且理解了。别着急，多轮重复起来。

函数名称（起名的艺术）

1. 函数名都是小写字母，单词之间要以下划线分隔，起描述性的函数名
2. 参数名要有意义（《代码整洁之道》）

函数定义要隐藏细节。能做到下一个人在调用你写的函数的时候，只关心函数的描述而不用关心函数的操作。

函数抽象的三个属性：

1. 定义域（范围）：能够使用的函数参数
2. 值域：函数的返回值集合
3. 意图：输入与输出的联系

现在学习cs61a遇到的问题：文档中对于专业名词和长难句运用较多，阅读起来速度较慢。感觉这个问题一时半会也解决不了，需要慢慢积累吧。

函数设计时的规则（同《代码整洁之道》）

1. 每一个函数都应该仅做一项任务
2. 不要重复自己
3. 函数应该具有一般性（实现乘方而不仅仅是平方）

Remember, code is written only once, but often read many times. 哈哈哈，太担心辣鸡代码了。

## 1.31

今日赶集，买了80块的苹果，我们比卖苹果的人都先到了集上，所以好吃的苹果都被我们买过来了。

今天继续cs61a，重新回顾下昨天学习的知识。

函数中的返回表达式仅仅在调用此函数的时候才会被计算。

计算表达式的环境中，包含了许多连续的栈帧。An `import` statement binds a name to a built-in function. A `def` statement binds a name to a user-defined function created by the definition.

今天看了下课程安排，![image-20240131160030163](C:\Users\28075\AppData\Roaming\Typora\typora-user-images\image-20240131160030163.png)

如果说这周到2.2号完成的话，需要解决ch1.6的文章和几个lab。

这周cs61a任务就是完成1.6章节的阅读，然后做题。但是还有一个问题就是，我的csapp进度呢？

现在做到了2.70题目，还有30道题。

## 2.1

今日任务：

- [ ] 阅读cs61a的1.6和1.7节文章
- [ ] 做5个csaqq题目（2.71-2.75）

今天在偶然阅读python的蟒蛇书时候，发现了作者写的几句话：

> 这里，我建议大家：
>
> 1. 第一部分尽可能在42小时内快速浏览一遍（2天之内），不用理解，先混个眼熟
> 2. 第二部分跟着项目实践精读，对应查阅第一部分的基础知识点，针对性地自我解答。
>
> 这样你就能从枯燥的语法、控制结构、数据结构等无穷的编程概念中挣脱出来，进入一个具体真实的项目场景中，一切将变得异常清晰、有目标且可检验。

这里我再去检视自己的学习方法：

1. 想将阅读材料全部掌握（不符合学习逻辑，应该是用到什么，再深入理解地去学什么。应该以问题驱动学习，而不是单纯学习不去应用知识）
2. 阅读英文文章的时候，会有走神的现象（语法卡住后，自己的精神就会恍惚一下🥲）

其实就是想死磕英语语法，为了语法而去阅读，但是忘记了英语只是一个工具，能读懂就行了。

现在就可以这样，先通篇略读，第一遍看看代码执行逻辑，然后第二遍看看概念介绍，第三遍再通读一遍。这段时间尽量控制在1h以内。好的，开始实践，预计8：40应该可以将第6节过一遍。（其实难度主要在这个文档的长难句语法上，可能也需要我耐心阅读来积累长难句的语法）

ok，现在是8：32，读到了1/3的部分，时间去哪了？

在读的时候，对设计模式产生了兴趣（因为这个函数的抽象实在是太牛逼了）

```py
>>> def improve(update, close, guess=1):
        while not close(guess):
            guess = update(guess)
        return guess
```

然后下载大话设计模式pdf，在往cs文件夹移动的时候，就发现了 [健康学习到150岁 - 人体系统调优不完全指南](https://github.com/zijie0/HumanSystemOptimization)这个当时摘录的文章，然后就走神进去了一会...

额，一个小时应该可以浏览完这个文章了，不走神的前提下，现在起身锻炼下身体，然后再8：45分开始到10点，解决1.6章节学习。

下午过来报道：

cs61a的阅读材1.6章节料现在已经读了3/5了，很牛逼。因为里面既有新知识：函数作为参数调用时的一些特性，原谅我现在想不起来上午的知识点了，一会再回顾一下吧。

现在就练习下打字速度，然后投入到csapp的学习当中。今天1.6和1.7应该是可以完结的，加油！

csapp的2.72题目

```C
/* Copy integer into buffer if space is available */
/* WARNING: The following code is buggy */
void copy_int(int val, void *buf, int maxbytes) {
if (maxbytes-sizeof(val) >= 0)
	memcpy(buf, (void *) &val, sizeof(val));
}
```

这个代码中的判断逻辑：`maxbytes-sizeof(val) >= 0`会导致这个题目出现“即使maxbytes < sizeof(val)也会执行复制操作”。

因为函数`sizeof()`会返回一个无符号数，而maxbytes是有符号数，这样运算的时候，就会导致类型转换。而类型转换在表达式的时候，如果一个操作数是有符号整数，而另一个是无符号整数，那么有符号整数会被转换为无符号整数。

这样就可以解释为什么出现“即使maxbytes < sizeof(val)也会执行复制操作”的问题了：两者转为无符号整数运算后，数据永远大于等于0，导致这个判断条件永远为真。

所以修改策略也很简单，就是强制将`sizeof()`返回的值转换为统一的有符号类型数据再处理。

## 2.2

今天稳步向前就好，别急功近利了。

### 2.74

这里挂一下csapp的2.74问题和答案，进行分析，学到了赋值的新思路。

> **Write a function with the following prototype:**
>
> ```C
> /* Determine whether arguments can be subtracted without overflow */
> 
> 	int tsub_ok(int x, int y);
> ```
>
> **This function should return 1 if the computation x-y does not overflow**

首先这个题目并没有要求使用164页的编程规则限制，也就是说你其实可以用条件判断和循环来实现这个题目。然后另一个问题就是，怎么样才能更简单实现这个功能。

我的思考肯定是基于这两个判断表达式的：

```C
if(x < 0 && y > 0 && sub > 0) return 0; //负溢出
if(x > 0 && y < 0 && sub < 0) return 0; //正溢出
```

然后可以看看答案是怎么考虑这个问题的，之所以记录这个题目，就是因为这个题目运用了逻辑运算与`&&`的短路特性来使得代码简化了（随之而来的是可读性变差的结果）：

```C
/*
 * tsub-ok.c
 */
#include <stdio.h>
#include <assert.h>
#include <limits.h>

/* Determine whether arguments can be substracted without overflow */
int tsub_ok(int x, int y)
{
    int res = 1;
    /* 如果y为INT_MIN，则x为任意值都会溢出：
    x > 0,sub < 0; 
    x < 0(x此时取值范围为 [INT_MIN,0) ),sub >= 0--突然发现这个条件是判断是否溢出的一个定理，可以重点记忆一下
    */
    (y == INT_MIN) && (res = 0);
    // if (y == INT_MIN) res = 0;

    /*这里就是很正常的条件判断，但是利用了逻辑与 && 运算符的短路特性*/
    int sub = x - y;
    int pos_over = x > 0 && y < 0 && sub < 0;
    int neg_over = x < 0 && y > 0 && sub > 0;

    res = res && !(pos_over || neg_over);

    return res;
}

int main(int argc, char* argv[]) {
  assert(!tsub_ok(0x00, INT_MIN));
  assert(tsub_ok(0x00, 0x00));
  return 0;
}
```

可以看到这个题目中，用到了逻辑运算与 `&&` 运算符的短路特性来判断是否溢出了。用chatgpt来分析这个` (y == INT_MIN) && (res = 0);`语句实现了什么功能，可以得到答案：

> 这个表达式使用了逻辑与 `&&` 运算符，它具有短路特性。表达式中有两部分：
>
> 1. `(y == INT_MIN)`：检查变量 `y` 是否等于 `INT_MIN`，即判断 `y` 是否为整型最小值。
> 2. `(res = 0)`：将变量 `res` 赋值为 `0`。
>
> 这两部分由 `&&` 连接在一起，整个表达式的结果取决于两部分的值。
>
> 如果第一部分 `(y == INT_MIN)` 为真（即 `y` 等于 `INT_MIN`），那么第二部分 `(res = 0)` 也会被执行。这是因为在逻辑与运算中，如果第一个条件为真，那么第二个条件就会被检查并执行。在这种情况下，整个表达式的值为真。
>
> 如果第一部分 `(y == INT_MIN)` 为假，那么第二部分 `(res = 0)` 将不会被执行，因为短路特性会导致整个表达式的值为假。
>
> 这样的表达式通常用于条件赋值的场景。如果 `y` 的值等于 `INT_MIN`，则将 `res` 的值设置为 `0`；否则，保持 `res` 的原始值。在实际编码中，这种写法可能会让代码可读性变差，应该慎用。最好将条件判断和赋值操作分开，以提高代码的清晰度。

那么其实这个题目用了某种取巧的方法简化了代码结构，其实可读性变差了。但是仍然加强了对于逻辑运算符的理解。

其实2.74还蕴藏着一个知识点：两个数的和什么时候会溢出。

当x + y > TMAX，或者x + y < TMIN时，这时候就会导致溢出。若根据这两个判断条件来确定当溢出时x和y的范围，则需要分类讨论：

1. x > 0时，因为TMIN < y < TMAX，所以x + y > TMIN + x是永远不会负溢出的。但是可能会出现x+ y > TMAX的正溢出的场景。此时x > 0，那么y的取值范围就是(TMAX - x, TMAX]
2. x < 0时，x + y = TMAX + x永远不会正溢出。但是会出现负溢出（x + y < TMIN）的场景。y的取值范围是[TMIN, TMIN - x)

### 2.73

然后再看2.73这个题目：

> Write code for a function with the following prototype:
>
> ```C
> /* Addition that saturates to TMin or TMax */
> 	int saturating_add(int x, int y);
> ```
>
> Instead of overflowing the way normal two’s-complement addition does, saturating
> addition returns TMax when there would be positive overflow, and TMin
> when there would be negative overflow. Saturating arithmetic is commonly used
> in programs that perform digital signal processing.
>
> Your function should follow the bit-level integer coding rules (page 164).

当程序运算有溢出的时候，返回对应的边界值（TMIN，TMAX），并且不能用判断循环等。看下答案怎么处理的这个情况：

```C
/*
 * saturating-add.c
 */
#include <stdio.h>
#include <assert.h>
#include <limits.h>

int saturating_add(int x, int y) {
  int sum = x + y;
  int sig_mask = INT_MIN;//0x80000000
  /*
   * if x > 0, y > 0 but sum < 0, it's a positive overflow
   * if x < 0, y < 0 but sum >= 0, it's a negetive overflow
   */
  int pos_over = !(x & sig_mask) && !(y & sig_mask) && (sum & sig_mask);
  int neg_over = (x & sig_mask) && (y & sig_mask) && !(sum & sig_mask);

  (pos_over && (sum = INT_MAX) || neg_over && (sum = INT_MIN));

  return sum;
}

int main(int argc, char* argv[]) {
  assert(INT_MAX == saturating_add(INT_MAX, 0x1234));
  assert(INT_MIN == saturating_add(INT_MIN, -0x1234));
  assert(0x11 + 0x22 == saturating_add(0x11, 0x22));
  return 0;
}
```

这里有两个问题需要研究代码解决：

1. 在没有条件判断符的情况下，如何判定正负溢出？
2. 溢出后，怎么确定正负溢出然后返回对应的边界值？

首先分析在没有关系运算符的情况下，此函数如何判断正溢出的：

```C
  int pos_over = !(x & sig_mask) && !(y & sig_mask) && (sum & sig_mask);
```

当x & sig_mask == 0 ，y & sig_mask == 0且sum & sig_mask != 0的时候，这个正溢出标志pos_over等于1成立。下面逐一分析正溢出的这几个条件：

`x & sig_mask == 0`：只要x的最高位为0即可，这样对应的x的取值就去除了负数部分，此时x的取值范围为：`x >= 0`。

`y & sig_mask == 0`：同理，y的最高位为0，y的取值范围为`y >= 0`。

`sum & sig_mask != 0`:此时证明参数sum的最高位一定为1，此时sum的取值范围为：`sum < 0`

所以结合注释，可以得到问题1的答案。由原来需要关系运算符（>和<）`if x > 0, y > 0 but sum < 0, it's a positive overflow`，到现在直接利用二进制补码的特性——即最高位是否为1，和逻辑运算符`&&`的短路特性，来判断x、y和sum是正数还是负数，从而得到相同的溢出判断结果。

既然正溢出可以用逻辑运算与`&&`和位运算符`&`来获得，那么负溢出的分析也是相同的，这里就不再赘述。

然后就是分析`溢出后，怎么确定正负溢出然后返回对应的边界值`的问题。这里放下答案中对于这个问题处理的代码：

```C
(pos_over && (sum = INT_MAX) || neg_over && (sum = INT_MIN));
```

这里还是利用了逻辑运算与`&&`的短路特性：如果正溢出，则执行`sum = INT_MAX`；如果负溢出，则执行`sum = INT_MIN`。

截至今天下午16：49分，研究完毕两个题目，现在需要慢下脚步来考虑下下一步该怎么走。

### 职业规划

java应该是不想走了，我想往底层发展，而且我现在学的这些东西，都是为了以后能更好地在计算机底层方面大放光彩的。

那就选择C++和python。现在粘贴一张BOSS直聘上关于c++招聘的一些技能要求，然后看看该怎么发展：

第一个，编译器开发工程师：

<img src="C:\Users\28075\AppData\Roaming\Typora\typora-user-images\image-20240202165334019.png" alt="image-20240202165334019" style="zoom:50%;" />

```
我们诚招对计算机体系结构和计算机系统（Computer Systems & Architecture）熟悉的研发工程师与我们团队中一群才华横溢的工程师一起工作，为未来的异构计算平台开发世界一流的计算机系统。
基本要求
● 计算机科学、自动化、电子与信息、数学等理工类相关专业本科及以上学历
● 全职、兼职或者实习（实习至少半年）
● 具有较强的责任心和学习能力，工作态度积极，敢于迎接挑战
职责描述
● 参与操作系统、编译器、计算库和相关软件的设计和实现
● 分析和开发基准测试和测试应用程序
● 配合产品部门进行产品的调度和计划
● 设计文档、测试文档及其他相关文档的编写和维护
技能和经验
● 精通 C/C++ 编程，有较强的算法和数据结构基础
● 熟悉计算机体系结构、操作系统和编译优化
● 熟悉并行计算和高性能计算
● 精通开发、测试、交付和维护生产质量的软件
● 拥有开源软件开发经验、为开源项目做过贡献以及与开源社区有合作经验者优先
● Computer Systems & Architecture 以及 Compiler 领域硕士或博士学位者优先
```

技能要求：

1. 精通 C/C++ 编程，学明白C++
2. 较强的算法和数据结构基础，需要学习ds
3. 熟悉计算机体系结构、操作系统和编译优化，这个在完成cs61a，csapp，以及对应的计算机组成、操作系统（pa）等对应课程后即可完成。
4. 熟悉并行计算和高性能计算--待研究
5. 拥有开源软件开发经验、为开源项目做过贡献以及与开源社区有合作经验者优先--在github上是否贡献过自己的力量。

另一个C++开发的例子：语音合成引擎开发工程师

<img src="C:\Users\28075\AppData\Roaming\Typora\typora-user-images\image-20240202170323254.png" alt="image-20240202170323254" style="zoom:50%;" />

技能要求：

1. 3年以上c++/c语言开发经验，好吧，算我熟悉？
2. 熟悉基本数据结构，基础功底扎实。同上文数据结构
3. 有构建大型c++软件的经验，熟练掌握设计模式--设计模式
4. 熟悉CPU体系结构，对ARM或者X86 CPU/ Register/Cache/Memory/Bus有较深入理解，会针对硬件特性就关键计算瓶颈做分析--同计算机底层结构分析
5. 熟悉ARM neon/X86 AVX2/512 指令集，有过使用SIMD指令做具体算法优化的经验。--还是熟悉的指令集调用者，PA！

再次确认下自己今年的学习路线吧。

## 2.3

本周任务：

1. 收尾工作：做完2.75和cs61a的1.6和1.7章节
2. 周报总结
3. 找一个合适的离线音乐播放器（暂定为椒盐音乐）

## 2.4

昨日与徐某艺术馆一游，遇见学妹校友。

今天：

- [x] 回顾2.73和2.74题目
- [ ] 新做2.75题目（不会就立刻研究答案，并且写下思路）
- [ ] 研究originOS4的新用法
- [x] 研究vivo个人模式
- [x] 研究离线音乐相关问题，并且将歌单音乐导入其中
- [x] 将手机及其原始照片数据切换至vivo+切换移动资费
- [x] 关闭apple的在线服务（仍保存云空间）

为了更好地消费时间，现在采用番茄todo25分钟计数，然后放松5分钟回顾下自己到底学到了什么。

第一个番茄时钟结束，完成2.74和2.73的题目重写，这里再具体研究下逻辑运算符。

回顾2.74题目，发现在最后返回是否溢出的时候，两个溢出标志用了逻辑运算符`||`：

```c
  res = res && !(pos_over || neg_over);
```

在这分析下这句话的作用：

首先是括号内的`pos_over || neg_over`，这里的意思是：当正溢出或者负溢出时候，此条件成立。即只要是溢出了，则此括号内的运算结果为1。

那此时`!(pos_over || neg_over)`就相当于一个mask：若计算结果溢出，则返回0；若不溢出，则返回1。

那我有个疑问，这个mask就是一个根据是否正溢出或者负溢出而判断溢出的标志掩码，那么我能否在括号内将`||`换为`&&`？

那此时只要有一个溢出标志为假，那么这个mask的取值就会成为：若两边都溢出，则返回0；若其中有一个溢出或者都不溢出，则返回1。这样与题目的要求不符合：只要溢出，则返回0。

所以这个`||`不能换为`&&`。

第二个番茄时钟完成，完成上文分析。

在做75题目的时候，发现课后习题是跟课文内容强关联的。所以我觉得后期优化csapp学习的方法就是，先快速浏览一遍内容，尽量按照习题去过基础内容。

75题目是关于补码和无符号整数的乘法运算，这里重新回顾下之前的无符号和补码的乘法运算。

比较重要的是：补码的乘法结果 = 无符号数的乘法结果取模后再转换为补码形式的结果。

发现不会做，直接看答案：

```C
/*
 * unsigned-high-prod.c
 */
#include <stdio.h>
#include <assert.h>
#include <inttypes.h>

int signed_high_prod(int x, int y) {
  int64_t mul = (int64_t) x * y;
  return mul >> 32;
}

unsigned unsigned_high_prod(unsigned x, unsigned y) {
  /* TODO calculations */
  int sig_x = x >> 31;
  int sig_y = y >> 31;
  int signed_prod = signed_high_prod(x, y);
  return signed_prod + x * sig_y + y * sig_x;
}

/* a theorically correct version to test unsigned_high_prod func */
unsigned another_unsigned_high_prod(unsigned x, unsigned y) {
  uint64_t mul = (uint64_t) x * y;
  return mul >> 32;
}

int main(int argc, char* argv[]) {
  unsigned x = 0x12345678;
  unsigned y = 0xFFFFFFFF;

  assert(another_unsigned_high_prod(x, y) == unsigned_high_prod(x, y));
  return 0;
}
```

看代码的时候，发现有人评论：

![image-20240204152211555](C:\Users\28075\AppData\Roaming\Typora\typora-user-images\image-20240204152211555.png)

> can I ask one question?
> why `int64_t mul = (int64_t) x * y;`must here explicit cast then implicit cast?(I thought I have seen related contents in csapp, but search "explicit" found nothing related)

额，为什么在x * y的时候强制类型转换为64位的。这里蕴含着两个问题：

1. 这个强制类型转换做了什么操作
2. 为什么要做这个操作

其实我现在知道的是x和y的补码乘积会溢出（例如x = INT_MIN、y = INT_MIN时，x*y的结果会超出32位的范围），溢出后计算机会自动将其高32位去除，保留低32位。这样也等效于结果取2的32次方的模。

所以需要将其计算结果转为64位，然后才能保存乘法运算中溢出的高位数据。

但是这个`(int64_t) x*y`，是先将x和y转为64位后（等价于`(int64_t) x * (int64_t) y`）再运算呢还是将计算结果（等价于`(int64_t)x*y`）转为64位呢？我不了解，因为我不清楚乘法运算符和类型转换符号的先后顺序，以及能否在得到结果后再强制类型转换。

那就首先解决这个类型转换和乘除法的优先级问题。

在菜鸟教程[C 强制类型转换](https://www.runoob.com/cprogramming/c-type-casting.html)中，示例代码非常贴合现在我们遇到的问题：

```C
#include <stdio.h>
 
int main()
{
   int sum = 17, count = 5;
   double mean;
 
   mean = (double) sum / count;
   printf("Value of mean : %f\n", mean );
 
}
```

下面对这个代码的解释也很到位：

> 这里要注意的是强制类型转换运算符的优先级大于除法，因此 **sum** 的值首先被转换为 **double** 型，然后除以 count，得到一个类型为 double 的值。

关于强制类型转换和乘除法的运算优先级，查询chat-gpt：

> 由于 `x` 被强制类型转换为 `int64_t`，整个表达式会采用更宽的整数类型（`int64_t`）进行计算，因此 `y` 会隐式地升级到 `int64_t`，避免了整数溢出的问题。

其实这样就解决了这个问题的两个疑惑：

1. 这个强制类型转换做了什么操作？

   答：将参数`x`的类型转换为 `int64_t`。

2. 为什么要做这个操作？

   答：想让x和y的乘积不溢出。这需要让结果类型为64位，这样就需要将两个参数进行升级。

   但是现在可以利用C语言的类型升级（涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别）来简化代码书写规则：只需要将其中一个参数x升级为64位的类型，另一个低级类型参数y在参与运算的过程中会被自动转换为64位的数据。

   这样两个64位的数据得到的结果是64位的数据，正好可以保存32位int类的乘法溢出的高位数据，解决了溢出问题。

## 2.5

今天主要任务是cs61a的项目，学到了关于debug的相关问题和lab1的一些题目，感觉挺简单的。

但是lab1的debug可以再看看，还有课本也可以再回顾下（卡好时间，不会就查

## 2.6

今天意识到昨天没怎么记录自己的所做的事情。今天就从第一个番茄todo开始，记录自己的时间使用情况。

首先继续cs61a的课程计划。下面写下本周待办清单

- [x] 30mins对比[Lab1答案](https://cs61a.org/lab/sol-lab00/)（15分钟即可搞定）
- [ ] 1h重读cs61a课本关于1-7节的内容
- [ ] [ Disc 01: Control, Environment Diagrams](https://cs61a.org/disc/disc01/)
- [ ] [Hog](https://cs61a.org/proj/hog/)
- [ ] [HW 02: Higher-Order Functions](https://cs61a.org/hw/hw02/)
- [ ] [Lab 02: Higher-Order Functions, Lambda Expressions](https://cs61a.org/lab/lab02/)
- [ ] [Disc 02: Environment Diagrams, Higher-Order Functions](https://cs61a.org/disc/disc02/)
- [x] 研究2.75题目
- [ ] csapp2.76-2.80
- [ ] 确认c++学习路线

对比Lab1答案，关于Q3: Falling Factorial

> ### Q3: Falling Factorial
>
> Let's write a function `falling`, which is a "falling" factorial that takes two arguments, `n` and `k`, and returns the product of `k` consecutive numbers, starting from `n` and working downwards. When `k` is 0, the function should return 1.
>
> ```python
> def falling(n, k):
>     """Compute the falling factorial of n to depth k.
> 
>     >>> falling(6, 3)  # 6 * 5 * 4
>     120
>     >>> falling(4, 3)  # 4 * 3 * 2
>     24
>     >>> falling(4, 1)  # 4
>     4
>     >>> falling(4, 0)
>     1
>     """
>     "*** YOUR CODE HERE ***"
> ```

官方提供的算法很简单：

```python
def falling(n, k):
	total, stop = 1, n-k #设置边界stop
    while n > stop:
        total, n = total*n, n-1
    return total
```

对比lab1的答案已经在第一个番茄时钟内完成。下两个番茄时钟主要是略读一遍cs61a的课本，因为接下来的项目需要用到里面更多的内容。

因为阅读原英文手册极其费劲（会注意力涣散），所以我搜了搜如何让自己英语阅读速度更快：[如何提高英文阅读速度？](https://www.zhihu.com/question/19559519)

重新学习课本，整理以下知识点：

1. 为什么称为变量？因为在程序执行的不同时段，名称可以跟不同的值进行绑定：In Python, names are often called *variable names* or *variables* because they can be bound to different values in the course of executing a program.

2. 利用py会优先执行赋值语句等号右边的表达式，所以交换值很方便：With multiple assignment, *all* expressions to the right of `=` are evaluated before *any* names to the left are bound to those values. As a result of this rule, swapping the values bound to two names can be performed in a single statement.

   ```python
   >>> x, y = 3, 4.5
   >>> y, x = x, y
   >>> x
   4.5
   >>> y
   3
   ```

3. print作为“非纯函数”的代表，除了返回一个`None`外，还会产生额外输出

   ```py
   >>> print(print(1), print(2))
   1
   2
   None None
   ```

4. Both `def` statements and assignment statements bind names to values, and any existing bindings are lost.

   ```py
   >>> def g():
           return 1
   >>> g()
   1
   >>> g = 2
   >>> g
   2
   >>> def g(h, i):
           return h + i
   >>> g(1, 2)
   3
   ```

5. The return expression is not evaluated right away; it is stored as part of the newly defined function and evaluated only when the function is eventually applied.

6. An `import` statement binds a name to a built-in function. A `def` statement binds a name to a user-defined function created by the definition. 

7. Applying a user-defined function introduces a second *local* frame, which is only accessible to that function.The environment in which the body is evaluated consists of two frames: first the local frame that contains formal parameter bindings, then the global frame that contains everything else.

8. The body of a function is not executed until the function is called (not when it is defined).

9. In *environment* ,each function is a line that starts with `func`, followed by the function name and formal parameters.

10. *scope*:We say that the *scope* of a local name is limited to the body of the user-defined function that defines it.

11. abstractions in functions:A programmer should not need to know how the function is implemented in order to use it. 

ok，截止到下午2点31分，重读完了1-3节。然后跑了10km。

回来研究2.75，发现被函数`unsigned_high_prod(x, y)`卡住：

```C
unsigned unsigned_high_prod(unsigned x, unsigned y) {
  /* TODO calculations */
  int sig_x = x >> 31;
  int sig_y = y >> 31;
  int signed_prod = signed_high_prod(x, y);
  return signed_prod + x * sig_y + y * sig_x;
}
```

这里翻译一下最终的结果：无符号乘积的高32位 = 对应有符号乘积的高32位 + x * y的符号位 + y * x的符号位。

这里涉及到有符号和无符号数的乘法规则：

<img src="C:\Users\28075\AppData\Roaming\Typora\typora-user-images\image-20240206191327119.png" alt="image-20240206191327119" style="zoom:50%;" />

## 2.7

今天继续本周目标。但是需要注意提升效率，因为没有ddl，所以做起事情来没有目标并且速度很慢。

其实真正学习知识慢一点完全没问题，但是像是英语阅读速度就是制约前进的巨大阻碍。

所以我今天在《刻意练习》这本书中找一下关于“如何提升英语阅读水平”的相关灵感。![image](https://s3.cn-north-1.amazonaws.com.cn/assets.xmind.cn/uploads/img/ff9569217a1586a5850a28b1661599f2.png)

把《刻意练习》下载到kindle里，很感兴趣作者是怎么举例的。

查询了下，现在对于英文阅读能力的要求是每分钟400个单词。

现在回到[如何提高英文阅读速度？](https://www.zhihu.com/question/19559519/answer/380807713
)，这里面介绍了四个提升英语阅读速度的方法：

1.  避免默读：对于阅读理解来说，你只需要看到文字并理解字面意思即可，不需要知道它的读音。如何解决默读问题？**关键还是要靠你的意识，你要在脑海里刻意地不断提醒自己不要去想它的发音。**
2. 意群阅读：将句子结构抽象为一个个的块，而不是一个个孤立的单词。**解决了默读的问题，我们已经能确保停顿的时间都花在获取字面信息上，所以接下来要提高的就是每次停顿获取的信息量。**如果每次凝视只能看到一个单词的话，你获取信息的效率就太低了，而你应当看到的是一个短语、词组、一部分信息，也就是我们说的意群。意群的快速划分需要大量阅读的积累。掌握的意群阅读的原理后，在阅读的过程中要不断尝试扩大每次凝视的宽度，从而在单位时间内获取更多的信息。
3. 主动阅读：要精准阅读，带着问题去读
4. 语法：主谓

总结一下训练方法：

1. 停止默读单词
2. 组块阅读而不是每个单词的阅读
3. 带着问题去阅读
4. 大量阅读英语文章重复训练上述三个能力

现在是9点半，半小时看看能否用以上三个能力去重新阅读完cs61a的第3节。（可以）

**Name Evaluation.** A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found.

Tests typically take the form of another function that contains one or more sample calls to the function being tested.

现在花了28分钟看完了1.5章节，但是很困。下午跑完了10km，因为在1.6节遇到了困难：

1. 牛顿法不了解
2. 嵌套程序不熟悉
3. currying法不熟悉

这几个问题导致我现在难以进行下去，明天先把这几个概念和程序写一遍，然后再去阅读材料。

明天可以加入一篇外刊阅读，卡时间读完，锻炼英语阅读的速度。

## 2.8

ok，今天主要任务就是将1.6节涉及到的概念弄明白，然后再通读一遍。如果有余力，那么请将2.75和csapp进度继续推进。

今天可以看下关于微积分的学习。

首先是了解牛顿方法：[Newton's method](https://amsi.org.au/ESA_Senior_Years/SeniorTopic3/3j/3j_2content_2.html)

了解完毕，继续看1.6，这次先把里面涉及的代码跑一遍去理解下，然后再通读一遍。

## 2.9

昨天下午直接帮忙干活（帮忙吃东西）

今天继续1.6。

1. An important feature of lexically scoped programming languages is that locally defined functions maintain their parent environment when they are returned. 

## 2.10

新年快乐，祝你新的一年Be open and go beyond yourself !

## 2.11

今天要去姥爷家玩了。

去之前看看材料。

## 2.13

ok，昨天郑兆乐来玩的，玩了玩双人成行，放松一下。

今天学习学习hog。

## 2.14

昨天跟姑姑姑父聊了下学习方面的问题，期待两位小伙子的成绩。

今天主要是去国栋大哥家站站，聊聊天。

继续hog项目。然后今天阅读下《丹尼尔斯的跑步训练》，为今年的马拉松做准备。除此以外，确定下今年的阅读书单，博客园开一个书单栏目，准备今年的阅读。

另外为了督促自己的学习，也在博客园开自己的cs61a和csapp的学习记录。

csapp的学习以梳理知识点，记录一些课后作业（有意思的题目）为主。

cs61a的话，因为有很多课后作业，暂且将自己的学习记录贴上吧，等以后再考虑具体创作方向。

今天就是打开博客园，开三个栏目，讲述自己以后想在每个模块想做的事情。

![image-20240214181052403](C:\Users\28075\AppData\Roaming\Typora\typora-user-images\image-20240214181052403.png)

## 2.15

上午完成hog规则部分的全部内容。

现在搞一下让我一直头疼的csapp2.75问题。

2.75题目描述

> Suppose we want to compute the complete 2w-bit representation of x . y, where
> both x and y are unsigned, on a machine for which data type
>
> unsigned is w bits.
> The low-order w bits of the product can be computed with the expression x*y, so
> we only require a procedure with prototype
>
> ```C
> unsigned unsigned_high_prod(unsigned x, unsigned y);
> ```
>
> that computes the high-order w bits of `x*y` for unsigned variables.
> We have access to a library function with prototype
>
> ```C
> int signed_high_prod(int x, int y);
> ```
>
> that computes the high-order w bits of x . y for the case where x and y are in two’scomplement
> form. Write code calling this procedure to implement.
>
> the function
> for unsigned arguments. Justify the correctness of your solution.
>
> **Hint**: Look at the relationship between the signed product x . y and the unsigned
> product x
>  . y
>  in the derivation of Equation 2.18.

等式2.18为：
$$
(x'.y') mod 2^\omega =
[(x + x_{\omega-1}.2^\omega).(y + y_{\omega-1}.2^\omega)]mod2^\omega
\\= [x.y+(x_{\omega-1}.y+y_{\omega-1}.x)2^\omega+x_{\omega-1}y_{\omega-1}2^{2\omega}]
\\=(x.y)mod 2^\omega
$$
这个问题抽象为程序语言的话，就是：

> 乘法得出的2w位数据被保存在2w位变量`unsigned_prd`中，
>
> 分别再用w位的变量`unsigned_high_bits`和`unsigned_low_bits`，分别去保存变量`unsigned_prd`的高w位和低w位。

协助完成这个保留无符号数乘法结果高w位的方法，是对应有符号数保留高w位的方法`signed_high_prod`。

我们需要找到有符号数高w位和无符号数高w位之间的关系，因为我们已经知道无符号数乘法和有符号数乘法最终结果的二进制表示是一致的，而最终结果就是乘法的结果对`2^w`求模运算得来的。

假设不截断无符号整数的乘法结果（2w位）：`unsigned_prd = ux * uy` 

那么截断为低w位的结果为：`unsigned_low_bits = unsigned_prd mod 2^w`.

这样乘法结果的高w位数据就可以得出：`unsigned_high_bits =  (unsigned_prd - unsigned_low_bits ) mod 2^w`

这里需要强调下，`unsigned_prd`是2w位的无符号变量，而保存其高、低w位的无符号变量`unsigned_high_bits`和`unsigned_low_bits`均为w位数据。

同理也可以得到有符号数的高低w位数据，其实公式都相同，只是把unsigned改为signed。

上述分析结束，就可以利用公式去推导下“如何利用有符号数乘法的高w位去表示无符号数的高w位”，我这里想用markdown自带的公式写的，寻思这样更清晰一些，但是上面等式2.18敲完了我就打了退堂鼓--因为语法太麻烦了！

这样我就在这贴一下自己手写的推导公式：<img src="C:\Users\28075\Desktop\17079823282211707982166990.jpg" alt="2.75solution" style="zoom:50%;" />

这样再去理解代码就方便很多了。贴一下[2.75答案](https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter2/2.75/)

```C
/*
 * unsigned-high-prod.c
 */
#include <stdio.h>
#include <assert.h>
#include <inttypes.h>

int signed_high_prod(int x, int y) {
  int64_t mul = (int64_t) x * y;
  return mul >> 32;
}

unsigned unsigned_high_prod(unsigned x, unsigned y) {
  /* TODO calculations */
  int sig_x = x >> 31;
  int sig_y = y >> 31;
  int signed_prod = signed_high_prod(x, y);
  return signed_prod + x * sig_y + y * sig_x;
}

/* a theorically correct version to test unsigned_high_prod func */
unsigned another_unsigned_high_prod(unsigned x, unsigned y) {
  uint64_t mul = (uint64_t) x * y;
  return mul >> 32;
}

int main(int argc, char* argv[]) {
  unsigned x = 0x12345678;
  unsigned y = 0xFFFFFFFF;

  assert(another_unsigned_high_prod(x, y) == unsigned_high_prod(x, y));
  return 0;
}
```

欢迎讨论csapp的相关问题~😉

## 2.16

今日：

- [x] 2h cs61a
- [x] 阅读1h
- [ ] csapp 2h

还有比较重要的是，我下一步的学习和生活道路是什么。

## 2.17

昨日烦恼的超哥来到了这里，祝愿兄弟能一切顺利吧。

hog的项目来到了问题8。

## 2.18

早起跑步10km，跑到水闸附近有股鱼腥味。

# 新的一周2. 19-2. 25

## 2.19

在写`def make_averaged(original_function, samples_count=1000):`函数的时候，发现函数很容易实现，但是加入实际的情景就没法理解。现在在这里记录下自己遇到的问题：

### Problem 8 (2 pt)问题描述	

> Implement `make_averaged`, which is a higher-order function that takes a function `original_function` as an argument.
>
> The return value of `make_averaged` is a function that takes in the same number of arguments as `original_function`. When we call this returned function on the arguments, it will return the average value of repeatedly calling `original_function` on the arguments passed in.
>
> Specifically, this function should call `original_function` a total of `samples_count` times and return the average of the results of these calls.

### 问题解析

这个问题其实很简单。`make_averaged`函数接受两个参数：

1. `original_function`：接受n个参数，返回一个值
2. `samples_count`：重复调用函数A的次数

接受了两个入参后，返回一个函数（高阶函数，将函数作为返回值）。这个函数接受的参数与`original_function`接受的参数相同。调用这个新函数的时候，会返回重复调用`samples_count`次`original_function`的值。

### 疑问

但是在检测自己是否理解这个函数（`python3 ok -q 08 -u`）的选项中，对于这个问题我总是答错：

```python
>>> from hog import *
>>> dice = make_test_dice(3, 1, 5, 6)
>>> averaged_roll_dice = make_averaged(roll_dice, 1000)
>>> # Average of calling roll_dice 1000 times
>>> # Enter a float (e.g. 1.0) instead of an integer
>>> averaged_roll_dice(2, dice)
?
```

在我理解中，`dice`被定义好后，每次调用`dice`就会指定下一个值，然后循环如此。（这个坑好久之前就被埋好了😒 ）

`roll_dice`呢，就是一个函数，接收投掷总数和骰子类型，返回投多个骰子的总点数（遵循sow sad原则）。

那么既然说这个`make_averaged`函数是重复调用`samples_count`次`original_function`的值，那么就先看看在这里调用一次`original_function`的效果，然后看看重复调用`samples_count`的效果。

1. `roll_dice(2, dice)`：这个函数就是`make_averaged`参数1。这个函数投掷两次骰子，然后算总和。例如第一次投掷两枚骰子，结果分别为3和1，符合“sow sad”原则，所以这次结果为1。
2. 重复调用`samples_count`次的结果：这就是我卡住的地方，也是需要反思的地方。

### 解决思路

这里因为我并没有深入理解`dice`函数的机制，导致我并不理解重复调用`dice`到底有什么效果。下面贴上`dice`的代码，学习一下嵌套函数如何利用`nonlocal`将修改上一层函数的变量:

```py
def make_test_dice(*outcomes):
    """Return a die that cycles deterministically through OUTCOMES.

    >>> dice = make_test_dice(1, 2, 3)
    >>> dice()
    1
    >>> dice()
    2
    >>> dice()
    3
    >>> dice()
    1
    >>> dice()
    2

    This function uses Python syntax/techniques not yet covered in this course.
    The best way to understand it is by reading the documentation and examples.
    """
    assert len(outcomes) > 0, 'You must supply outcomes to make_test_dice'
    for o in outcomes:
        assert type(o) == int and o >= 1, 'Outcome is not a positive integer'
    index = len(outcomes) - 1
    def dice():
        nonlocal index
        index = (index + 1) % len(outcomes)
        return outcomes[index]
    return dice
```

这里的`dice()`函数中，使用`nonlocal index`的声明，`dice()`可以修改`make_test_dice`的局部变量`index`。

这样代码就好理解了：

```py
>>> dice = make_test_dice(3, 1, 5, 6)
```

`dice`每次调用的时候，都会改变`make_test_dice`的局部变量`index`。这样`index`就会循环往复地在`[0, len(outcomes) - 1]`中徘徊。

使用 `nonlocal` 关键字可以指示 Python 解释器在嵌套函数中查找并修改上一层函数的局部变量。

这样再去看`roll_dice(2, dice)`重复调用`samples_count`次的结果：第一次投掷两个骰子，结果分别为3和1，得分为1；第二次投掷两个骰子，结果分别为5和6，得分为11；第三次投掷两个骰子，结果分别为3和1，得分为1...

这样重复调用的结果就是1和11，重复1000次的平均值就是（1 * 500 +11 * 500） / 1000  = 6.0。

### 总结

1. 请读源码：调用函数解决问题前，需要详细理解每一个函数到底做了什么。
2. 遇到问题：那肯定是你代码没弄明白又或者是出现了bug，请再次重新回顾代码，做到详尽理解和测试。
3. 偷懒被教育：`nonlocal`关键字懒得查，注释` This function uses Python syntax/techniques not yet covered in this course.
       The best way to understand it is by reading the documentation and examples.`也懒得理解，最终导致了让我跌了个跟头。而这个坑又是自信的我亲手埋下的。

## 2.20

一三五七八十腊，三十一天永不差。还有九天，二月份就过完了。

今天想把hog弄完，然后回顾下自己这一个月的优势和不足，整理份书单，阅读。

然后试着看看能否找到一条正常学习csapp的道路？现在这样的学习太累了。（找到累在哪里了？然后怎么解决这个问题）

### 问题9

> Implement `max_scoring_num_rolls`, which runs an experiment to determine the number of rolls (from 1 to 10) that gives the maximum average score for a turn. Your implementation should use `make_averaged` and `roll_dice`.
>
> If two numbers of rolls are tied for the maximum average score, return the lower number. For example, if both 3 and 6 achieve a maximum average score, return 3.
>
> You might find it useful to read the doctest and the example shown in the doctest for this problem before doing the unlocking test.
>
> > **Important:** In order to pass all of our tests, please make sure that you are testing dice rolls starting from 1 going up to 10, rather than from 10 to 1.

函数原型描述：

```py
def max_scoring_num_rolls(dice=six_sided, samples_count=1000):
    """Return the number of dice (1 to 10) that gives the highest average turn score
    by calling roll_dice with the provided DICE a total of SAMPLES_COUNT times.
    Assume that the dice always return positive outcomes.

    >>> dice = make_test_dice(1, 6)
    >>> max_scoring_num_rolls(dice)
    1
    """
    # BEGIN PROBLEM 9
    "*** YOUR CODE HERE ***"
    # END PROBLEM 9
```

### 分析

这个函数想实现：给定一个`dice()`，然后确定这个骰子扔多少个（`num_rolls`）才能在函数`make_averaged()`中获取最大平均值。

在这举个例子，看下函数`roll_dice(num_rolls, dice)`以相同的点数策略`dice()`，但是在不同的骰子数量`num_rolls`的影响下，产生的结果。这里先固定下`dice()`函数的策略：

```py
>>> dice = make_test_dice(3, 1, 5, 6)
```

然后看下`roll_dice(num_rolls, dice)`在不同的骰子数量`num_rolls`的影响下（这里仅举1、2、3数量，其他数量可以自行推算💦），产生的结果：

1. `num_rolls = 1`：反复调用`roll_dice()`函数，省略各个骰子的结果，可以得到分数分别为：3、1、5、6。各个结果的概率均为1/4。
2. `num_rolls = 2`：反复调用`roll_dice()`函数，省略各个骰子的结果，分数分别为1、11。得到每个结果的概率为1/2
3. `num_rolls = 3`：反复调用`roll_dice()`函数，骰子的结果分别为：`3,1,5`、`6,3,1`、`5,6,3`、`1,5,6`、`3,1,5`...这是4个得分循环，每次得分分别为：1、1、14、1。各个结果的概率均为1/4。

这个例子说明，函数`roll_dice(num_rolls, dice)`在相同的点数策略`dice()`，而在不同的骰子数量`num_rolls`的影响下，重复调用会出现完全不一致的结果。这样就会导致函数`make_averaged()`在选用`相同点数策略但是不同骰子数量`的`roll_dice()`时候，得到的结果不一致。

所以要确定：函数`roll_dice(num_rolls, dice)`以相同的点数策略`dice()`，但是以多少骰子数量`num_rolls`才能在函数`make_averaged()`获取到较大的平均值。

### 实现

```py
def max_scoring_num_rolls(dice=six_sided, samples_count=1000):
    """Return the number of dice (1 to 10) that gives the highest average turn score
    by calling roll_dice with the provided DICE a total of SAMPLES_COUNT times.
    Assume that the dice always return positive outcomes.

    >>> dice = make_test_dice(1, 6)
    >>> max_scoring_num_rolls(dice)
    1
    """
    # BEGIN PROBLEM 9
    "*** YOUR CODE HERE ***"
    i = num_rolls = 1
    higher_avg_score = 0
    while i <= 10:
        avg_score = make_averaged(roll_dice, samples_count)(i, dice)
        if avg_score > higher_avg_score:
            higher_avg_score = avg_score
            num_rolls = i
        i += 1
    return num_rolls
    # END PROBLEM 9
```

## csapp问题

今天将csapp单独作为一章节来讨论，探讨下自己学习csapp遇到的困难和未来学习规划。

## cs61a回顾

从1月25开始到2.20，完成第一个项目hog。

总结让自己进度慢的主观因素：

1. **妄图一次阅读掌握所有知识**：违反了[《为什么学生不喜欢上学》](https://book.douban.com/subject/4864832/)中`大脑不是用来思考的，它的真正作用在于使你避免思考`的前提，避免让自己学习新知识感到有阻碍是最重要的。[cs61a的课本](https://www.composingprograms.com/)难度还是有的啊！

2. **非母语阅读的困难**。虽然我自诩英语还不错，但是我的英语自信在这里被击的粉碎。所谓“越挫越勇”，那时候发现自己阅读英文能力慢，及时搜索了提升英语阅读的速度方法：[如何提高英文阅读速度？](https://www.zhihu.com/question/19559519)。

3. **其次就是例子不了解**。书中为了让学生更好地理解抽象的概念，每个概念后面作者都提供了促使学生理解的函数程序，同时贴心地提供了类似于`debug`按钮，让学生单步调试。但是我在阅读之前，根本没有好好理解并且调试这个程序，导致我在阅读晦涩难懂的抽象概念的同时，还要思考例子中的代码逻辑，简直难上加难！🤯但是如果书中的例子都事先理解了，那么文章就没那么困难了（背景知识的重要性不言而喻，就像年前阅读1.6，对于里面的很多概念类似牛顿法、嵌套和currying等不了解，然后先放下课本1.6节去研究这三个东西，研究完了再去阅读1.6就感觉轻松许多）。

4. **没有DDL带来的紧迫感**。因为没有具体的ddl和学习规划，学习效率大打折扣。经常会因为高度思考遇到挫折后，选择转移注意力来放松保护下脆弱的自己（😥）。

5. **阅读时没有方向**：这个问题是很困扰的。因为没有问题作为阅读的驱动力，在阅读课程材料的时候，无法调用太多的主观能动性。

6. **不动手实践**。嗯，怎么检验自己是否对于概念理解了呢？最起码书中的例子得过一遍吧？只看概念不动手实践，懒惰导致的问题。

这几个问题的解决方案，我也在这里整理下：

1. 理解背景知识：为了爱护自己的大脑，避免自己过度思考，请：
   1. 首先请提升英语阅读速度；
   2. 阅读材料之前请先观看视频对内容进行梳理；
   3. 请将书中的例子认真过一遍；
   4. 请略读先混个眼熟，不要妄图一次阅读掌握所有概念。
2. DDL的问题：放到后面计算机学习计划一起做吧。
3. 阅读时没有方向：可以试一下看完视频课和ppt直接入手题目，然后不会了再去翻看课本的具体概念介绍，这样可能更轻松些。
4. 懒惰：懒？md，不写程序是吧，不写也甭想活着！

ok，现在是2024年2月20号15:58分，我该去做晚饭了，一会回来继续整理csapp的相关问题。（我发现有问题还是得周报反馈，这样一个月的反馈周期太长了！很多问题早就出现了，但是一直被自己忽略了，下次**周报必须做！！！！！**）

## cs学习之路

确定大概学习方向和课程。

## 2.21

### How to draw an Environment Diagram

![image-20240221101304130](C:\Users\crx\AppData\Roaming\Typora\typora-user-images\image-20240221101304130.png)

这里解释下打星号的2：

 `Copy the parent of the function to the local frame: [parent=<label>]`：意思是将`定义原函数的frame`名称作为`<label>`，放在这个`local frame: [parent=<label>]`中。

下面举个例子（代码来自[1.6  Higher-Order Functions](https://www.composingprograms.com/pages/16-higher-order-functions.html)的`1.6.3  Defining Functions III: Nested Definitions`）：

```py
def average(x, y):
    return (x + y)/2

def improve(update, close, guess=1):
    while not close(guess):
        guess = update(guess)
    return guess

def approx_eq(x, y, tolerance=1e-3):
    return abs(x - y) < tolerance

def sqrt(a):
    def sqrt_update(x):
        return average(x, a/x)
    def sqrt_close(x):
        return approx_eq(x * x, a)
    return improve(sqrt_update, sqrt_close)

result = sqrt(256)
```

让我们看下当程序执行到`sqrt(256)`但是还未执行到`return improve(sqrt_update, sqrt_close)`时候的环境：

![image-20240221102433295](C:\Users\crx\AppData\Roaming\Typora\typora-user-images\image-20240221102433295.png)

可以得知当调用存在于`[parent= Globa]`函数`sqrt()`的时候：

1. 新增本地栈：新增一个名为`sqrt`的本地栈，代号为`f1`。（todo：`f1`应该是代号或者标签，类似指针的作用，下面统一用“标签”）。
2. 注明上级栈：`The parent of a function is the frame in which it was defined`。将原型函数`sqrt()`的栈**`Global`**作为这个本地栈`sqrt`的上级栈。
3. 参数传递：将传入的实参`256`赋值给形参`a`，现在`a = 256`。
4. 嵌套函数定义：`sqrt_update(x)`和`sqrt_close(x)`定义在此本地栈中，且两个函数的上级栈均为当前`sqrt`的本地栈，即`f1`。

从这个计算`sqrt(256)`的部分，就可以将上面`调用函数和定义函数时候的环境图表`如何画概念理解清晰了。

例子2：

```py
def cake():
   print('beets')
   def pie():
       print('sweets')
       return 'cake'
   return pie
chocolate = cake()
```

提供一个[Python图形化代码执行过程](https://pythontutor.com/cp/composingprograms.html#mode=edit)的网站，输入代码执行，多尝试一下~😉

[例子3](https://cs61a.org/disc/disc02/)：

```py
def team(work):
    return t(work) - 1
def dream(work, s):
    if work(s-2):
        t = not s
    return not t
work, t = 3, abs
team = dream(team, work + 1) and t
```

### 修改Python别名

发现课程提供的启动python程序的命令均为`python3`，而我们的环境中只能用`python`来启动 Python 解释器，可以通过修改python的别名来实现不同名称调用同一个程序的效果。

1. **配置命令别名:** 如果你想使用 `py`、`py3`、`python3` 这些别名，你可以创建一个 `py.bat` 文件（同理 `py3.bat`、 `python3.bat`）并将其添加到系统路径。在 `C:\Users\<YourUsername>\AppData\Local\Programs\Python\Python3x\Scripts` 目录（这个是你自己安装python程序的目录）下创建一个名为 `py.bat` 的文本文件，其中内容如下：

   ```bat
   @echo off
   C:\Users\<YourUsername>\AppData\Local\Programs\Python\Python3x\python.exe %*
   ```

   将 `<YourUsername>` 替换为你的用户文件夹名。然后，将 `C:\Users\<YourUsername>\AppData\Local\Programs\Python\Python3x\Scripts` 添加到系统路径中。

2. **保存并关闭所有窗口:** 确保保存所有打开的窗口，并关闭命令提示符等。

3. **验证配置:** 打开新的命令提示符窗口，并输入以下命令进行验证：

   ```bat
   bashCopy codepython --version
   py --version
   py3 --version
   python3 --version
   ```

   如果配置正确，你应该能够看到 Python 的版本信息。

现在，应该能够正常使用 `py`、`py3`、`python3` 以及 `python` 命令调用 Python 解释器。

### [Short Circuiting](https://cs61a.org/lab/lab02/)

| Operator | Checks if:                 | Evaluates from left to right up to: | Example                                |
| :------- | :------------------------- | :---------------------------------- | :------------------------------------- |
| AND      | All values are true        | The first false value               | `False and 1 / 0` evaluates to `False` |
| OR       | At least one value is true | The first true value                | `True or 1 / 0` evaluates to `True`    |

Short-circuiting happens when the operator reaches an operand that allows them to make a conclusion about the expression. For example, `and` will short-circuit as soon as it reaches the first false value because it then knows that not all the values are true.

If `and` and `or` do not *short-circuit*, they just return the last value; another way to remember this is that `and` and `or` always return the last thing they evaluate, whether they short circuit or not. Keep in mind that `and` and `or` don't always return booleans when using values other than `True` and `False`.

#### 举例

```py
---------------------------------------------------------------------
The Truth Will Prevail > Suite 2 > Case 2
(cases remaining: 2)

What would Python display? If you get stuck, try it out in the Python
interpreter!

>>> print(3) or ""
```

#### 分析

1. `short-circuit operator`：之所以说`or`是“短路操作符”，是因为当第一个操作数为`True`的时候，`or`便会得出整体表达式为`True`的结论，这样就不会执行下一个操作数。（`and`同理）
2. 整体的返回值：就如上面所说，：`and` 和`or`总是会返回最后一个计算的值，无论他们是否短路。短路时，返回计算的第一个操作数（表达式）的值，不短路时就会返回计算的第二个操作数的值。

这样当表达式`print(3) or ""`执行到第一个操作数`print(3)`时，因为函数`print()`输出`3`后，返回的是`None`，`None` 在逻辑上被视为 `False`，因此会继续判断第二个操作数。这时候output只有一个`3`。计算第二个操作数`""`即为`''`空字符串，这时会输出`''`。

这样输出结果为：

```py
>>> print(3) or ""
3
''
```

## 2.22

回顾时间。

1. 高阶函数中，嵌套函数和以函数作为返回值的`Environment`怎么画？
2. Python中的短路操作符`and`和`or`的特性以及具体案例分析

### Lambda

```py
>>> (lambda: 3)()  # Using a lambda expression as an operator in a call exp.
```

经过查阅资料，理解了这个表达式要做的事情：

`(lambda: 3)()` 是一个 Lambda 表达式的调用，它表示创建了一个匿名函数（Lambda 函数），该函数不接受任何参数，而在执行时返回值为 `3`。

- `(lambda: 3)`: 这是一个 Lambda 表达式，使用 `lambda` 关键字定义一个匿名函数。这个特定的 Lambda 函数不接受任何参数，而且在执行时总是返回 `3`。
- `()`: 这是对 Lambda 函数的调用。通过在 Lambda 表达式后面加上一对小括号，就会调用这个函数。因为 Lambda 函数不接受参数，所以小括号是空的。

所以，`(lambda: 3)()` 的结果是 `3`，因为 Lambda 函数被调用并返回了 `3`。这种构造方式通常用于创建简单的匿名函数，特别是在需要传递函数作为参数的地方。

### 从右边开始寻找整数的第k位

Implement `match_k`, which takes in an integer `k` and returns a function that takes in a variable `x` and returns `True` if all the digits in `x` that are `k` apart are the same.

For example, `match_k(2)` returns a one argument function that takes in `x` and checks if digits that are 2 away in `x` are the same.

`match_k(2)(1010)` has the value of `x = 1010` and digits 1, 0, 1, 0 going from left to right. `1 == 1` and `0 == 0`, so the `match_k(2)(1010)` results in `True`.

`match_k(2)(2010)` has the value of `x = 2010` and digits 2, 0, 1, 0 going from left to right. `2 != 1` and `0 == 0`, so the `match_k(2)(2010)` results in `False`.

**Important:** You may not use strings or indexing for this problem.

Floor dividing by powers of 10 gets rid of the rightmost digits.

```py
def match_k(k):
    """Returns a function that checks if digits k apart match.

    >>> match_k(2)(1010)
    True
    >>> match_k(2)(2010)
    False
    >>> match_k(1)(1010)
    False
    >>> match_k(1)(1)
    True
    >>> match_k(1)(2111111111111111)
    False
    >>> match_k(3)(123123)
    True
    >>> match_k(2)(123123)
    False
    """
    def check(x):
        while x // (10 ** k) > 0:
            if (x % 10) != (x // (10 ** k)) % 10:
                return False
            x //= 10
        return True
    return check
```

分析：

1. 判断最后一位与右边数第k位数字是否相同：`(x % 10) != (x // (10 ** k)) % 10`
2. 如果不相同，则这个数肯定不符合题目要求，直接返回`False`
3. 如果相同，则将比较位置转为左手边的下一个数字：`x //= 10`

## 2.25 DDL下的背景知识学习实践

本周DDL：完结第二章的知识+1.7递归  + 并且练习一遍题目。

《为什么学生不喜欢上学》：

**思考技巧和知识点是密不可分的。**

**事实性知识要先于技能。**

这句话的个人理解：cs61a的材料中，既包含事实性的知识，也包括思考后的技能。

现在以1.7节"递归函数"为例，列举下我需要学习的东西：

### 1.7 递归函数

1. “递归的概念”，以及解释递归概念用到的函数 `sum_digits(n)`：“编写一个对自然数的所有数字位求和的函数的样例”。
2. 为了进一步理解递归函数，以上文的`sum_digits(n)`为例，介绍了“*递归函数的常见模式*”：`base case`，以及递归调用的特点，并且举例“阶乘函数”：`fact_iter(n)`
3. 介绍互递归的概念，并且用“一个互递归函数来确定一个数字是偶数还是奇数”例子来论证这个概念。
4. 为了更好地理解递归函数的调用过程，实现一个`cascade` 函数：该函数按从大到小再到大的顺序，打印一个数字的所有前缀；另一个例子就是“拿走石子”的游戏例子。
5. 介绍了概念“树递归”的概念，并且举例计算“斐波那契数列”的例子，来帮助理解这个概念。
6. 最后用一个例子“分割数”作为本节的所有概念的应用，至此完结。

ok，经过这么整理，我发现里面事实性的知识包括：

1. 概念：理解递归、递归的模式、互递归、递归调用的过程、树递归
2. 函数代码和可视化执行过程

首先要理解这些东西，才能更好地学习案例，深入分析。

那么想让读者掌握的技能是什么？我觉得可能的是：

1. 函数可视化执行过程：自己debug，利用概念将代码流程在心里走一遍，然后跟可视化工具进行对比
2. 最后的“分割数”怎么解决问题
3. 当然，课后习题是很好的技能检验处。

那么根据“事实性知识要先于技能”的理论，首先要掌握事实性的知识，然后才能利用知识提炼技能。上面分析完了学习1.7的规划路线，发现背景知识很重要。在学习1.7节时，需要提前将对应的概念弄明白，代码需要写一遍跑一下，然后再通篇阅读。

为了实现这个ddl，需要：

1. 提纲：首先将ddl中涉及材料的事实性的知识和要掌握的技能粗略地列出来。事实性的知识列举这里用`xmind`来实现，更加直观方便。（用时预估2h）；
2. 背景知识
   1. 记忆事实性的知识：概念、代码重复写
   2. 运用：利用概念解课本例题

ok，首先用xmind整理本周的学习章节的事实性的知识。

首先用md来整理下涉及所有章节的事实性的知识（不懂就肯定读不下去的硬通货背景知识）

### 2.2 数据抽象

1. 表示有理数的三个函数，然后一厢情愿可以进行加法、乘法、打印和测试有理数是否相等的四个函数
2. 用“对”代表有理数的代码
3. 抽象屏障。背景知识：1,2涉及的代码
4. 数据属性。用两个函数 `pair` 和 `select` 来实现一个二元列表。

### 2.3 序列

1. 序列遍历，函数`count(s, value)`，统计一个值在序列中出现了多少次的问题，并且引入`for`语法。
2. `for`：执行过程概念。（已经了解）
3. 序列解包。`x, y = 3, 4.5`
4. `range(a, b)`:它有两个整数参数：起始值和结束值加一。以及常用用法。
5. 序列处理1：列表推导式（List Comprehensions）、选取原序列中满足某些条件的值、将序列中的所有值聚合为一个值-- 列表推导式的一般形式概念
6. `完美数`是等于其约数之和的正整数。
7. 计算 1 到 1000 的所有完美数。
8. 定面积的情况下计算具有整数边长的矩形的最小周长。以及其中涉及到的几个函数。
9. 序列处理2：高阶函数概念并且利用概念寻找`完美数`的代码。
10. 序列抽象：成员资格，切片。
11. 字符串
12. 树：列表中嵌套列表，树的数据抽象（构造函数 `tree`、选择器 `label` 和 `branches`）
13. 树递归（Tree-recursive）函数可用于构造树： `The nth Fibonacci tree`
14. 分割树`partition_tree(n, m)`，以及涉及的代码，还利用了序列抽象的切片定义了右二叉树`right_binarize(tree)`
15. 链表（linked list）。
16. 链表的抽象数据表示（abstract data representation）：`is_link(s)`、`link(first, rest)`、`first(s)`、`rest(s)`
17. 用定义的抽象数据表示证明它`满足序列抽象`的条件：长度`len_link(s)`和元素选择`getitem_link(s, i)`。
18. 通过递归的方式实现17中涉及的长度计算和元素选择
19. 递归构造：1.7中的 `count_partitions`。

### 2.4 可变数据

1. `suits = chinese`扑克问题
2. 字典
3. `make_withdraw(balance)`能够正常使用的原因。
4. `mutable_link()`：为了理解如何使用具有局部状态的函数来表示可变列表，我们现在将开发一个可变链表的实现。用到了2.3节中16：链表的抽象数据表示，返回一个调度函数（dispatch）
5. `dictionary()`：实现一个具有与字典类似行为的值
6. 调度字典：`dispatch` 函数是实现抽象数据消息传递接口的通用方法
7. 华氏温度和摄氏温度之间的关系是：`9 * c = 5 * (f - 32)`
8. 图的计算过程
9. 连接器`connector `

刚刚在[可变数据](https://composingprograms.netlify.app/2/4)的评论区埋下了一个坑：我要出一份教程，降低阅读cs61a材料的痛苦程度（主要依据是增加必要背景知识，屏蔽繁文缛节）。

今天的整理就到这了，明天跑步，积累跑量。

## 2.26 DDL下的背景知识2

早晨跑了10km，用时53分钟。

继续整理今天所需要的2.5到2.9。start at 8:52

### 2.5 面向对象编程

1. 用`抽象屏障`和`调度字典`介绍。
2. 代码`class Account`
3. 内置函数 `getattr` 按名称返回对象的属性：`getattr(spock_account, 'balance')`
4. 类名命名规则：CapWords 约定。方法名称遵循使用下划线分隔的小写单词命名函数的标准约定
5. 类属性：为 `Account` 创建名称为 `interest` 的类属性。
6. 继承：支票账户`CheckingAccount` 是 `Account` 的特化。
7.  `Account` 类的完整实现
8.  `CheckingAccount` 的完整实现
9. `deposit_all(winners, amount=5)`：将 5 美元存入每个帐户列表
10. 多继承：`SavingsAccount(Account)`
11. ``AsSeenOnTVAccount(CheckingAccount, SavingsAccount)`：取款和存款都将产生费用，分别使用 `CheckingAccount` 和 `SavingsAccount` 中的函数定义

### 2.6 实现类和对象

1. 使用`调度字典`
2. `make_instance(cls)`：将一个类传递给形参`cls`。
3. `bind_method(value, instance)`：将 `instance` 作为第一个参数插入到函数值中，从而创建绑定方法值
4. `make_class(attributes, base_class=None)`：可以响应 `get` 和 `set` 消息，以及 `new` 消息以及`init_instance(cls, *args)`函数。
5. 使用上面的方法重新创建一个 `Account` 类，一个 `CheckingAccount` 子类，以及为他们各自创建一个实例

### 2.7 对象抽象

1. 字符串构造函数： `str`；
2. `repr` 函数返回一个 Python 可解释的表达式，该表达式的求值结果与原对象相同
3. 专用方法：特殊名称会在特殊情况下被 Python 解释器调用
4. 复数的直角坐标系（实部和虚部）和极坐标系（幅度和角度）表示
5. 实现复数最高等级的抽象：`class Number`:要求数值型对象拥有 `add` 和 `mul` 方法
6. 复数的乘法和加法运算规则
7. 对复数的数学运算：`Complex` 类
8. 两个表示复数的类:`ComplexRI` 使用实部和虚部构建一个复数；`ComplexMA` 使用幅度和角度构建一个复数
9. 实现算术运算所需要的接口包括四个属性：`real`、`imam`、`magnitude` 和 `angle`。
10. `@property` 修饰符
11. 泛型函数`Rational` 类来精确地表示分数
12. 下面的内容有点看不懂，上面的背景知识掌握了后再看吧

### 2.8 效率

1.  树递归函数：计算斐波那契数列中的数字的 `fib` 函数
2. `count` 函数：检查 `fib` 函数被调用的次数
3. 函数的空间需求：活动和非活动的状态
4. 函数 `count_frames` ：跟踪尚未返回的函数调用次数 `open_count`
5. 记忆化（Memoization）：`memo(f)`函数提升效率
6. 增长阶- 时间复杂度啊！数学论证（头大）以及技能`指数运算`
7. 增长类别：（上面6的内容得搞懂才能学这个）

### 2.9 递归对象

1. 递归对象概念。
2. `Link`类： `__len__` 和 `__getitem__` 的定义都是递归的
3. `link_expression(s)`：将一个 `Link` 实例转换为一个字符串表达式
4.  `__repr__` 方法
5. 闭包性质：一个 `Link` 实例的第一个元素也可以是一个 `Link` 实例
6. 函数 `count_partitions`（第一章分割数）
7. `fib_tree(n)`：`Tree` 类可以表示 **用于计算斐波那契数的函数 `fib` ** 的 递归表达式树 中计算的值
8. 有序序列集合节省时间：使集合元素按递增顺序排列
9. 二叉搜索树的 集合
10. 平衡二叉树

我去，需要补充的知识不少呢。Ends at 10:17（8：52 - 10 ：17），eat lunch~

现在是晚上8点45分，今天下午爬山，穿的有点薄，冷。

现在学的头疼，感觉好多代码根本理解不了。按照《为什么学生不喜欢上学》中说的，思考困难是因为背景知识太少，材料中的问题场景一多，存储背景知识就越多，这时候代码逻辑就很难弄明白了。

然后又看了下 [你有什么值得分享的高效学习方法？ - howhowfire的回答 - 知乎](https://www.zhihu.com/question/50343728/answer/184657839)里面作者如何规划理科学习的，发现自己在一开始应该追求的是熟悉材料：混个面熟，代码记一下，逻辑走一下而已。

贴一下里面对于第一阶段的学习指导：

> **学习中的困难，要么源于主动思维过难，超出了学习者能力所及的范围，要么源于主动思维时间过长，超出了学习者意志力的承受范围。**
>
> 第一个阶段都是对知识的**熟悉**阶段。
>
> 这个阶段学习的关键是：**不要去理解，不要去记忆，甚至还要有意识去抑制一些主动思维。**
>
> **预习的第一个要点，是通过快速阅读，来控制时间**。记住：阅读是速度最快、时间最省的学习手段，是快速学习的基础。
>
> **预习的第二个要点，是要不求甚解，来控制难度**。读的过程中，不去记忆，不去理解。读到后面感觉忘了前面，也不要回头去再看。难度大的时候，还可以把内容分类后筛读，先读容易的部分。
>
> **预习的第三个要点，是要多次阅读。**在老师正式讲解之前，每隔一两周预习一次，每次把时间控制在十多二十分钟内。多次阅读，才能促进[内隐记忆](https://www.zhihu.com/search?q=内隐记忆&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A184657839})，才能促进顿悟理解。
>
> **预习的第四个要点，是要整体阅读**。在开学之前，可以将整本教材，从头到尾快速浏览一遍。以后每次预习，并不只是预习明天要讲学内容，而是预习下一个月要学的内容。

熟悉了，才能理解概念，然后运用概念。

那么现在我在做的是增加自己的背景知识而去抄一遍代码（是的，我希望通过抄写代码来让自己更加熟悉材料），但是忘记了代码其实是思考的副产物。抄写不了解的代码真的是一种折磨！所以放下这个抄写代码的想法吧，我觉得应该得阅读5遍以上才能写一写这个代码，要不纯浪费自己时间。

那么现在理解了这个阶段任务是熟悉材料，具体任务就是将对应简单的代码逻辑梳理一下，方便更高层知识运用的时候能更好地运用它。

## 2.27 实践

今天仍然是熟悉材料阶段，抓住简单概念理解。

> gpt查了下任务受挫怎么办：
>
> 面对任务执行中的挫折感，这是一个常见的情况，但也可以通过一些策略来应对。以下是一些建议：
>
> 1. **明确目标和期望：** 确保你对任务的目标和期望有清晰的认识。有时挫折感可能来自于对任务不明确或期望过高。
> 2. **分解任务：** 将任务分解成小而可管理的部分。这样一来，你可以专注于每个小任务，逐步完成，减轻了整体任务的压力。
> 3. **设定合理的时间和计划：** 制定一个合理的时间计划，不要给自己过多的压力。合理的计划可以帮助你更好地掌控任务的进度。
> 4. **寻求支持：** 与朋友、家人或同事分享你的感受，寻求支持和建议。有时与他人分享可以得到新的观点和鼓励。
> 5. **调整期望：** 重新评估和调整你的期望，确保它们是合理的。有时候我们期望太高可能导致挫折感。
> 6. **专注于过程而非结果：** 将注意力集中在任务执行的过程中，而不是过于关注最终结果。专注于过程可以减轻对结果的过度焦虑。
> 7. **制定奖励系统：** 制定一个小的奖励系统，当你完成一部分任务时给自己一些小奖励。这可以激发积极性。
> 8. **学会放松：** 学会在压力时放松自己。可以尝试一些冥想、深呼吸或休息的方法来缓解情绪。
> 9. **寻找学习机会：** 将挫折看作学习的机会。了解失败的原因，思考如何改进，从中学到经验。
> 10. **寻求专业帮助：** 如果挫折感过于沉重，可能需要寻求专业心理健康支持，如心理咨询。
>
> 记住，每个人都会遇到挫折，重要的是学会如何应对和从中学习。挫折并不意味着失败，而是人生中成长和发展的一部分。

“每个人都会遇到挫折，重要的是学会如何应对和从中学习。挫折并不意味着失败，而是人生中成长和发展的一部分。”

变得更强吧。

我今天的任务就是：

1. 2.4和2.9不用主动思维去过一遍（2h）:
2. 重新过一遍1.7 - 2.9（2h）
3. 过一遍4.2（1h）

ok，今天算是认真过了两遍，有了前面背景知识的粗略了解，这次很多知识再读就懂了。现在是19：37，看个电影睡觉。

## 2.28

破冰cs61a：轻松阅读

对于其中涉及的代码，直接粘贴出来，上图形化解释器。

今天需要了解的问题（eat完后浏览下）：

1. 返回链表 s 中索引为 i 的元素的操作
2. 返回链表 s 的长度
3. 递归方式怎么实现的

了解了VO2max与耐力的关系。准备系统训练跑步。

接触到了另一种学习的角度：

> 有很多正在求学的青少年也在看这个帖，我强烈建议你们去研究研究自己的最近发展区，把维果斯基搞清楚，同时搞清楚，什么是技能，特别是心智技能，其实说白了，考试就是一种技能。会考试的孩子考什么都会考，当然，考试也是一种破玩意儿啊，你琢磨这个破玩意儿，单位时间内看谁得分高，妥妥的靠内化靠熟练，这里面很多隐性知识是可以高路迁移的。在中国，学会考试是很重要的。
>
> 至于不能做到脱产的学习，在我看来研究教育心理的意义不大，因为你剩余的时间可能做劳动力恢复都不够。就好像棒棒军研究增肌一样无用，因为棒棒军最大的毛病是劳损，最需要的是停止过量劳动通过多睡，吃好，来恢复，才能增肌。肌纤维是超量恢复的，人的学习也是靠学完后的梳理总结进步的。你还是专心搞钱，或者早点进入一种充足劳动力恢复时间的状态，更实际一些。
>
> 作者：王某
> 链接：https://www.zhihu.com/question/319623962/answer/3373123534
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

下午过一遍第二章再来。

休息！

了解github如何修改项目并且提交？

今天感兴趣的东西：

1. 2.3.7链表实现：）
2. 2.4.7可变链表实现：条件比对字符串实现函数调用
3. 2.4.8 调度字典：键值对索引实现函数调用
4. 2.4.9约束系统connector：集大成者

OK，明天就是周四了，有什么想法吗？

2.3.7链表代码实现遇到的问题（只是抄写然后稍微理解用时47分钟）：

1. 对于链表的基础算法并不熟悉（获取第`i`个元素、返回链表的长度）
2. 其实对于链表的定义也不清楚，像是是否为链表：空或者剩余元素都是长度为2（一个值域一个指针域）且都是链表
3. 基础算法本就不熟悉，然后加上递归后，更难理解截止条件和将问题分解为更小问题的思维。

给出的教训是：

1. 提前预习链表算法：这个部分的代码需要有一定的链表算法基础，可以直接参考算法通关手册中的[链表基础知识](https://algo.itcharge.cn/02.Linked-List/01.Linked-List-Basic/01.Linked-List-Basic/)，大体浏览一遍算法实现的思想：像是[求线性链表的长度](https://algo.itcharge.cn/02.Linked-List/01.Linked-List-Basic/01.Linked-List-Basic/#_2-3-%E6%B1%82%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6)，没基础的同志最起码需要将文字描述读一遍吧。
2. 像是递归部分难以理解，建议根据[递归三步走](https://algo.itcharge.cn/09.Algorithm-Base/02.Recursive-Algorithm/01.Recursive-Algorithm/#_3-%E9%80%92%E5%BD%92%E4%B8%89%E6%AD%A5%E8%B5%B0)看看是否能理解代码，然后再去上手写。

设置2.3.7的目的很明确：用py内置类型和满足序列抽象的条件（具有长度和元素选择）实现上面介绍的序列抽象概念，实践就是实现一个链表。

所以想实现这个代码需要有两个知识背景：

1. 理解序列抽象条件：长度和元素选择
2. 链表的基础算法。

ok，又写了下2.4.7，这里用到的pop和push都是需要提前了解的。晚安玛卡巴卡，明天回顾下概念重新实现一遍链表吧。然后再将调度字典和约束系统代码中涉及到的背景知识写一下。

## 2.29

今天不再拘泥于例题了，直接上课后习题。

一段话治好了我的材料阅读焦虑：

> Remember, it's ok if someone hasn't learned everything yet and needs more time to master the course material. The whole point of the course is for students to learn things they don't already know. Please support each other in the process.

这门课就是让我们掌握不了解的知识的，所以不要担心课程材料没有掌握地足够好（而且反问：怎么才算掌握地好呢？），只要跟着学就一定能学到相应的技能。

**简单阅读1.7的要点**

首先一句话总结本节内容：用递归调用来理解“函数抽象”的概念。

所以在这里`递归`是工具，是为了方便更好地理解函数抽象概念的。这里面涉及到的函数抽象概念就是递归的核心问题：如何将原问题分解为同类的子问题而解决。

想要通畅阅读本节，你是需要一定的背景知识的。背景知识如下（预计背景知识准备时间：0.5-1h）：

1. [递归是什么？](https://algo.itcharge.cn/09.Algorithm-Base/02.Recursive-Algorithm/01.Recursive-Algorithm/#_1-%E9%80%92%E5%BD%92%E7%AE%80%E4%BB%8B)（思考：递归分为递推和回归，这两个过程是按照什么原则进行的？）
2. [如何实现递归？](https://algo.itcharge.cn/09.Algorithm-Base/02.Recursive-Algorithm/01.Recursive-Algorithm/#_3-%E9%80%92%E5%BD%92%E4%B8%89%E6%AD%A5%E8%B5%B0)
3. [图形化执行递归函数](https://pythontutor.com/cp/composingprograms.html#mode=edit)：为了更好地理解递归的过程，将1.7材料中较为简单的递归打印函数：`cascade(n)`代码粘贴进去，走一遍看看效果
4. [斐波那契数列的递归应用](https://algo.itcharge.cn/09.Algorithm-Base/02.Recursive-Algorithm/01.Recursive-Algorithm/#_5-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0)
5. [什么是`分割数`](https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B8%E5%88%86%E6%8B%86)？（1.7节的材料最后用分割数作为检验递归调用是否理解的范例）

带着一定的问题将上面涉及的背景知识看完，然后再通篇阅读1.7，就能明白这节讲什么了。

------

做完了1.7节的课后题，今天休息下，写下自己的规划，下个月就要开始了，这个文件也要终结了。但是我的脚步不会停下！
