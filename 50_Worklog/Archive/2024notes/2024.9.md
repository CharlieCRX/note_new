## 9.3

学习完毕link章节，掌握了静态链接和动态链接的区别

本周写一个帖子，看介绍所学的“链接”

## 9.10

pa1：测试代码

实现一个表达式生成器。

进行表达式求值测试，首先考虑生成合法的表达式`gen_rand_expr()`。

表达式生成器框架代码测试流程（`nemu/tools/gen-expr/gen-expr.c`）：

- 生成合法表达式`gen_rand_expr()`：随机生成表达式，输出到缓冲区`buf`中。

- 生成表达式的结果：将`buf`中的随机表达式放入C程序代码`result`中

  ```C
  #include <stdio.h>
  int main() {
    unsigned result = ???; // 把???替换成表达式
    printf("%u", result);
    return 0;
  }
  ```

  编译运行即可获取对应的结果。

- 输出随机生成的表达式以及对应的表达式计算结果。

**表达式生成器如何获得C程序的打印结果?**

利用管道命令`popen()`将程序执行的输出结果，保存到一个字符串变量中。

要学习的函数：

- `fgets()`和`fopen()`
- `popen()`
- `sscanf()`

## 9.11

看到了你的评论。
pa雀食不是一帆风顺的。说来惭愧，现在pa1磕磕绊绊，写了也是快两个月的时间了，我看了下番茄todo:tomato:里面的计时，到现在写完表达式生成器，总共用时为56h。
其中学到的就是：

1. 完成比完美更重要（KISS原则）
2. 对于源码的探索，按照文档来就可以了，没必要在前期特别深入钻研。（因为不上手研究讨论，不会对代码有更多的认识）
3. 遇到不会的问题，需要反复查看文档描述，根据上下文推测出具体需求。
4. 如果实在卡了太久，我觉得借鉴一下答案也可以。毕竟坐牢雀食难受

还有另一个就是效率问题。在7月23号开始pa1阶段，到现在其实用时也不是很多，折合每天也就学了不到三小时。我感觉这东西需要深入研究才可以，需要长时间debug和思考学习，所以我的学习时间也是太少了。

你说的`相关要求不明确`确实是这样，总是感觉需求仿佛说了，又仿佛没说。:pensive:我的应对办法就是将文档中模糊的需求，自己梳理清晰，然后写出具体实现的思路来。

我觉得pa代码的唯一问题就是注释太少，真的需要自己静下心来`STFSC`。遇到不会的函数，需要及时查阅文档弄明白作用是什么。

我觉得好的工具也会帮助我们学习，这里分享下我的学习辅助工具：

- `chat-gpt`：唯一真神，实在不会，偷懒将源码扔给他分析
- `tmux`：多窗口分屏神器
- `typroa`：梳理逻辑

我觉得这些工具都能帮助我在学习新东西的时候，更加得心应手一些。

觉得痛苦没问题，发现问题解决问题，说不定就发现“只缘身在此山中”的拨云见日呢？共勉！

我现在一直更新着博客，希望能帮助到你！也希望你能和我一起做pa项目，一起探索下南大的计算机“魅力”！

## 9.12

监视点笔记抽取

- 非法访存的时候：编译器一个叫`Address Sanitizer`的工具, 它可以自动地在指针和数组的访问之前插入用来检查是否越界的代码. 

  GCC提供了一个`-fsanitize=address`的编译选项来启用它.

- 调试建议：尽可能多地在代码中插入`assert()`，拦截非预期情况

- 监视点：用于监控内存地址或变量的值发生变化。当程序运行过程中，某个指定的变量或内存位置的值发生变化时，GDB 会暂停程序。

- 获取特定寄存器的值：`isa_reg_str2val()`.它用于返回名字为`s`的寄存器的值, 并设置`success`指示是否成功.

- 如何判断`*`是解引用还是乘号？（同等问题：判断`-`是负号还是减号）；解引用操作就是通过指针获取或修改它指向的变量的内容。

- api：是一组定义了如何与软件组件、系统或服务进行交互的规则和协议

- 关于提供的`expr()`实现了更好的判断`-`是负号还是减号的那件事（将判断逻辑放在`eval()`中，并且区分服负号和减号的token.type）--可以不改现在已有的判断负号的逻辑，直接动手写解引用的判断逻辑，等实现完毕了再改。

- ~~关于空格的处理：判断是否存储在token数组中~~

  > 其中空格串的token类型是`TK_NOTYPE`, 因为空格串并不参加求值过程, 识别出来之后就可以将它们丢弃了
  >
  > from [词法分析](https://nju-projectn.github.io/ics-pa-gitbook/ics2023/1.5.html#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90)

- 表达式求值的类型：表达式结果均为`uint32_t`类型.指针也没有类型, 进行指针解引用的时候, 我们总是从客户计算机的内存中读出一个`uint32_t`类型的整数.

- 用链表实现监视点的原因：因为要动态添加和删除元素，所以链表的灵活性要强于数组

- 监视点结构体中还缺什么？-gdb的监视点拿过来，根据对监视点工作原理的理解在结构体中增加必要的成员

- 为什么定义监视点结构的池？其作用是什么？`head`用于组织使用中的监视点结构, `free_`用于组织空闲的监视点结构

- 框架代码中定义`wp_pool`等变量的时候使用了关键字`static`, `static`在此处的含义是什么? 为什么要在此处使用它?

## 9.13

需求分析：2h（12:00-14:00）

代码整洁之道：

- 写整洁代码，需要遵循大量的小技巧，贯彻刻苦习得的“整洁感”
- 整洁的代码只做好一件事
- 代码块越小越好
- 函数功能太多，将其切分为两个或者多个能够清晰地说明其自身功能的方法
- “你还得练，孩子，还得练！”

其他就是发现了官方的字符串转长数字的方法，准备优化代码。

打卡达目标，提交代码，做饭。

## 9.14

### 表达式求值功能

主线任务需要实现：

- [x] 16进制数据的表示
- [x] 打印寄存器的值
- [x] 指针的解引用
- [x] 逻辑运算`==`、`!=`、`&&`

第一个十六进制数据的表达式，可以通过数据以`0x`开头来判断。将其以16进制保存后，再以`uint32_t`的形式输出即可。

> 问1：是否可以用正则表达式识别16进制？(`0x12..9ABCDE`）
>
> 分析：`0x`开头，随后是任意数量的十六进制数字（从数字0-9和大小写不区分的A-F）
>
> 得出的结论是：`0x[0-9A-Fa-f]+`
>
> 并且十六进制的正则表达式规则`TK_HEX`，需要放在正则表达式`TK_NUM`的前面，否则正则表达式识别`0x...`的时候，会优先选择数字匹配`0`，然后遇到符号`x`报错。
>
> 问2：识别出此表达式为16进制表达式后，在哪处理此值？
>
> 答：在`eval()`函数的流程`else if(p == q)`，判断表达式为数字（包括10进制和16进制），调用函数将其转换为`uint32_t`的整数数据。
>
> 需要实现一个函数：将数字字符串转换为无符号整型变量
>
> 输入：一个结构体token元素，按照结构体里面的type属性分为10进制字符串和16进制字符串
>
> 处理：按照对应的type类型，判断按照哪种进制处理字符串数据，并且调用函数将字符串转换为无符号整型变量
>
> 输出：无符号整型变量
>
> 附：在实现这个函数的时候，我希望后期维护性提升。例如后面需要支持8进制数据的时候，仅需要简单处理一下，而不用修改大量代码。
>
> 所以用到了函数指针，创建一个函数指针的数组，根据token的type确定对应的函数调用。
>
> 另一个问题：将字符串转为10进制、16进制的方法？
>
> 答：使用`sscanf()`，将16进制字符串转化为数字存储。函数原型如下：
>
> ```C
> int sscanf(const char *str, const char *format, ...);
> ```
>
> - `str`：要扫描的输入字符串。
> - `format`：格式控制字符串，用于指定如何解析输入字符串。
> - `...`：一系列变量的地址，这些变量将接收解析出来的数据。
>
> 返回值：`sscanf` 成功返回转换的项数。如果返回值为1，表示成功从字符串中读取了一个十六进制数

第二个问题，实现打印寄存器的值。

> 1. 寄存器的正则表达式
>
>    答：以字符`$`开头，后面跟着寄存器的名称，是任意数量的字符和数字的拼装。所以正则表达式为`\$[0-9a-z-A-Z]+`
>
> 2. 寄存器表达式的求值
>
>    答：调用函数`isa_reg_str2val()`来获取返回名字为`s`的寄存器的值。`s`是去掉符号`$`后的寄存器名称字符串。
>
> 3. 为了让代码更简约，能做点什么？
>
>    答：寄存器表达式也是一个单独的token保存：token.type = TK_REG，token.str = reg_name_string.
>
>    所以在计算寄存器表达式的时候，希望也可以用统一的函数`convert_token_to_unsigned_num()`来处理代表寄存器表达式的token。
>
>    而框架给的API原型为
>
>    ```C
>    word_t isa_reg_str2val(const char *s, bool *success);
>    ```
>
>    而我想实现的获取寄存器值的函数`get_register_value()`的输入参数仅有代表寄存器名称的`s`。所以需要在函数`get_register_value()`中，首先声明一个布尔变量，然后和变量名一起作为参数调用框架的API。
>
>    然后根据布尔变量的结果，来确定是否返回获取的值。
>
> 4. 怎么实现这个API？
>
>    答：首先找到这个获取寄存器值API的位置`nemu/src/isa/riscv32/reg.c`。步骤是:
>
>    - 根据寄存器名称，获取寄存器索引`reg_idx_by_name()`
>    - 打印寄存器的值
>
>    在`risv-32`的体系下，cpu寄存器是一个大小为32的数组。现在已经在对应`risv-32`的体系（`nemu/src/isa/riscv32/local-include/reg.h`）下，实现了根据索引（0-31）来获取寄存器值的方法`gpr(idx)`（`nemu/src/isa/riscv32/local-include/reg.h`）。
>
>    所以我们可以实现”根据寄存器的名称获取寄存器编号“的方法，来间接获取寄存器的值。我们暂且将这个方法命名为`static int reg_idx_by_name(const char *name)`

## 9.16

中秋快乐！

非常理解你在PA项目中的心情。我自己在做 PA 的时候也有过类似的感受：耗费了大量时间，但没有实质性的收获，但是到了表达式这部分，感觉好起来了。

将不明的C库函数用命令`man 3`（配合`chat-gpt`生成代码阅读起来很舒服）熟悉地掌握，将代码结构不断地观摩（因为写这个表达式时，需要回头将`ISA`目录下的相关代码接口完善等）。随着不断地反复观看手册和思考，现在对PA强调的[原理的理解透彻，离不开动手实践](https://nju-projectn.github.io/ics-pa-gitbook/ics2023/why.html)，有了微妙的体会。

但是每个人的底子和环境不同，对同一件问题的感受也不同。理解你想将更多时间，放在自己能掌握的东西、能让自己有成就感的东西上，因为这会让人闪闪发光！所以很高兴你也基于自己的判断，暂时放下并去学习其他有意义的内容，我相信这样会让你的效率和动力猛猛地上升！

CSAPP的Lab，确实能学到很多东西。不管是boomlab的在汇编层面分析逻辑，从而拆解几个炸弹带来的刺激；还是cachelab自己设计一个缓存系统，实现LRU的缓存替换策略。都在苦于bug调不通的同时，让我陶醉于计算机世界的美妙。

至于你提到的 C++ 小项目，我觉得你做得很有趣，能实现自己的 map 类，并且引入平衡树切换功能，已经是非常不错的成果了！我在学习代码的时候，总会局限于语言本身，很少敢于用学到的知识去实践什么具体的功能。所以我要对你说声**respect！**

虽然目前性能还没有达到预期，但我相信你肯定能不断优化自己的代码，最终达到自己心目中的那个目标！

至于 PA 的暂时搁置，这并不是逃避，而是合理的规划。正如毛主席曾说的那样，“道路是曲折的，前途是光明的。”

时间很长，总能找到合适的时间和状态去重新挑战 PA，期待你的回归bro！

感谢你的回信！我很期待今后有更多的交流和分享，祝你在 CSAPP 和自己的项目中继续有更多的收获！

加油！！！！中秋快乐！:full_moon:

## 9.18

拒绝买房的招聘需求：

计算机、电子工程、自动化等相关专业
熟悉并开发过 TVM、MLIR、Triton 等开源编译器框架
了解编译器的中后端优化，具备自动分布式、量化、Tiling、Fusion、Schedule 等技术的实际经验
具备扎实的编程基础，熟练掌握 C/C++，熟悉 Python 等编程语言

继续开始PA.

第三个问题，指针的解引用。

> 1. 如何判断`*`是乘法还是解引用的符号？
>
>    答：看`*`前一个token的类型。如果星号前面是表达式开始的标识符，那么证明`*`前面并没有表达式，所以此时`*`只有解引用的功能。反之则是乘法的作用。
>
>    而表达式开始的标志，要么是token下标为0；要么是token的类型为左括号`(`。
>
> 2. 在哪里判断`*`的作用？
>
>    答：在方法`expr()`中。`eval()`函数只管按照已有的表达式结构计算，不参与符号的判断。
>
> 3. 思考：既然已经判断了`*`的类型为解引用，那我该怎么计算解引用表达式？（同负数）
>
>    答：例如`*0x1234 + 678`这个表达式。
>
>    正常的四则运算只能确认此表达式的主运算符为`+`。然后分别计算表达式1：`*`、`0x1234`和表达式2：`678`的值。
>
>    首先判断前缀是否为特殊运算符（指针的解引用和负数，以及后面可能需要的自增、取地址、按位取反等）。如果是，则进入特殊运算流程。
>
>    特殊运算流程：
>
>    - 找到第一个表达式：确认前缀运算符后，第一个表达式`0x1234`
>    - 调用解引用函数处理表达式结果：根据前缀运算符，调用相应的函数进行处理第一个表达式运算后的值，得到特殊运算的结果`deference(0x1234)`
>
>    计算解引用表达式后，再与后面的`678`相加得出结果。
>
>    同理计算表达式：`*(0x1234+0x12) + 56`
>
>    步骤依旧是：
>
>    - 找到第一个表达式：`(0x1234 + 0x12)`
>    - 然后调用解引用函数获取对应地址的值
>
> 4. 需要实现的函数或者方法。
>
>    - `int locate_first_operator(int p, int q)`：从p，q下标中获取第一个运算符的位置
>    - 前缀表达式函数策略：利用函数指针来实现
>

## 9.27

- [x] 完成取指部分的逻辑分析
- [x] 完成译码部分的宏定义理解
- [x] 完成译码部分的逻辑分析
- [ ] 修改博客园外观

`exec_once()`函数覆盖了指令周期的所有阶段: 取指, 译码, 执行, 更新PC

下面学习下函数`exec_once()`的各个阶段所做的事情

### 取指

在执行指令之前，需要获取这个指令，我们看下NEMU如何获取一条指令的。

`exec_once()`接受一个`Decode`类型的结构体指针`s`.这个结构体存放“在执行一条指令过程中所需的信息”。

`Decode`结构体定义在`nemu/include/cpu/decode.h`中

```C
typedef struct Decode {
  vaddr_t pc;
  vaddr_t snpc; // static next pc
  vaddr_t dnpc; // dynamic next pc
  ISADecodeInfo isa;
  IFDEF(CONFIG_ITRACE, char logbuf[128]);
} Decode;
```

这里可以看出，除了指令的地址信息`pc`、`snpc`和`dnpc`，还包括了一个与ISA相关的结构体抽象`ISADecodeInfo`.

其具体的定义在`nemu/src/isa/$ISA/include/isa-def.h`中

```C
typedef struct {
  union {
    uint32_t val;
  } inst;
} MUXDEF(CONFIG_RV64, riscv64_ISADecodeInfo, riscv32_ISADecodeInfo);
```

这个`ISADecodeInfo`结构体中包含了一个联合体`inst`，联合体中有一个`uint32_t`类型的成员`val`。 RISC-V 32 位架构中，每一条指令的长度都是 32 位，因此这个 `val` 可以用于存储一条完整的指令。

现在`exec_once()`函数接收了传入参数`s`，然后将当前的PC保存到`s`的成员`pc`和`snpc`中。随后调用`isa_exec_once()`进行指令的执行操作。

函数`isa_exec_once()`定义在`nemu/src/isa/riscv32/inst.c`中

```C
int isa_exec_once(Decode *s) {
  s->isa.inst.val = inst_fetch(&s->snpc, 4);
  return decode_exec(s);
}
```

因为`inst.val`是用来存储一条完整指令的变量，所以推测`inst_fetch()`函数的功能，是用来取指令的。

下面我们看下函数`inst_fetch()`的定义（`nemu/include/cpu/ifetch.h`）

```C
static inline uint32_t inst_fetch(vaddr_t *pc, int len) {
  uint32_t inst = vaddr_ifetch(*pc, len);
  (*pc) += len;
  return inst;
}
```

而函数`vaddr_ifetch()`的功能就是通过`pc`所指的客户程序地址，找到对应物理内存中的长度为`len`的数据。

函数`isa_exec_once()`将`pc->snpc`的地址作为参数传入到函数`vaddr_ifetch()`中，所以函数`vaddr_ifetch()`取完数据后，会根据`len`（这里是`4`）来更新`s -> snpc`，从而让`s -> snpc`指向下一条指令。

已经获取的指令，将其存放于结构体`s`关于ISA信息的`isa`中。至此，取指令流程结束。

### 译码

随后`s`带着指令的信息，传入到函数`decode_exec()`开始译码，其定义在`nemu/src/isa/riscv32/inst.c`

```C
static int decode_exec(Decode *s) {
  int rd = 0;
  word_t src1 = 0, src2 = 0, imm = 0;
  s->dnpc = s->snpc;

#define INSTPAT_INST(s) ((s)->isa.inst.val)
#define INSTPAT_MATCH(s, name, type, ... /* execute body */ ) { \
  decode_operand(s, &rd, &src1, &src2, &imm, concat(TYPE_, type)); \
  __VA_ARGS__ ; \
}

  INSTPAT_START();
  INSTPAT("??????? ????? ????? ??? ????? 00101 11", auipc  , U, R(rd) = s->pc + imm);
  INSTPAT("??????? ????? ????? 100 ????? 00000 11", lbu    , I, R(rd) = Mr(src1 + imm, 1));
  INSTPAT("??????? ????? ????? 000 ????? 01000 11", sb     , S, Mw(src1 + imm, 1, src2));

  INSTPAT("0000000 00001 00000 000 00000 11100 11", ebreak , N, NEMUTRAP(s->pc, R(10))); // R(10) is $a0
  INSTPAT("??????? ????? ????? ??? ????? ????? ??", inv    , N, INV(s->pc));
  INSTPAT_END();

  R(0) = 0; // reset $zero to 0

  return 0;
}
```

译码的目的是得到指令的操作和操作对象, 这主要是通过查看指令的`opcode`来决定的. NEMU通过一个模式字符串来指定指令中的`opcode`.

因为译码部分研读时候发现细节很多，所以为了理解这部分的内容，我这个小节的规划是：先从宏观角度讲译码做了什么，即译码的功能；随后着眼细节，剖析代码的筋骨纹理，看看译码是怎么实现这些功能的。

来不及解释了，我们开始:star:

#### 功能

首先看下，如何获取指令中的`opcode`.

NEMU定义了用于识别对应`opcode`的模式匹配规则`INSTPAT`（意思是instruction pattern）

```tex
INSTPAT(模式字符串, 指令名称, 指令类型, 指令执行操作);
```

宏展开后，首先调用`pattern_decode()`函数，将一条包含`opcode`对应匹配规则的字符串，经过转换，作为`opcode`的判断参数。

然后再将输入的`s`中的指令信息`s->isa.inst.val`，经过位操作后，跟上一步骤中的`opcode`判断参数进行比对。

如果比对成功，则宣告了指令的操作类型已经确定，指令类型的译码工作已经完成。

指令类型确定后，随后便是对操作对象的译码处理`decode_operand()`。此函数根据传入的指令类型`type`来进行操作数的译码，译码结果会被保存起来。

```C
decode_operand(s, &rd, &src1, &src2, &imm, TYPE_U);
```

以上就是宏观角度，屏蔽掉函数内部的复杂粒度，只概述每个函数的输入输出，从简化译码的逻辑。

但是实际的操作，还是需要依靠复杂的逻辑处理和对应c语言特性才能实现。下面，我们就着手细节，从细节上剖析译码的操作流程。

#### 细节

首先看下如何实现的模式匹配。NEMU可以通过一个模式字符串来指定指令中`opcode`, 例如在riscv32中有如下模式:

```C
INSTPAT_START();
INSTPAT("??????? ????? ????? ??? ????? 00101 11", auipc, U, R(rd) = s->pc + imm);
// ...
INSTPAT_END();
```

而定义每一条模式匹配规则的`INSTPAT`是一个宏，其格式为：

```tex
INSTPAT(模式字符串, 指令名称, 指令类型, 指令执行操作);
```

`INSTPAT`的各个参数的说明如下：

> `模式字符串`中只允许出现4种字符:
>
> - `0`表示相应的位只能匹配`0`
> - `1`表示相应的位只能匹配`1`
> - `?`表示相应的位可以匹配`0`或`1`
> - 空格是分隔符, 只用于提升模式字符串的可读性, 不参与匹配
>
> `指令名称`在代码中仅当注释使用, 不参与宏展开; 
>
> `指令类型`用于后续译码过程; 
>
> `指令执行操作`则是通过C代码来模拟指令执行的真正行为.

下面看下`INSTPAT`宏如何转换为对应的C代码。

我们看下`INSTPAT`、`INSTPAT_START()`和`INSTPAT_END()`其宏定义的具体实现。它们均被定义在`nemu/include/cpu/decode.h`中。

```c
// --- pattern matching wrappers for decode ---
#define INSTPAT(pattern, ...) do { \
  uint64_t key, mask, shift; \
  pattern_decode(pattern, STRLEN(pattern), &key, &mask, &shift); \
  if ((((uint64_t)INSTPAT_INST(s) >> shift) & mask) == key) { \
    INSTPAT_MATCH(s, ##__VA_ARGS__); \
    goto *(__instpat_end); \
  } \
} while (0)

#define INSTPAT_START(name) { const void ** __instpat_end = &&concat(__instpat_end_, name);
#define INSTPAT_END(name)   concat(__instpat_end_, name): ; }
```

`INSTPAT`又使用了另外两个宏`INSTPAT_INST`和`INSTPAT_MATCH`, 它们在`nemu/src/isa/$ISA/inst.c`中定义. 

```C
#define INSTPAT_INST(s) ((s)->isa.inst.val)
#define INSTPAT_MATCH(s, name, type, ... /* execute body */ ) { \
  decode_operand(s, &rd, &src1, &src2, &imm, concat(TYPE_, type)); \
  __VA_ARGS__ ; \
}
```

具体定义如上文所述，下面我们按照其源码，分析下`INSTPAT`、`INSTPAT_START()`和`INSTPAT_END()`的具体逻辑。

首先是宏`INSTPAT`的各部分含义解析：

1. `pattern_decode` 是一个函数，通过解析 `pattern`（模式）生成 `key`、`mask` 和 `shift` 这三个变量。

2. `if ((((uint64_t)INSTPAT_INST(s) >> shift) & mask) == key)`

   - `INSTPAT_INST(s)` 是一个宏，用于从存放指令执行信息的结构体 `s` 中提取指令或数据。其逻辑实现为

     ```c
     #define INSTPAT_INST(s) ((s)->isa.inst.val)
     ```

   - `(uint64_t)INSTPAT_INST(s)`将提取到的指令，转换为64位的整数

   - `& mask`：通过掩码操作保留需要匹配的位，屏蔽掉其他不相关的位。

   - `== key`：最后将处理后的结果与 `key` 进行比较，判断当前指令或数据是否符合指定模式。

3. `INSTPAT_MATCH(s, ##__VA_ARGS__)`

   - 当2阶段`if`判断条件成立，宏调用`INSTPAT_MATCH`，执行与该模式匹配的逻辑

     ```C
     #define INSTPAT_MATCH(s, name, type, ... /* execute body */ ) { \
       decode_operand(s, &rd, &src1, &src2, &imm, concat(TYPE_, type)); \
       __VA_ARGS__ ; \
     }
     ```

   - `##__VA_ARGS__` 表示可变参数，允许传递多个参数给 `INSTPAT_MATCH`，使这个宏更灵活。

4. `goto *(__instpat_end)`

   - 匹配成功，代码跳转到预定义的指针`__instpat_end`所指的地址。`__instpat_end`实现在`INSTPAT_START`中

总结`INSTPAT`宏的整体逻辑：

1. 通过`pattern_decode()`函数解析传入的指令模式`pattern`，用与生成匹配的 `key`、`mask` 和 `shift`。
2. 从 `s` 中提取待处理的指令或数据，并根据 `shift`、`mask` 和 `key` 进行模式匹配。
3. 如果匹配成功，执行 `INSTPAT_MATCH` 中的操作，并通过 `goto *(__instpat_end)` 跳转到预定义的位置，可能是为了跳过某些指令或结束当前匹配过程。

分析完毕`INSTPAT`的整体逻辑后，再深入分析下函数`pattern_decode()`和`decode_operand()`的逻辑。

首先是将模式字符串解析到变量`key`、`mask`和`shift`的函数`pattern_decode()`，定义在`nemu/include/cpu/decode.h`中。

```C
static inline void pattern_decode(const char *str, int len,
    uint64_t *key, uint64_t *mask, uint64_t *shift) {
  uint64_t __key = 0, __mask = 0, __shift = 0;

#define macro(i) \
  if ((i) >= len) goto finish; \
  else { \
    char c = str[i]; \
    if (c != ' ') { \
      Assert(c == '0' || c == '1' || c == '?', \
          "invalid character '%c' in pattern string", c); \
      __key  = (__key  << 1) | (c == '1' ? 1 : 0); \
      __mask = (__mask << 1) | (c == '?' ? 0 : 1); \
      __shift = (c == '?' ? __shift + 1 : 0); \
    } \
  }

#define macro2(i)  macro(i);   macro((i) + 1)
#define macro4(i)  macro2(i);  macro2((i) + 2)
#define macro8(i)  macro4(i);  macro4((i) + 4)
#define macro16(i) macro8(i);  macro8((i) + 8)
#define macro32(i) macro16(i); macro16((i) + 16)
#define macro64(i) macro32(i); macro32((i) + 32)

  macro64(0); // 从索引 0 开始解析字符串
  panic("pattern too long"); // 如果解析到这里，表示字符串超长

#undef macro
finish:
  *key = __key >> __shift; // 将 __key 右移 __shift 位
  *mask = __mask >> __shift; // 将 __mask 右移 __shift 位
  *shift = __shift; // 返回移位值
}
```

里面比较有意思的是宏`macro(i)`的相关定义，这里学习下。

```C
#define macro(i) \
  if ((i) >= len) goto finish; \
  else { \
    char c = str[i]; \
    if (c != ' ') { \
      Assert(c == '0' || c == '1' || c == '?', \
          "invalid character '%c' in pattern string", c); \
      __key  = (__key  << 1) | (c == '1' ? 1 : 0); \
      __mask = (__mask << 1) | (c == '?' ? 0 : 1); \
      __shift = (c == '?' ? __shift + 1 : 0); \
    } \
  }
```

- 边界检查：如果索引 `i` 超过字符串长度 `len`，则跳转到 `finish` 标签，结束解析
- 字符处理：
  - 获取字符串中索引为`i`的字符`c`
  - 如果字符为非空格，继续下面的执行
  - 使用宏`Assert()`确保字符是`0`、`1`或`?`
  - 根据字符更新`__key`、`__mask` 和 `__shift`
    - `1`：将 `__key` 向左移位并设置最低位为 1，同时在 `__mask` 中将相应位设为 1
    - `0`：将 `__key` 向左移位并设置最低位为 0，同时在 `__mask` 中将相应位设为 1
    - `?`：不影响`__Key`，在`__mask`中对应位设置为`0`，并增加`__shift`的计数

这里我们单独拎出`__key`的处理方法，来看看是怎么根据当前字符`c`来决定这个参数值的

```C
__key = (__key << 1) | (c == '1' ? 1 : 0);
```

1. 左移操作`__key << 1`
2. 条件表达式`(c == '1' ? 1 : 0)`
3. 按位或操作`|`：按位或是位运算的一种，是将两个数据的二进制表示右对齐后，按位进行运算，两个对应的二进制位中只要一个是1，结果对应位就是1。

举例：如果当前`__key`值为`5`（二进制`0101`）

- 当前字符`c`为`1`，则`__key = 1010 | 1 = 1011`
- 当前字符`c`为`0`，则`__key = 1010 | 0 = 1010`

其实这行代码的目的是逐个处理字符串中的字符，并根据字符是否为`1`，来构建一个二进制数。举一反三，其他两个参数`__mask` 和 `__shift`的值获取方式类似。

`pattern_decode()`中另一个需要学习的点，就是用于简化和加速字符串解析过程的宏扩展。

```C
#define macro2(i)  macro(i);   macro((i) + 1)
```

- 顺序执行：带有分号的 `macro(i);` 使得它是一个完整的语句，接着在同一行执行 `macro((i) + 1)`。这两者是顺序执行的，编译器能够正确解析。
- 通过一次宏调用处理两个字符，相比于逐个调用 `macro(i)`，可以减少宏调用的次数，从而提高解析效率。

学习完主要的宏`macro(i)`后，我们再回头对函数`pattern_decode()`主要部分进行解析

- 宏 `macro(i)`：将字符串表示的指令模式转换为可以用于比较的位值和掩码

- `macro64(0)`：从索引0开始，处理从 0 到 63 的字符。

- `panic()`：尝试处理的字符超出了实际字符串的长度范围，会调用此函数报错。

  举例字符串如果为`1010`，而`len`为十进制的10。将这个4位的字符串用函数`macro4(0)`处理时，即使处理完字符串，也会因为`if`语句不成立，不会跳转到正常的`finish`部分。所以会调用函数`panic()`报错。

- `finish`：保留`__key`和`__mask`的有效位，并将解析过程中遇到的 `?` 字符的数量，有效位的偏移量`__shift`返回

这个`pattern_decode()`的含金量还是蛮高的，总结下里面值得学习的东西有：

1. 宏的使用和递归解析：灵活地处理输入字符串的不同长度
2. 将字符串转换为`key`和`mask`：增加新类型的字符或改变解析规则只需调整宏逻辑，而无需重写整个解析过程。
3. 错误保护机制
4. 代码维护性：体现在宏和`finish`。所有解析结果的更新集中在`finish:`标签处，避免了代码重复。

分析完毕`pattern_decode()`，再具体分析下函数`decode_operand()`

`INSTPAT`的整体逻辑不仅包含模式字符串处理函数`pattern_decode()`，而且包含另一个匹配操作码行为的函数`decode_operand()`。

```C
#define src1R() do { *src1 = R(rs1); } while (0)
#define src2R() do { *src2 = R(rs2); } while (0)
#define immI() do { *imm = SEXT(BITS(i, 31, 20), 12); } while(0)
#define immU() do { *imm = SEXT(BITS(i, 31, 12), 20) << 12; } while(0)
#define immS() do { *imm = (SEXT(BITS(i, 31, 25), 7) << 5) | BITS(i, 11, 7); } while(0)

static void decode_operand(Decode *s, int *rd, word_t *src1, word_t *src2, word_t *imm, int type) {
  uint32_t i = s->isa.inst.val;
  int rs1 = BITS(i, 19, 15);
  int rs2 = BITS(i, 24, 20);
  *rd     = BITS(i, 11, 7);
  switch (type) {
    case TYPE_I: src1R();          immI(); break;
    case TYPE_U:                   immU(); break;
    case TYPE_S: src1R(); src2R(); immS(); break;
  }
}
```

其中用到的宏定义`BITS`和`SEXT`在`nemu/include/macro.h`中定义，分别用于位抽取和符号扩展

```C
#define BITMASK(bits) ((1ull << (bits)) - 1)
#define BITS(x, hi, lo) (((x) >> (lo)) & BITMASK((hi) - (lo) + 1)) // similar to x[hi:lo] in verilog
#define SEXT(x, len) ({ struct { int64_t n : len; } __x = { .n = x }; (uint64_t)__x.n; })
```

宏的简单介绍：

- `BITMASK(bits)`：生成一个由 `bits` 个低位为 1 的无符号长整型掩码。例如，`BITMASK(3)` 的结果是 `0b111`，即十进制的 7。
- `BITS(x, hi, lo)`：获取`x`的`[lo, hi]`部分数据
- `SEXT(x, len)`：将`x`符号扩展为64位的无符号整数

其中`SEXT(x, len)`用位域的好处在于：

1. **自动处理符号扩展**：由于 `int64_t n : len` 是有符号的，当对 `n` 进行赋值时，C 语言会自动根据最高位进行符号扩展，这就避免了手动处理符号位的复杂逻辑。
2. **高效简洁**：这种方式通过位域直接实现了符号扩展，不需要手动移位或其他位操作，代码简洁且高效。

这样函数`decode_operand()`根据指令的类型`type`，来进行操作数的译码，并将译码结果记录到函数参数`rd`, `src1`, `src2`和`imm`中, 它们分别代表目的操作数的寄存器号码, 两个源操作数和立即数.

### 执行

### 更新PC
