# 11月

## 11.4

问题：

- AM究竟给程序提供了多大的栈空间？RTFSC
- riscv32如何实现自陷指令来触发自陷操作？
- 事件处理回调函数是干嘛的：响应和处理系统中发生的特定事件。当特定事件发生时（如用户输入、定时器到期、硬件中断等），系统会触发相应的事件处理机制，调用这个操作系统提供的回调函数，以便执行相应的响应逻辑
- `abstract-machine\am\src\riscv\nemu\trap.S`代码和`cte_init`联系
  - 

浏览PA3摘抄

- 批处理：批处理系统的关键, 就是要有一个后台程序, 当一个前台程序执行结束的时候, 后台程序就会自动加载一个新的前台程序来执行.
- 操作系统实现的程序之间的执行流切换入口

- 硬件保护机制的本质: 在硬件中加入一些与特权级检查相关的门电路(例如比较器电路), 如果发现了非法操作, 就会抛出一个异常信号, 让CPU跳转到一个约定好的目标位置, 并进行后续处理.
- 硬件提供一种可以限制入口的执行流切换方式. 这种方式就是自陷指令, 程序执行自陷指令之后, 就会陷入到操作系统预先设置好的跳转目标. 保存程序状态以及跳转到异常入口地址的工作, 都是硬件自动完成的
- 异常响应机制和内存无关
- `raise_intr`：虚构的异常响应指令。此指令的行为是就是异常响应过程。
- riscv32中使用mtvec寄存器来存放异常入口地址。
- 状态机下的异常响应需要系统寄存器(SR)。riscv32的SR包括了控制状态寄存器(CSR寄存器)和mtvec寄存器等

CTE

- 程序的状态, 在**操作系统**中有一个等价的术语, 叫"上下文"
- 与IOE一样, 上下文管理的具体实现也是架构相关的
- 将上下文管理的功能划入到AM的一类新的API中, 名字叫CTE(ConText Extension).
- 操作系统的处理过程其实需要哪些信息：
  - 引发这次执行流切换的原因`Event`
  - 程序的上下文`Context`
- 因为Context是架构相关的，所以操作系统直接引用Context成员时候，会损坏操作系统的可移植性
- 保证操作系统的相关代码与架构无关的两个API

中断视频

- IF中断：cpu是否响应中断
- 函数调用时候的状态保存栈
- sigsegv信号
- 如何利用c语言提供的异常捕捉功能，来处理ring3状态下，使用汇编指令cli导致的段错误？
- thread-os.c（联合体）task的next怎么连接的？

控制状态寄存器(CSR寄存器). 在PA中, 我们只使用如下3个CSR寄存器:

- mepc寄存器 - 存放触发异常的PC
- mstatus寄存器 - 存放处理器的状态
- mcause寄存器 - 存放触发异常的原因

riscv32触发异常后硬件的响应过程如下:

1. 将当前PC值保存到mepc寄存器
2. 在mcause寄存器中设置异常号
3. 从mtvec寄存器中取出异常入口地址
4. 跳转到异常入口地址

今天看了未名子的[【青年建议】初中、高中成绩差的最根本原因和解决方法](https://www.bilibili.com/video/BV1aM4y1T7f3/?spm_id_from=333.999.0.0&vd_source=842936ebeedd7cce8bb2e1922b41edf1)。未名子将学习学不明白的原因，归结于个人心境的封闭：要么认为自己是无敌的，与权威的教科书和老师叫板；要么彻底跪拜在应试教育的模式下，在这种封闭的环境下，将某次考试归结于应试教育的牛逼，差劲归结于”超纲“。

这两种情况出现的根源，就是自己内心的封闭：拒接承认教科书的权威性。第一种不必多言，遇到新知识点与自己所认知的知识体系冲突，他一般会选择大手一挥：放屁，这纯属胡说八道！第二种比较隐晦，仿佛他很谦逊地学习这个体系的东西，但是依旧是将封闭的自我折射到这个不完善的应试教育中。具体的差别我还不算理解，他提到的犬儒主义，我甚是感兴趣。

而反观自己，高中时候就是第一种情况：在遇到老师讲解的权威教科书知识体系与自己的认知冲突的时候，我会选择用所谓的”不可能，怎么可能这样“这样的句式开始，陷入到自我解释宠物的泥潭中：”我怎么可能有错？我万一是对的呢？“

我用一种简单的方法，逃避了本应该面对权威教科书知识体系和自己认知冲突的时的应对措施：接纳自己的失败和有限性，并且认真地去学习权威知识体系。

这样我就可以不做工地达到精神胜利了：至少我没错！

可是这样就是不能承认失败的表现啊。对于权威知识体系的考量来说，你的认知确实对于它不值一提。大大方方地承认自己的局限性，老老实实地在认识到痛苦后解决掉自己脑子里错误的思维方式，才是针对应该要做的。

下一个觉得很有意思的就是知乎的帖子，里面探讨了技术路线和市场需求的相互结合.

## 11.5

[如何不虚度大学的时光？ - 白诗诗的回答 - 知乎](https://www.zhihu.com/question/36766890/answer/70795756)
整体性学习：

- 获取信息
  - **简化** 找出真正需要的信息
  - **速度** 好的阅读和听讲方法能使获取阶段大为改善
- 理解：了解信息的基本意思
- 拓展：深度、横向
- 纠错：寻找错误，**删除无效的联系**
- 应用：**更多的实践，抛开书本，走出去，去做实验，去接触生活，去融入社会。**
- 测试

提升方法：

- 获取知识：

  - 联系阅读法。目的并不是吸收阅读的内容，练习阅读的唯一目的是训练自己以尽快的速度**理解**所读内容。

  - 积极阅读：这一节中主要点是什么？ ——获取完整信息

    我怎样才能记住主要点？ ——对信息进行联系、比喻法（寻找比喻的欲望 除非你不断地**问**自己什么样的比喻才能很好地描述要学的知识，否则你什么也得不到。）

    我要怎样将主要点拓展开以及应用它？——运用

  - **一次学会**：在学习时要全神贯注地听老师讲课， 而不是 忙着做细致漂亮的笔记，等到课下再学。记笔记是为了更好地理解所学内容，不要忘记这个目的。 使用笔记流时，首先写下最主要的观点，尽 量用**很短的单词**来替换完整的句子。　　

**ecall执行时硬件的工作**(硬件提供的异常响应)

1. 保存当前状态：mepc记录执行ecall指令时的地址
2. 设置异常或中断原因：mcause寄存器
3. 控制流转移：PC <- SR[mtvec]

**初始化异常入口地址**

```c
asm volatile("csrw mtvec, %0" : : "r"(__am_asm_trap));
```

## 11.6

学习摘抄：

- 学习以一章为单位
- 完成规定任务量后，在某一个热情高涨的时候索性中断学习（不要让自己在“累”的感觉中结束任务）

第一步阅读：

- 看目录：大概讲一个什么问题？
- 看章节习题：圈关键术语
- 根据术语浏览书中概念和术语解释
- 理解图标和立体

浏览用户程序和系统调用

- ,Nanos-lite是运行在AM之上, AM的API在Nanos-lite中都是可用的
-  如果你现在不能理解什么是进程, 你只需要把进程作为"正在运行的程序"来理解就可以了
- Nanos-lite目前的行为：
  - -打印Project-N的logo
  - 调用`init_device()`对设备进行一些初始化操作
    - 初始化`ramdisk`
  - `init_fs()`和`init_proc()`
  - 调用`panic()`结束Nanos-lite的运行.
- HAS_CTE
  - 初始化时调用`init_irq()`函数, 它将通过`cte_init()`函数初始化CTE
  - 在`panic()`前调用`yield()`来触发自陷操作
- 加载的过程就是把用户程序（可执行文件）中的代码和数据放置在正确的内存位置, 然后跳转到程序入口
- 用户程序哪里来的？
- os使用系统调用对系统中的资源进行统一的管理（承接系统所有资源和用户程序的需求）
-  系统调用把整个运行时环境分成两部分, 一部分是操作系统内核区, 另一部分是用户区
- 触发一个系统调用：程序描述自己的需求, 然后告诉操作系统(自陷指令)
- 如何使用通用寄存器来向操作系统描述需求？

## 11.7

回顾

- `__am_irq_handle()`的代码会把执行流切换的原因打包成事件, 然后调用在`cte_init()`中注册的**事件处理回调函数**, 将事件交给`yield test`来处理. 在`yield test`中, 这一回调函数是`am-kernels/tests/am-tests/src/tests/intr.c`中的`simple_trap()`函数. `simple_trap()`函数会根据事件类型再次进行分发.

- ```c
  void yield() {
    asm volatile("li a7, -1; ecall");
  }
  ```

  `li a7, -1` 是用来设置系统调用编号，`-1` 可能是一个特殊的值，用于标识特定的系统调用。

  `ecall` 是用来触发系统调用的，它会导致程序进入操作系统内核并执行系统调用的处理程序。

- 模拟异常响应机制`isa_raise_intr`

  ```c
  word_t isa_raise_intr(word_t NO, vaddr_t epc) {
    /* TODO: Trigger an interrupt/exception with ``NO''.
     * Then return the address of the interrupt/exception vector.
     */
  
    return 0;
  }
  ```

  riscv32触发异常后硬件的响应过程如下:

  1. 将当前PC值保存到mepc寄存器
  2. 在mcause寄存器中设置异常号
  3. 从mtvec寄存器中取出异常入口地址
  4. 跳转到异常入口地址

- 异常的处理`__am_irq_handle`

  `__am_irq_handle`会把执行流切换的原因打包成事件,然后调用在`cte_init()`中注册的事件处理回调函数, 将事件交给`yield test`来处理. 

  ```c
  Context* __am_irq_handle(Context *c) {
    if (user_handler) {
      Event ev = {0};
      switch (c->mcause) {
        default: ev.event = EVENT_ERROR; break;
      }
  
      c = user_handler(ev, c);
      assert(c != NULL);
    }
  
    return c;
  }
  ```

  - CTE的`__am_irq_handle()`函数需要正确识别出自陷事件，并且打包成编号为`EVENT_YIELD`的事件

- 从`__am_asm_trap`获取结构体`Context`成员顺序

  ```asm
  .align 3
  .globl __am_asm_trap
  __am_asm_trap:
    addi sp, sp, -CONTEXT_SIZE
  
    MAP(REGS, PUSH)
  
    csrr t0, mcause
    csrr t1, mstatus
    csrr t2, mepc
  
    STORE t0, OFFSET_CAUSE(sp)
    STORE t1, OFFSET_STATUS(sp)
    STORE t2, OFFSET_EPC(sp)
  
    # set mstatus.MPRV to pass difftest
    li a0, (1 << 17)
    or t1, t1, a0
    csrw mstatus, t1
  
    mv a0, sp
    jal __am_irq_handle
  
    LOAD t1, OFFSET_STATUS(sp)
    LOAD t2, OFFSET_EPC(sp)
    csrw mstatus, t1
    csrw mepc, t2
  
    MAP(REGS, POP)
  
    addi sp, sp, CONTEXT_SIZE
    mret
  ```

  - riscv32则是将地址空间信息与0号寄存器共用存储空间, 反正0号寄存器的值总是0, 也不需要保存和恢复. 

  ```c
  struct Context {
    // TODO: fix the order of these members to match trap.S
    uintptr_t mepc, mcause, gpr[NR_REGS], mstatus;
    void *pdir;
  };
  ```

**系统调用**

- riscv32如何利用通用寄存器，区分硬件的自陷指令`ecall`是由于自陷操作还是系统调用执行的呢？
- Nanos-lite收到系统调用事件`EVENT_SYSCALL`之后, 就会调出系统调用处理函数`do_syscall()`进行处理.
  - 获取系统调用参数
  - 通过系统调用参数分发处理

# PA3 - 穿越时空的旅程: 批处理系统

## 穿越时空的旅程

### 概览

**需求**

程序内部的执行流切换：函数A和函数B可以简单地通过`call/jal`指令实现；

程序之间的执行流切换：因为安全问题，程序Prog1和程序Prog2的执行流切换只能交给操作系统和硬件来共同实现。

为了满足程序之间的执行流切换，需要硬件和操作系统（或AM）共同协作。

**实现目标**

通过软硬件协作，实现程序的执行流切换

下面本节具体例子来帮助理解：通过`am-tests`中的`yield test`测试触发一次自陷操作![yield test逻辑](C:\Users\crx\Desktop\pa3\yield.png)

**实现的功能概览**

- 实现“硬件响应机制”
- 实现CTE的异常处理功能

**注意**

本节中的描述中，“操作系统”其实就是一个管理各种硬件资源和软件资源的软件。在本节“穿越时空的旅程”中，硬件就是NEMU本身，而与硬件直接交互的“操作系统”软件就是库函数AM。所以实现最终目标的方法，就是通过实现NEMU和AM的相关指令和函数，来实现程序的执行流切换.

### 硬件的异常响应机制

为满足程序之间的执行流切换，硬件提供了名为“异常响应机制”的功能。

- 扩充寄存器
- 添加指令

### CTE的异常处理功能

异常入口地址是硬件和操作系统（或AM）约定好的, 接下来的处理过程将会由操作系统来接管

#### 初始化CTE环境

`cte_init()`

#### 异常处理

`__am_asm_trap`

- 保存上下文
- 异常处理函数`__am_irq_handle()`
- 回复上下文
- 异常返回指令

### 自陷操作举例

## 11.8

在PA3.1的内容中，能够实现程序的执行流切换的

## 11.9

实现指令

- csrrw rd, csr, rs1
  - x[rd]	 = CSRs[csr]
  - VSRs[csr] = x[rs1]

- csrrs rd, csr, rs1
  -  t = CSRs[csr]
  - CSRs[csr]  =  t | x[rs1]
  -  x[rd] = t
- mret
  - PC = CSRs[mepc]

需要实现读取csr寄存器的值函数：获取csr编号，根据csr编号获取寄存器的值

## 11.11

### printf安全性

编译运行Nanos-lite的时候，报错

```c
riscv32-nemu-interpreter: src/device/io/map.c:40: check_bound: Assertion `map != ((void *)0)' failed.
make[1]: *** [/home/crx/study/ics2023/nemu/scripts/native.mk:38: run] Aborted (core dumped)
make[1]: Leaving directory '/home/crx/study/ics2023/nemu'
make: *** [/home/crx/study/ics2023/abstract-machine/scripts/platform/nemu.mk:28: run] Error 2
```

因为是在输出了文件`nanos-lite\resources\logo.txt`后报错，怀疑是调用`printf`报错。注释后解决问题。

问题：如何处理`printf()`处理字符超出最大值`MAX_STRING_LEN`的情况

```c
int printf(const char *fmt, ...) {
	char buf[MAX_STRING_LEN];
	va_list args;
	va_start(args, fmt);

	int len = process_format_string(buf, fmt, args);

	for (int i = 0; i < len; i++) {
		putch(buf[i]);
	}
	
	return len;
}
```

### 加载地址

```c
static uintptr_t loader(PCB *pcb, const char *filename) {
  size_t count;
  Elf_Phdr pt_load_segments[MAX_SEGMENTS];
  // 获取要加载的段信息
  uintptr_t entry = get_pt_load_segments(filename, pt_load_segments, &count);

  // 加载段到内存中
	load_segments(pt_load_segments, count);
  return entry;
}	
```

正常跳转后，发现之前图省事将所有情况下调用`ecall`指令时，对应的异常响应机制`isa_raise_intr()`的入参`NO`均设置为了固定值16。这里按照寄存器`a7`的值对应异常的种类，改写

```
isa_raise_intr（isa_reg_str2val("a7", &success), s->pc)
```

## 11.12

工欲善其事必先利其器。

发现了linux命令行在编写代码时候的不方便了。具体不方便之处在于：

- 列出包含关键词的文件操作：快捷操作，用于在当前目录及其子目录下递归搜索指定的关键词，并仅在 `.c` 和 `.h` 文件中查找

  ```bash
  alias g='grep -nr --include="*.c" --include="*.h" '
  ```

- vim打开文件的特定行

  ```bash
  vim +N file
  ```

- tree命令选项

  ```bash
  #只看目录，不看文件
  -d     List directories only.
  -x     Stay on the current file-system only.
  -L level Max display depth of the directory tree.
  # 例如只看nemu/src目录下的文件
  tree -x nemu/src/
  
  ```

- vim的操作

最终，直接舍弃vim操作。转向用vscode连接虚拟机开发。配置ssh密钥：

1. 在本地计算机上生成SSH密钥对

   ```bash
   ssh-keygen -t rsa -b 4096
   ```

2. 将公钥复制到 Ubuntu 虚拟机

   ```bash
   echo "your_public_key" >> ~/.ssh/authorized_keys
   ```

3. 验证SSH密钥登陆

   ```bash
   ssh user@<Ubuntu_IP_address>
   ```

vscode确实用着更顺手一点。

RISCV32的相关问题：

### RV32I 寄存器

为什么NEMU要给riscv32的寄存器提供名称？

riscv32架构下，cpu的32个通用寄存器定义在`isa-def.h`中。而关于其通用寄存器`gpr`的解释定义在下面的`reg.c`中。`reg.c`为RV32I 寄存器提供了可读性较好的ABI定义的寄存器名称。

RISC-V 32 的寄存器使用 ABI（Application Binary Interface，应用二进制接口）的名称的原因：

1. **标准化函数调用**：
   - 使用 ABI 的命名（如 `a0` 到 `a7` 表示参数寄存器，`t0` 到 `t6` 表示临时寄存器等）明确了寄存器在函数调用中的用途。例如，函数参数通过 `a0` 到 `a7` 传递，返回值通过 `a0` 和 `a1` 返回，这种标准化便于程序员和编译器理解每个寄存器的用途，并统一函数调用的接口规则。
   - 在进行函数调用时，编译器能根据 ABI 规范安排寄存器，方便管理数据传递和调用栈，简化了函数调用流程。
2. **跨平台和语言兼容性**：
   - ABI 名称建立了通用的接口和约定，使得不同编程语言和工具链（如编译器、链接器）能够基于同一规则协同工作。RISC-V 的 ABI 规范是跨平台的，即便在不同的操作系统和环境中，ABI 命名规则保持一致，确保代码的可移植性和兼容性。
   - 例如，编写汇编代码时，用 `sp` 表示栈指针，而不是 `x2`，这样代码的可读性和可维护性更高，也方便跨平台移植
3. **提高可读性和可维护性**：
   - 相比直接使用 `x0` 到 `x31` 的编号，ABI 名称（如 `sp`、`ra` 等）更容易让程序员理解寄存器的用途。例如， `sp` 代表栈指针，`ra` 代表返回地址，`s0` 到 `s11` 代表保存寄存器（函数调用中需要保存的数据），这使代码更具可读性。

ABI类似遥控器，简化了我们与硬件的交互难度。例如我们只需要知道这个遥控器（栈指针`sp`）的是调节风扇转速的功能（保存栈顶的地址），就可以与风扇（程序）交互。

### CSR地址映射

CSR有关的命令中例如`csrrw`和`csrrs`

![image-20241112143045188](E:\backup\software\typora_image\image-20241112143045188.png)

其中对于csr的地址编码是12位。在机器模式M下的一些CSR的地址分配情况如下：

![image-20241112143405409](E:\backup\software\typora_image\image-20241112143405409.png)

更多信息可以访问[The RISC-V Instruction Set Manual: Volume II](https://github.com/riscv/riscv-isa-manual/releases/tag/20240411) 的2.2小节。

## yield test

从`yield test`调用`yield()`开始, 到从`yield()`返回的期间, 这一趟旅程具体经历了什么?

### 准备工作

在调用自陷操作前，CTE已经做好了初始化CTE环境，设置好CTE的异常处理程序`__am_asm_trap`地址，同时注册特定的事件处理函数`simple_trap`.

```c
CTE(simple_trap)
static Context* (*user_handler)(Event, Context*) = NULL;

bool cte_init(Context*(*handler)(Event, Context*)) {
  // initialize exception entry
  asm volatile("csrw mtvec, %0" : : "r"(__am_asm_trap));

  // register event handler
  user_handler = handler;

  return true;
}
```

### 应用程序调用yield()

`hello_intr`调用函数`yield()`

```C
void hello_intr() {
  printf("Hello, AM World @ " __ISA__ "\n");
  printf("  t = timer, d = device, y = yield\n");
  io_read(AM_INPUT_CONFIG);
  iset(1);
  while (1) {
    for (volatile int i = 0; i < 1000000; i++) ;
    yield();
  }
}
```

**yield的实现**

```c
void yield() {
  asm volatile("li a7, -1; ecall");
}
```

- 将立即数`0xFFFFFFFF`赋值给寄存器`a7`
- 调用自陷指令`ecall`

使用`a7`寄存器的原因：程序的许多**事件**都会使用自陷指令`ecall`，所以CTE使用寄存器`a7`的值来区分不同的**事件**。`a7` 的用途是由 CTE（Context Extension）和操作系统（AM）约定的，因此在执行 `ecall` 之前，用户程序会将系统调用号放入 `a7`，供操作系统在处理时读取。

### 硬件

译码自陷指令 `ecall` 时，译码器的操作为：

- 将异常号和当前PC传递给异常响应硬件处理
- 跳转到异常入口地址

在 RISC-V 架构中，`ecall` 指令的异常号是由硬件定义的。而此异常号会被控制状态寄存器(CSR)`mcause`寄存器保存。这里我们需要在riscv32的NEMU中加入CSR寄存器的相关支持（在`nemu/src/isa/riscv32/include/isa-def.h`中定义）

```C
// 用于控制和监控 CPU 状态的特殊寄存器
typedef struct control_and_status_registers {
	word_t mtvec;  // 异常入口地址
	word_t mepc;   // 触发异常的PC
	word_t mstatus;// 处理器的状态
	word_t mcause; // 触发异常的原因
}CSRs;

// 常用 CSR 地址
typedef enum {
  // Machine Trap Setup
	CSR_MSTATUS = 0x300,  // mstatus
	CSR_MTVEC   = 0x305,  // mtvec

  // Machine Trap Handling
	CSR_MEPC    = 0x341,	// mepc
	CSR_MCAUSE  = 0x342,  // mcause
}csr_id;

typedef struct {
  word_t gpr[MUXDEF(CONFIG_RVE, 16, 32)];
  vaddr_t pc;
	CSRs csrs;
} MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state);
```

对于其CSR的读写功能，则放到寄存器功能模块中实现（在`nemu/src/isa/riscv32/local-include/reg.h`中定义）

```c
word_t get_csr_val_by_id(int csr_id);
void set_csr_val_by_id(int csr_id, word_t val);

#define read_csrs(idx) (get_csr_val_by_id(idx)) 
#define write_csrs(idx, val) (set_csr_val_by_id(idx, val))
```

将 RISC-V 机器中的手册中`mcause`中保存的异常号定义为枚举类（在`nemu/src/isa/riscv32/include/isa-def.h`中定义）：

```c
typedef enum {
  //mcause 的最高位在发生中断时置 1,发生同步异常时置 0
    INSTRUCTION_ADDRESS_MISALIGNED = 0,  // 指令地址未对齐
    INSTRUCTION_ACCESS_FAULT       = 1,  // 指令访问故障
    ILLEGAL_INSTRUCTION            = 2,  // 非法指令
    BREAKPOINT                     = 3,  // 断点
    LOAD_ADDRESS_MISALIGNED        = 4,  // 加载地址未对齐
    LOAD_ACCESS_FAULT              = 5,  // 加载访问故障
    STORE_ADDRESS_MISALIGNED       = 6,  // 存储地址未对齐
    STORE_ACCESS_FAULT             = 7,  // 存储访问故障
    ENVIRONMENT_CALL_FROM_U_MODE   = 8,  // 用户模式的环境调用
    ENVIRONMENT_CALL_FROM_S_MODE   = 9,  // 管理模式的环境调用（若存在）
    ENVIRONMENT_CALL_FROM_M_MODE   = 11, // 机器模式的环境调用
    INSTRUCTION_PAGE_FAULT         = 12, // 指令页面故障
    LOAD_PAGE_FAULT                = 13, // 加载页面故障
    STORE_PAGE_FAULT               = 15, // 存储页面故障
    // 中断的最高位为1，这里使用更大的数值表示
    INTERRUPT_MACHINE_TIMER        = 0x80000007, // 机器定时器中断
    INTERRUPT_MACHINE_EXTERNAL     = 0x8000000b  // 机器外部中断
} RiscV_ExceptionCode;   
```

因为PA不涉及特权级的切换, 这里不需要关心和特权级切换相关的内容，所以自陷指令`ecall`的异常号设置为`ENVIRONMENT_CALL_FROM_U_MODE`（8）即可。

随后译码器调用硬件的异常处理模块，并将自陷指令的异常码和当前PC作为参数，进行异常响应。这里模拟硬件的异常响应机制的函数为`isa_raise_intr()`：

```C
/** 模拟硬件异常响应机制*/
word_t isa_raise_intr(word_t NO, vaddr_t epc) {

	// 将当前PC值保存到mepc寄存器
	cpu.csrs.mepc = epc;
  
  // 在mcause寄存器中设置异常号
	cpu.csrs.mcause = NO;

	// 从mtvec寄存器中取出异常入口地址
	return cpu.csrs.mtvec;
}
```

这样译码`ecall`的操作为

```c
#define ECALL(dnpc) { dnpc = isa_raise_intr(ENVIRONMENT_CALL_FROM_U_MODE, s->pc);}

INSTPAT("0000000 00000 00000 000 00000 11100 11", ecall  , N, ECALL(s->dnpc));
```

译码结束后，此时PC指向异常处理程序`__am_asm_trap`的入口地址

### 操作系统

成功跳转到异常入口地址之后, 我们就要在软件上开始真正的异常处理过程了.异常处理过程包括：

1. 保存上下文（程序的状态）
2. 事件分发（按照异常号分发事件和按照事件分发具体事件处理）
3. 恢复上下文

异常处理的时候，首先会将程序异常状态的上下文保存起来。CTE定义通用的上下文包括：

- 通用寄存器
- 触发异常时的PC和处理器状态
- 异常号
- 地址空间

看代码的操作可以得知，CTE从栈顶`sp`位置从近到远依次保存了：

- 通用寄存器：32个通用寄存器（不包含0号和2号寄存器）
- mcause
- mstatus
- mepc

地址空间去哪了？栈申请了36个空间保存上下文成员，此时栈底`sp+35`还存在一个空闲位置，应该就是存放地址空间的位置了。

中途用到的CSR读写指令为

```c
  INSTPAT("??????? ????? ????? 001 ????? 11100 11", csrrw  , I, R(rd) = read_csrs(imm); write_csrs(imm, src1));
  INSTPAT("??????? ????? ????? 010 ????? 11100 11", csrrs  , I, R(rd) = read_csrs(imm); word_t val = read_csrs(imm) | src1; write_csrs(imm,val));
```

分析异常事件处理函数`__am_irq_handle()`，其入参为一个指向上下文结构体`Context`的指针。而栈`sp`就是保存着结构体`Context`的指针，所以上下文保存完毕后，将`sp`作为参数，调用函数`__am_irq_handle()`。

在CTE中，按照栈保存上下文的顺序，可以得出结构体`Context`的顺序：

```C
struct Context {
	uintptr_t gpr[NR_REGS], mcause, mstatus, mepc;
	void *pdir;
};
```

保存上下文结束后，调用的异常处理函数`__am_irq_handle()`进行异常号的分发。此操作会将执行流切换的原因打包成事件, 然后调用在`cte_init()`中注册的事件处理回调函数（`simple_trap()`）, 将事件交给`yield test`来处理.

这时候需要`__am_irq_handle()`通过异常号识别出自陷异常，并打包成编号为`EVENT_YIELD`的自陷事件。要想在AM上识别RISCV32硬件的异常号，还需要再从AM上定义一份`mcause`的异常号（在`abstract-machine/am/src/riscv/riscv.h`中定义）。实现后的`__am_irq_handle()`：

```C
Context* __am_irq_handle(Context *c) {
  if (user_handler) {
    Event ev = {0};
    switch (c->mcause)
    {
      case ENVIRONMENT_CALL_FROM_U_MODE:  ev.event = EVENT_YIELD; break;
      default:  ev.event = EVENT_YIELD; break;
    }
    c = user_handler(ev, c);	// simple_trap
    assert(c != NULL);
  }

  return c;
}
```

其中调用注册的`simple_trap()`函数进行事件的处理：

```c
Context *simple_trap(Event ev, Context *ctx) {
  switch(ev.event) {
    case EVENT_IRQ_TIMER:
      putch('t'); break;
    case EVENT_IRQ_IODEV:
      putch('d'); break;
    case EVENT_YIELD:
      putch('y'); break;
    default:
      panic("Unhandled event"); break;
  }
  return ctx;
}
```

根据事件`EVENT_YIELD`输出了一个字符`y`。

这样异常处理函数`__am_irq_handle()`处理完应用程序的异常号后，返回到异常处理程序`__am_asm_trap`。随后进行恢复上下文。此时由于CSR寄存器`mepc`保存的是调用`ecall`时候的地址，需要在恢复过程中，将`epc`设置为执行`ecall`的下一条指令。这样异常处理程序最后调用`mret`指令取出下一条指令的地址就是正确的。

```c
INSTPAT("0011000 00010 00000 000 00000 11100 11", mret   , N, s->dnpc = read_csrs(CSR_MEPC));
```

异常处理程序执行完毕后，PC指向`ecall`的下一条指令。此时调用`yield()`触发自陷操作的函数`hello_intr`，会进入一个循环，循环结束后，又会再来调用`yield()`触发自陷操作。

```c
  while (1) {
    for (volatile int i = 0; i < 1000000; i++) ;
    yield();
  }
```

至此完结

## 11.13

## etrace

用etrace记录异常处理的踪迹，就在异常响应机制下手即可。在实现异常响应之后，记录异常状态：

- 异常号
- 程序计数器
- 寄存器值
- 异常处理入口地址

```C
// etrace
/* 记录异常处理的踪迹 */
void etrace(const char *inst, vaddr_t epc, word_t mcause, word_t gpr, word_t mtvec){
  etrace_write("etrace: %s epc = " FMT_WORD ", mcause = "FMT_WORD", gpr(a7) = " FMT_WORD", mtvec = "FMT_WORD "\n",
  inst, epc, mcause, gpr, mtvec);
}
#define ETRACE(inst) do { bool success = true; word_t a7 = isa_reg_str2val("a7",&success); assert(success);  etrace(inst, read_csrs(CSR_MEPC), read_csrs(CSR_MCAUSE), a7, read_csrs(CSR_MTVEC));} while(0)

#define ECALL(dnpc) do { dnpc = isa_raise_intr(ENVIRONMENT_CALL_FROM_U_MODE, s->pc); ETRACE("ecall");} while(0)
```

但是此时查看日志发现并没有关于etrace的记录。在`etrace`函数中，添加printf函数，发现`etrace`调用printf函数输出正确信息，但是并没有执行`log_write`的指令。

```c
#define log_write(...) IFDEF(CONFIG_TARGET_NATIVE_ELF, \
  do { \
    extern FILE* log_fp; \
    extern bool log_enable(); \
    if (log_enable()) { \
      fprintf(log_fp, __VA_ARGS__); \
      fflush(log_fp); \
    } \
  } while (0) \
)
```

最终调试发现是`log_enable()`是错误的。继续查看`log_enable()`的源码：

```C
bool log_enable() {
  return MUXDEF(CONFIG_TRACE, (g_nr_guest_inst >= CONFIG_TRACE_START) &&
         (g_nr_guest_inst <= CONFIG_TRACE_END), false);
}
```

那我们先不管`g_nr_guest_inst`具体含义直接自定义一个`etrace_write()`

```c
#define etrace_write(...) IFDEF(CONFIG_TARGET_NATIVE_ELF, \
  do { \
    extern FILE* log_fp; \
    fprintf(log_fp, __VA_ARGS__); \
    fflush(log_fp); \
  } while (0) \
)
```

调用此即可实现etrace功能。输出例子如下：

```bash
etrace: ecall epc = 0x80001408, mcause = 0x00000008, gpr(a7) = 0xffffffff, mtvec = 0x80001418
etrace: mret  epc = 0x8000140c, mcause = 0x00000008, gpr(a7) = 0xffffffff, mtvec = 0x80001418
```

遗留问题：`g_nr_guest_inst`的功能。

## syscall

分析`_syscall_`的相关参数：

```C
intptr_t _syscall_(intptr_t type, intptr_t a0, intptr_t a1, intptr_t a2) {
  register intptr_t _gpr1 asm (GPR1) = type;
  register intptr_t _gpr2 asm (GPR2) = a0;
  register intptr_t _gpr3 asm (GPR3) = a1;
  register intptr_t _gpr4 asm (GPR4) = a2;
  register intptr_t ret asm (GPRx);
  asm volatile (SYSCALL : "=r" (ret) : "r"(_gpr1), "r"(_gpr2), "r"(_gpr3), "r"(_gpr4));
  return ret;
}
```

其相关的宏定义为

```c
// helper macros
#define _concat(x, y) x ## y
#define concat(x, y) _concat(x, y)
#define _args(n, list) concat(_arg, n) list
#define _arg0(a0, ...) a0
#define _arg1(a0, a1, ...) a1
#define _arg2(a0, a1, a2, ...) a2
#define _arg3(a0, a1, a2, a3, ...) a3
#define _arg4(a0, a1, a2, a3, a4, ...) a4
#define _arg5(a0, a1, a2, a3, a4, a5, ...) a5

// extract an argument from the macro array
#define SYSCALL  _args(0, ARGS_ARRAY)
#define GPR1 _args(1, ARGS_ARRAY)
#define GPR2 _args(2, ARGS_ARRAY)
#define GPR3 _args(3, ARGS_ARRAY)
#define GPR4 _args(4, ARGS_ARRAY)
#define GPRx _args(5, ARGS_ARRAY)
# define ARGS_ARRAY ("ecall", "a7", "a0", "a1", "a2", "a0")
```

首先从`GPR1`开始拆解宏定义。

```C
GPR1 -> _args(1, ARGS_ARRAY)
_args(1, ARGS_ARRAY)  -> _arg1 ARGS_ARRAY
_arg1(ARGS_ARRAY) -> a7
```

其他拆解同理，拆解完毕后分析内联汇编语法。

```c
intptr_t _syscall_(intptr_t type, intptr_t a0, intptr_t a1, intptr_t a2) {
  register intptr_t _gpr1 asm ("a7") = type;
  register intptr_t _gpr2 asm ("a0") = a0;
  register intptr_t _gpr3 asm ("a1") = a1;
  register intptr_t _gpr4 asm ("a2") = a2;
  register intptr_t ret asm ("a0");
  asm volatile ("ecall" : "=r" (ret) : "r"(_gpr1), "r"(_gpr2), "r"(_gpr3), "r"(_gpr4));
  return ret;
}
```

例如

```c
register intptr_t _gpr1 asm ("a7") = type;
```

1. `register`：C 语言的一个关键字，表示该变量建议存储在 CPU 寄存器中，而不是内存中。
2. `_gpr1`：这是声明的变量名
3. `asm (GPR1)`：将 C 变量`_gpr1`与汇编寄存器 `a7` 绑定起来。这样编译器会将该`_gpr1`的值加载到`a7`寄存器中.
4. `= type;`：这部分是变量 `_gpr1` 的初始化，`_gpr1` 被初始化为 `type` 的值。

这行代码包含的关键意思就是将变量`_gpr1`与寄存器`a7`绑定起来。

最后

```C
asm volatile ("ecall" : "=r" (ret) : "r"(_gpr1), "r"(_gpr2), "r"(_gpr3), "r"(_gpr4));
```

1. 输出操作数（`: "=r" (ret)`）
   - `=r` 是一个输出操作数约束符，告诉编译器，输出操作数 `ret`（存储返回值的变量）需要被存储在一个通用寄存器中。
   - `ret` 是一个变量，它将存储 `ecall` 执行后的返回值（即通过 `a0` 寄存器返回的值）。在执行 `ecall` 后，`a0` 寄存器中存放的值将被复制到 `ret`。
2. 输入操作数（`: "r"(_gpr1), "r"(_gpr2), "r"(_gpr3), "r"(_gpr4)`）
   - `"r"` 表示 `a7`、`a0`、`a1` 和 `a2`（也就是 RISC-V 的通用寄存器）
   - `_gpr1`, `_gpr2`, `_gpr3`, `_gpr4` 是用来传递给 `ecall` 的四个输入参数，分别放在寄存器`a7`、`a0`、`a1` 和 `a2`中

具体来说，`_gpr1` 会被存储到 a7 寄存器，`_gpr2` 会被存储到 a0 寄存器，`_gpr3` 会被存储到 a1 寄存器，`_gpr4` 会被存储到 a2 寄存器。

此时`ecall`执行后，`ret`变量将包含`a0`寄存器的值。

## dummy的系统调用

### os的异常处理

让Nanos-lite（后面统称为os）事件处理回调函数识别自陷事件`EVENT_YIELD`.

os初始化CTE的时候，注册的回调函数为`do_event`，所以修改其中的事件判断条件即可（在`nanos-lite/src/irq.c`中定义）

```C
static Context* do_event(Event e, Context* c) {
  switch (e.event) {
		case EVENT_YIELD:   printf("EVENT_YIELD event!\n");   break;
		case EVENT_SYSCALL: do_syscall(c);                    break;
    default: panic("Unhandled event ID = %d", e.event);
  }

  return c;
}

void init_irq(void) {
  Log("Initializing interrupt/exception handler...");
  cte_init(do_event);
}
```

os可以正确触发自陷操作，为应用程序提供了执行流切换的入口。下一步就是将程序加载到os中。注意：在Nanos-lite中, `Log()`宏通过你在`klib`中编写的`printf()`输出, 最终会调用TRM的`putch()`.

### 加载程序

在操作系统中, 加载用户程序是由loader(加载器)模块负责的。其功能是：

- 从文件中获取要加载的信息`get_pt_load_segments()`
- 加载获取到的信息到内存`load_segments`
- 返回入口地址

做完了[PA](https://nju-projectn.github.io/ics-pa-gitbook/ics2023/3.3.html#%E5%8A%A0%E8%BD%BD%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F)上面的操作后，可以得知可执行文件位于ramdisk偏移为0处, 访问它就可以得到用户程序的第一个字节.结合ELF文件的操作`man 5 elf`，可以写出从ELF文件中获取要加载的信息函数`get_pt_load_segments()`

```C
// 获取 PT_LOAD 段的数组和数量，并返回控制转移的入口地址
uintptr_t get_pt_load_segments(const char *filename, Elf_Phdr *pt_load_segments, size_t *num_pt_load_segments) {

  Elf_Ehdr ehdr;
  
  // Step 1: 读取 ELF 头部
  ramdisk_read(&ehdr, 0, sizeof(Elf_Ehdr));
  
  // 检查 ELF 魔数
  if (memcmp(ehdr.e_ident, ELFMAG, SELFMAG) != 0) {
      panic("Not a valid ELF file.\n");
  }
  
  // Step 2: 读取所有 Program Headers
  Elf_Phdr phdrs[MAX_SEGMENTS];
  ramdisk_read(phdrs, ehdr.e_phoff, ehdr.e_phnum * sizeof(Elf_Phdr));
  
  // Step 3: 筛选出所有 PT_LOAD 段
  int count = 0;
  for (int i = 0; i < ehdr.e_phnum; i++) {
      if (phdrs[i].p_type == PT_LOAD) {
          pt_load_segments[count++] = phdrs[i];
      }
  }
  // 保存要加载程序段的条目
  *num_pt_load_segments = count;

  // Step 4: 返回控制转移的入口地址
  return ehdr.e_entry;
}
```

以及将程序段加载到内存中的函数`load_segments()`

```C
// 段加载函数，输入参数为pt_load_segments和其数量
void load_segments(Elf_Phdr *pt_load_segments, int num_segments){
  for (int i = 0; i < num_segments; i++) {
    Elf_Phdr *seg = &pt_load_segments[i];

    // 获取段的偏移、虚拟地址、文件大小、内存大小
    size_t offset = seg->p_offset;
    uint32_t vaddr = seg->p_vaddr;
    size_t filesz = seg->p_filesz;
    size_t memsz = seg->p_memsz;

    // 从ramdisk中读取段数据到内存
    ramdisk_read((void *)(vaddr), offset, filesz);

    // 清零 [VirtAddr + FileSiz, VirtAddr + MemSiz) 的内存
    if (memsz > filesz) {
      memset((void *)(vaddr + filesz) , 0, memsz - filesz);
    }
  }
}
```

两个主要功能做好后，loader的功能就ok了。

```C
#define MAX_SEGMENTS 16  // 假设 ELF 文件中 Program Headers 的最大数量
static uintptr_t loader(PCB *pcb, const char *filename) {
  size_t count;
  Elf_Phdr pt_load_segments[MAX_SEGMENTS];
  // 获取要加载的段信息
  uintptr_t entry = get_pt_load_segments(filename, pt_load_segments, &count);

  // 加载段到内存中
  load_segments(pt_load_segments, count);
  return entry;
}
```

### 系统调用

这里的系统调用包含两个操作：

- 系统调用参数：通过通用寄存器保存
- 系统调用指令：自陷指令`ecall`

`dummy`程序会执行系统调用方法`_syscall_()`

```c
#define SYS_yield 1
_syscall_(SYS_yield, 0, 0, 0);
```

具体定义在`navy-apps/libs/libos/src/syscall.c`中

```c
intptr_t _syscall_(intptr_t type, intptr_t a0, intptr_t a1, intptr_t a2) {
  register intptr_t _gpr1 asm (GPR1) = type;
  register intptr_t _gpr2 asm (GPR2) = a0;
  register intptr_t _gpr3 asm (GPR3) = a1;
  register intptr_t _gpr4 asm (GPR4) = a2;
  register intptr_t ret asm (GPRx);
  asm volatile (SYSCALL : "=r" (ret) : "r"(_gpr1), "r"(_gpr2), "r"(_gpr3), "r"(_gpr4));
  return ret;
}
```

结合繁多的宏定义，解析`_syscall_()`的行为：

- 通用寄存器 `a7`、`a0`、`a1` 和 `a2`分别保存系统调用的参数
- 调用自陷指令`ecall`
- 执行完毕后，将寄存器`a0`值传递给变量`ret`作为返回值

联系之前CTE中`yield()`在调用自陷指令之前，用`a7`保存了一个`-1`：

```asm
li a7, -1
```

其目的都是相同的。用`a7`来保存系统调用的类型，这样不同的事件（访问文件、IO操作等）调用相同的自陷指令进行执行流切换的时候，就可以区分出来了。

这样就要修改CTE中的异常事件处理函数`__am_irq_handle()`中，对于事件的判断条件。将之前的从CSR寄存器`mcause`判断改为从寄存器`a7`中判断

```C
Context* __am_irq_handle(Context *c) {
  if (user_handler) {
    Event ev = {0};
    int type = (int) c->GPR1;
    if (type < 0) {
      ev.event = EVENT_YIELD;
    } else if (type >= 0 && type <= 16) {
      ev.event = EVENT_SYSCALL; 
    }else {
      printf("c->GPR1 = %d\n", c->GPR1);
      assert(0);
    }
    c = user_handler(ev, c);
    assert(c != NULL);
  }
  return c;
}
```

在`abstract-machine/am/include/arch/riscv.h`中，根据RISCV32的ABI定义的寄存器名称，修改通用寄存器下标，实现正确的`GPR?`宏, 让它们从上下文`c`中获得正确的系统调用参数寄存器.

```C
#define GPR1 gpr[17] // a7
#define GPR2 gpr[10] // a0
#define GPR3 gpr[11] // a1
#define GPR4 gpr[12] // a2
#define GPRx gpr[10] // a0
```

这样异常事件打包函数`__am_irq_handle`就可以将自陷指令对应的系统调用事件`EVENT_SYSCALL`打包起来，交付给os处理了。

os收到系统调用事件之后，将会调出系统调用处理函数`do_syscall()`进行处理.并且按照用户进程之前设置好的系统调用参数（`a7`保存的值），进行下一步的分发。这里`dummy`的系统调用参数为`1`，触发了一个`SYS_yield`的系统调用。实现`SYS_yield`系统调用宏：

- 调用CTE的`yield()`
- 返回值设置为0

```C
void sys_yield(Context *c) {
  yield();
  c->GPRx = 0;
}
void sys_exit() {
  halt(SYS_exit);
}
void do_syscall(Context *c) {
  uintptr_t a[4];
  a[0] = c->GPR1;

  switch (a[0]) {
    case SYS_exit : sys_exit(c);  break;
    case SYS_yield: sys_yield(c); break;
    default: panic("Unhandled syscall ID = %d", a[0]);
  }
}
```

## 11.14

[10 系统编程和基础设施](https://www.bilibili.com/video/BV1nnUNYyENU?vd_source=842936ebeedd7cce8bb2e1922b41edf1&spm_id_from=333.788.videopod.sections)

- 配置vim快捷键，使得编写完毕后某个c文件后，直接使用快捷键执行gcc -o file file.c这个指令。需要在 `.vimrc` 文件中，添加以下内容

  ```bash
  nnoremap <F5> :w<CR>:!gcc -o %:r % && ./%:r<CR>:
  ```

- 进入一个目录后，自动列出当前目录下的文件，并且目录优先

  ```C
  # 切换目录后，优先展示目录+文件
  function cd () {
      builtin cd "$@" &&  tree -x --dirsfirst
  }
  ```

- ls指令优化：列出按访问时间排序的文件，且目录会排在文件前面

  ```c
  alias ll='ls -lt --time=access --group-directories-first'
  ```

- vim中如何快捷同步关闭/打开行数和智能缩进

  ```bash
  " F2 键切换行号显示和自动缩进设置（同开同关）
  function! ToggleLineNumberAndIndentation()
    " 检查行号和自动缩进是否都启用
    if &number && &smartindent
      " 如果都启用，则关闭它们
      set nonumber
      set noautoindent
      set nosmartindent
    else
      " 如果有一个或都没有启用，则启用它们
      set number
      set autoindent
      set smartindent
    endif
  endfunction
  
  " 将 F2 键绑定到 ToggleLineNumberAndIndentation 函数
  nnoremap <F2> :call ToggleLineNumberAndIndentation()<CR>
  ```

- vim如何快捷处理A文件内容的某几行复制到B文件的某行？

  1. 打开B文件：`:sp B.txt`
  2. 复制A内容：`:10,15y`
  3. 切换到文件B：使用 `Ctrl-w` 加上方向键（`h`, `j`, `k`, `l`）来切换到文件 B 窗口
  4. 在B文件中粘贴内容：移动至目标行，按`p`粘贴

- 如何搜寻文件名？

- `%s`的全局替换+正则表达式 

- 记录回放`qa`和`@a`

- vim如何批量选择某几列

- reverse 

- gdb连接已经执行的程序

- 默认每次make的时候，都带有参数`-j 8`

  ```bash
  MAKEFLAGS += -j8
  ```

- 快捷打开文件的某一行

## TRM

### write

```c
int _write(int fd, void *buf, size_t count) {
  return _syscall_(SYS_write, fd, buf, count);
}
```

### sbrk

`man 3 end`了解到`_end`是`.bss`

## 11.15

不要低效率写东西，浪费时间还不如玩耍。

今天的主题是，探究下AM上运行程序的时候，发生了什么事情。

# 编译AM程序

在`am-kernels/tests/am-tests`下运行下面命令，探究下基于riscv32-nemu上的AM程序的编译流程

```bash
make ARCH=riscv32-nemu mainargs = 'i' -nB
```

## 编译am-test的用户程序

```bash
# Building amtest-image [riscv32-nemu]
mkdir -p $AM_TEST/build/riscv32-nemu/src/ && echo + CC src/main.c
($CROSS_COMPILE)gcc -std=gnu11 -O2 -MMD -Wall -Werror
    -I$AM_TEST/include
    -I/abstract-machine/am/include/
    -I/abstract-machine/klib/include/ 
-D__ISA__=\"riscv32\" -D__ISA_RISCV32__ -D__ARCH__=riscv32-nemu -D__ARCH_RISCV32_NEMU -D__PLATFORM__=nemu -D__PLATFORM_NEMU -DARCH_H=\"arch/riscv.h\" -fno-asynchronous-unwind-tables -fno-builtin -fno-stack-protector -Wno-main -U_FORTIFY_SOURCE -fvisibility=hidden -DBATCH_MODE -fno-pic -march=rv64g -mcmodel=medany -mstrict-align -march=rv32im_zicsr -mabi=ilp32    -static -fdata-sections -ffunction-sections -DMAINARGS=\"i\"
    -I/abstract-machine/am/src/platform/nemu/include -DISA_H=\"riscv/riscv.h\" -c -o $TEST/build/riscv32-nemu/src/main.o $TEST/src/main.c
```

分类一下amtest的编译选项`$COMPILE_CONFIG`和`$CROSS_COMPILE`

```BASH
$COMPILE_CONFIG = 
-std=gnu11 -O2 -MMD -Wall -Werror
-D__ISA__=\"riscv32\" 
-D__ISA_RISCV32__ 
-D__ARCH__=riscv32-nemu 
-D__ARCH_RISCV32_NEMU 
-D__PLATFORM__=nemu 
-D__PLATFORM_NEMU 
-DARCH_H=\"arch/riscv.h\" 
-fno-asynchronous-unwind-tables -fno-builtin -fno-stack-protector -Wno-main 
-U_FORTIFY_SOURCE -fvisibility=hidden -DBATCH_MODE -fno-pic 
-march=rv64g -mcmodel=medany -mstrict-align -march=rv32im_zicsr -mabi=ilp32    
-static 
-fdata-sections 
-ffunction-sections 
-DMAINARGS=\"i\"
```

```BASH
$CROSS_COMPILE := riscv64-linux-gnu-
```

这样就简化为

```bash
mkdir -p $TEST/build/riscv32-nemu/src/ && echo + CC src/main.c
($CROSS_COMPILE)gcc -std=gnu11 -O2 -MMD -Wall -Werror
    -I$AM_TEST/include
    -I/abstract-machine/am/include/
    -I/abstract-machine/klib/include/
    $COMPILE_CONFIG
    -I/abstract-machine/am/src/platform/nemu/include -DISA_H=\"riscv/riscv.h\" 
-c -o $AM_TEST/build/riscv32-nemu/src/main.o $AM_TEST/src/main.c
```

此步骤就是将用户程序只编译不链接为一个目标文件`main.o`

## 编译AM文件

### 普通AM模块编译

将AM的普通模块（TRM+IOE+VME + MPE）编译为对应的目标文件（这里以`trm.c`代表的TRM模块为例）

```bash
mkdir -p /abstract-machine/am/build/riscv32-nemu/src/platform/nemu/ && echo + CC src/platform/nemu/trm.c
($CROSS_COMPILE)gcc -std=gnu11 -O2 -MMD -Wall -Werror
    -I/abstract-machine/am/src
    -I/abstract-machine/am/include
    -I/abstract-machine/am/include/
    -I/abstract-machine/klib/include/ 
	$COMPILE_CONFIG
    -I/abstract-machine/am/src/platform/nemu/include 
    -DISA_H=\"riscv/riscv.h\" 
-c -o /abstract-machine/am/build/riscv32-nemu/src/platform/nemu/trm.o /abstract-machine/am/src/platform/nemu/trm.c
```

```BASH
#COMPILE_CONFIG信息
$COMPILE_CONFIG = 
-D__ISA__=\"riscv32\" 
-D__ISA_RISCV32__ 
-D__ARCH__=riscv32-nemu 
-D__ARCH_RISCV32_NEMU 
-D__PLATFORM__=nemu 
-D__PLATFORM_NEMU 
-DARCH_H=\"arch/riscv.h\" 
-fno-asynchronous-unwind-tables -fno-builtin -fno-stack-protector -Wno-main -U_FORTIFY_SOURCE -fvisibility=hidden 
-DBATCH_MODE 
-fno-pic 
-march=rv64g -mcmodel=medany -mstrict-align -march=rv32im_zicsr -mabi=ilp32    
-static 
-fdata-sections 
-ffunction-sections 
-DMAINARGS=\"i\"
```

### CTE模块的编译

包含三个文件的编译：

- start.S
- cte.c
- trap.S

在编译CTE之前，首先将源文件 `start.S` 编译为目标文件 `start.o`

```bash
mkdir -p /abstract-machine/am/build/riscv32-nemu/src/riscv/nemu/ && echo + AS src/riscv/nemu/start.S
($CROSS_COMPILE)gcc -MMD
    -I/abstract-machine/am/src
    -I/abstract-machine/am/include
    -I/abstract-machine/am/include/
    -I/abstract-machine/klib/include/ 
    -fno-pic -march=rv64g -mcmodel=medany -mstrict-align -march=rv32im_zicsr -mabi=ilp32    -O0 
-c -o /abstract-machine/am/build/riscv32-nemu/src/riscv/nemu/start.o /abstract-machine/am/src/riscv/nemu/start.S
```

编译完毕`start.S`后，随后继续编译AM文件`cte.c`，执行流程与上面普通AM模块编译参数相同。

生成`cte.o`后，将`trap.S`编译为目标文件`trap.o`

```bash
mkdir -p /abstract-machine/am/build/riscv32-nemu/src/riscv/nemu/ && echo + AS src/riscv/nemu/trap.S
($CROSS_COMPILE)gcc -MMD
    -I/abstract-machine/am/src
    -I/abstract-machine/am/include
    -I/abstract-machine/am/include/
    -I/abstract-machine/klib/include/ 
    -fno-pic -march=rv64g -mcmodel=medany -mstrict-align -march=rv32im_zicsr -mabi=ilp32    -O0 
-c -o /abstract-machine/am/build/riscv32-nemu/src/riscv/nemu/trap.o /abstract-machine/am/src/riscv/nemu/trap.S
```

### 打包AM库

最终将AM所有模块的目标文件打包为一个静态库文件`am-riscv32-nemu.a`

```bash
echo + AR "->" build/am-riscv32-nemu.a
($CROSS_COMPILE)ar rcs /abstract-machine/am/build/am-riscv32-nemu.a 
/abstract-machine/am/build/riscv32-nemu/src/platform/nemu/trm.o 
/abstract-machine/am/build/riscv32-nemu/src/platform/nemu/ioe/ioe.o 
/abstract-machine/am/build/riscv32-nemu/src/platform/nemu/ioe/timer.o 
/abstract-machine/am/build/riscv32-nemu/src/platform/nemu/ioe/input.o 
/abstract-machine/am/build/riscv32-nemu/src/platform/nemu/ioe/gpu.o 
/abstract-machine/am/build/riscv32-nemu/src/platform/nemu/ioe/audio.o 
/abstract-machine/am/build/riscv32-nemu/src/platform/nemu/ioe/disk.o 
/abstract-machine/am/build/riscv32-nemu/src/platform/nemu/mpe.o 
/abstract-machine/am/build/riscv32-nemu/src/riscv/nemu/start.o 
/abstract-machine/am/build/riscv32-nemu/src/riscv/nemu/cte.o 
/abstract-machine/am/build/riscv32-nemu/src/riscv/nemu/trap.o 
/abstract-machine/am/build/riscv32-nemu/src/riscv/nemu/vme.o
```

编译klib文件

以`klib/src/stdio.c`为例，看下如何获取klib的目标文件。`$COMPILE_CONFIG`与编译AM时的参数相同。

```bash
mkdir -p /abstract-machine/klib/build/riscv32-nemu/src/ && echo + CC src/stdio.c
($CROSS_COMPILE)gcc -std=gnu11 -O2 -MMD -Wall -Werror
    -I/abstract-machine/klib/include
    -I/abstract-machine/am/include/
    $COMPILE_CONFIG
    -I/abstract-machine/klib/include/                                       
    -I/abstract-machine/am/src/platform/nemu/include 
    -DISA_H=\"riscv/riscv.h\" 
-c -o /abstract-machine/klib/build/riscv32-nemu/src/stdio.o /abstract-machine/klib/src/stdio.c
```

编译好所有klib的目标文件后，将klib打包为一个静态链接库`klib-riscv32-nemu.a`

```bash
echo + AR "->" build/klib-riscv32?
($CROSS_COMPILE)ar rcs /abstract-machine/klib/build/klib-riscv32-nemu.a
    /abstract-machine/klib/build/riscv32-nemu/src/stdio.o
    /abstract-machine/klib/build/riscv32-nemu/src/int64.o
    /abstract-machine/klib/build/riscv32-nemu/src/string.o
    /abstract-machine/klib/build/riscv32-nemu/src/cpp.o
    /abstract-machine/klib/build/riscv32-nemu/src/stdlib.o
    /abstract-machine/klib/build/riscv32-nemu/src/test.o   
```

## 打包用户程序am-test到ELF

这样am-test用户程序，和提供运行环境的AM的库（AM和klib）均已完成，下面就是将所有目标文件链接为一个ELF文件了。

```bash
echo + LD "->" build/amtest-riscv32-nemu.elf
($CROSS_COMPILE)ld -z noexecstack -melf64lriscv 
-T /abstract-machine/scripts/linker.ld 
	--defsym=_pmem_start=0x80000000 
	--defsym=_entry_offset=0x0 --gc-sections 
	-e _start 
	-melf32lriscv                                                                                                     -o $TEST/build/amtest-riscv32-nemu.elf
    --start-group
    $TEST/build/riscv32-nemu/src/main.o
    $TEST/build/riscv32-nemu/src/tests/video.o                                                                                   	 $TEST/build/riscv32-nemu/src/tests/mp.o
    $TEST/build/riscv32-nemu/src/tests/hello.o
    $TEST/build/riscv32-nemu/src/tests/devscan.o
    $TEST/build/riscv32-nemu/src/tests/audio/audio-data.o
    $TEST/build/riscv32-nemu/src/tests/audio.o
    $TEST/build/riscv32-nemu/src/tests/keyboard.o
    $TEST/build/riscv32-nemu/src/tests/intr.o
    $TEST/build/riscv32-nemu/src/tests/rtc.o
    $TEST/build/riscv32-nemu/src/tests/vm.o
    /abstract-machine/am/build/am-riscv32-nemu.a
    /abstract-machine/klib/build/klib-riscv32-nemu.a 
    --end-group
```

其中STFM(`man ld`)比较有意思的`ld`的链接选项：

- `-e _start`：设置符号`entry`作为程序执行的开头。如果没有`entry`这个符号，连接器将会解析`entry`为一个数字，并将其作为入口地址
- `-T .../linker.ld `：用自定义的链接脚本`linker.ld `来连接程序
- `--defsys=expression`：在链接时定义符号（如变量或标签）及其值。而且此参数与`-T`有顺序关系。
  - `--defsym` 在 `-T` 之前：链接器在处理链接脚本时会首先处理 `--defsym` 定义的符号。这意味着在链接脚本中引用的符号（比如用来设置段地址或进行内存布局）将是可用的。
  - `--defsym` 在 `-T` 之后：链接脚本中的表达式不能使用这些符号

下面就是生成反汇编文本文件：

```bash
echo \# Creating image [riscv32-nemu]
($CROSS_COMPILE)objdump -d $TEST/build/amtest-riscv32-nemu.elf > $TEST/build/amtest-riscv32-nemu.txt
```

## 生成二进制镜像文件

通过 `objcopy` 将 ELF 文件转换为 `.bin` 格式的二进制镜像文件。

```bash
echo + OBJCOPY "->" build/amtest-riscv32-nemu.bin
($CROSS_COMPILE)objcopy
  -S
  --set-section-flags
  .bss=alloc,contents
  -O binary
$TEST/build/amtest-riscv32-nemu.elf
$TEST/build/amtest-riscv32-nemu.bin
```

- `objcopy` 是 GNU 工具链中的另一个工具，用于修改目标文件格式，这里用于将 ELF 格式的可执行文件转换为二进制文件（即 `.bin` 格式）

至此，am-test的编译流程结束。

# linker.ld

抽出编译AM程序中的“打包用户程序am-test到ELF”步骤，看看链接脚本`abstract-machine/scripts/linker.ld`如何将库函数和用户程序链接起来的。

## 链接命令

首先看下链接命令：

```bash
echo + LD "->" build/amtest-riscv32-nemu.elf
($CROSS_COMPILE)ld -z noexecstack -melf64lriscv
-T /abstract-machine/scripts/linker.ld
  --defsym=_pmem_start=0x80000000
  --defsym=_entry_offset=0x0
  --gc-sections
  -e _start
  -melf32lriscv
-o $AM_TEST/build/amtest-riscv32-nemu.elf
    --start-group
    $AM_TEST/build/riscv32-nemu/src/main.o
    $AM_TEST/build/riscv32-nemu/src/tests/video.o
    $AM_TEST/build/riscv32-nemu/src/tests/mp.o
    $AM_TEST/build/riscv32-nemu/src/tests/hello.o
    $AM_TEST/build/riscv32-nemu/src/tests/devscan.o
    $AM_TEST/build/riscv32-nemu/src/tests/audio/audio-data.o
    $AM_TEST/build/riscv32-nemu/src/tests/audio.o
    $AM_TEST/build/riscv32-nemu/src/tests/keyboard.o
    $AM_TEST/build/riscv32-nemu/src/tests/intr.o
    $AM_TEST/build/riscv32-nemu/src/tests/rtc.o
    $AM_TEST/build/riscv32-nemu/src/tests/vm.o
    /abstract-machine/am/build/am-riscv32-nemu.a
    /abstract-machine/klib/build/klib-riscv32-nemu.a
    --end-group
```

这里蕴含几个关键信息：

- `linker.ld`作为链接的自定义脚本
- 设置符号（symbol）`_pmem_start`的值为0x80000000，`_entry_offset`为0。
- 设置程序的入口地址为`_start`

## 链接脚本linker.ld

接下来我们转移到链接脚本`abstract-machine/scripts/linker.ld`的具体实现：

```asm
ENTRY(_start)
PHDRS { text PT_LOAD; data PT_LOAD; }

SECTIONS {
  /* _pmem_start and _entry_offset are defined in LDFLAGS */
  . = _pmem_start + _entry_offset;
  .text : {		
    *(entry)	/* 引用与符号 entry 相关的所有内容*/
    *(.text*)	/* 将所有文件的 .text 段的内容合并到当前段*/
  } : text		/* 指定 .text 段被加载到名为 text 的内存区域中*/
  etext = .;
  _etext = .;
  .rodata : {
    *(.rodata*)
  }
  .data : {
    *(.data)
  } : data
  edata = .;
  _data = .;
  .bss : {
	_bss_start = .;
    *(.bss*)
    *(.sbss*)
    *(.scommon)
  }
  _stack_top = ALIGN(0x1000);
  . = _stack_top + 0x8000;
  _stack_pointer = .;
  end = .;
  _end = .;
  _heap_start = ALIGN(0x1000);
}
```

`linker.ld`的链接内容：

- 设置`_start`作为程序的入口点：`ENTRY(_start)`

- 加载`.text` 和 `.data` 段到内存中：`PHDRS { text PT_LOAD; data PT_LOAD; }`。`PT_LOAD`是Program Header的类型

- 设置当前地址`_pmem_start + _entry_offset`：`.` 表示当前地址，`_pmem_start + _entry_offset` 就是定义当前地址的位置。这里的地址就是`0x80000000`

- 设置`.text`、`.rodata`、`.data`、`.bss`段。其中拿出`.text`段的处理

  ```assembly
    .text : {		
      *(entry)	/* 引用与符号 entry 相关的所有内容*/
      *(.text*)	/* 将所有文件的 .text 段的内容合并到当前段*/
    } : text		/* 指定 .text 段被加载到名为 text 的内存区域中*/
  ```

- 设置栈和堆的布局

  - `_stack_top = ALIGN(0x1000);` 确保栈从 4KB 对齐的位置开始。
  - `. = _stack_top + 0x8000;` 设置栈的初始位置，分配了 32KB 的栈空间。
  - `stack_pointer = .;` 设置 `_stack_pointer` 符号，指示栈指针的位置

- 设置结束符号：`end`和`_end`

- 设置堆的起始地址，并确保堆从 4KB 对齐的位置开始` _heap_start = ALIGN(0x1000)`\

## 入口地址

而其中符号`entry`是在`abstract-machine/am/src/riscv/nemu/start.S`中定义的

```assembly
.section entry, "ax"
.globl _start
.type _start, @function

_start:
  mv s0, zero				# 清零s0寄存器
  la sp, _stack_pointer		# 将标签 _stack_pointer 的地址加载到栈指针 sp 中，符号在linker.ld中定义。
  jal _trm_init				# 这条指令会跳转到 _trm_init 标签，并将当前指令地址（即 jal 的下一条指令的地址）压入栈中
  							# _trm_init就是trm初始化函数
```

此程序设置了程序的入口点`_start`，并且将符号 `_start` 声明为一个函数类型。

结合`trm.c`的TRM初始化函数`_trm_init()`分析

```C
void _trm_init() {
  int ret = main(mainargs);
  halt(ret);
}
```

## 总结

综上所有关于链接的符号和语法，我们可以得知链接后的ELF程序的一些信息是：

- 程序入口地址`_start`设置为`0x80000000`（`ElfN_Ehdr.e_entry = 0x80000000`）
- 程序段有两个：`data`和`text`（`Elf32_Phdr.p_type == PT_LOAD`）
- `.text`代码段的开始就是`start.S`中的`.section entry` 指示的地址（`text.Elf32_Phdr.p_vaddr == 0x80000000`）
- `etext`和`_etext`符号所代表的地址为`.text`段的结尾处（`addr(_start)` + `len(.text)`）
- `eadta`和`_data`符号位于`.data`的末尾

查看ELF文件

```bash
riscv64-linux-gnu-readelf -a build/amtest-riscv32-nemu.elf
```

- 在`ELF Header`栏中，程序入口地址被设置为`0x80000000`

  ```tex
  Entry point address:               0x80000000
  ```

- 在段头表`Section Headers`中

  ```tex
  Section Headers:
    [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
    [ 0]                   NULL            00000000 000000 000000 00      0   0  0
    [ 1] .text             PROGBITS        80000000 001000 001f70 00  AX  0   0  8
    [ 2] .rodata           PROGBITS        80001f70 002f70 000e0f 00   A  0   0  4
    [ 3] .srodata.mainargs PROGBITS        80002d80 003d80 000002 00   A  0   0  4
    [ 4] .data             PROGBITS        80002d88 003d88 00de0c 00  WA  0   0  8
    [ 5] .data.code        PROGBITS        80010b94 011b94 00000f 00  WA  0   0  4
    [ 6] .sdata.first_trap PROGBITS        80010ba4 011ba4 000004 00  WA  0   0  4
    [ 7] .sdata.heap       PROGBITS        80010ba8 011ba8 000008 00  WA  0   0  4
    [ 8] .data.lut         PROGBITS        80010bb0 011bb0 000200 00  WA  0   0  4
    [ 9] .sdata.next       PROGBITS        80010db0 011db0 000004 00  WA  0   0  4
    [10] .bss              NOBITS          80010db4 011db4 084240 00  WA  0   0  4
    [11] .comment          PROGBITS        00000000 011db4 00002b 01  MS  0   0  1
    [12] .riscv.attributes RISCV_ATTRIBUTE 00000000 011ddf 000023 00      0   0  1
    [13] .symtab           SYMTAB          00000000 011e04 000dc0 10     14 138  4
    [14] .strtab           STRTAB          00000000 012bc4 000500 00      0   0  1
    [15] .shstrtab         STRTAB          00000000 0130c4 0000a0 00      0   0  1
  ```

  其中`.text`段在进程中的地址为`0x80000000`，大小为`001f70`，所以结束地址为`0x80001f70`.标志`Flg`为`AX`

  - `A`:该节是可分配的，意味着它将被映射到进程的虚拟地址空间中
  - `X`：该节是可执行的，表示它包含程序的机器指令，可以被 CPU 执行

  `.data`地址为`80002d88`，大小为`00de0c`字节，结束地址为`80010b94`

- 程序头表`Program Headers`

  ```tex
  Program Headers:
    Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
    RISCV_ATTRIBUT 0x011ddf 0x00000000 0x00000000 0x00023 0x00000 R   0x1
    LOAD           0x001000 0x80000000 0x80000000 0x02d82 0x02d82 R E 0x1000
    LOAD           0x003d88 0x80002d88 0x80002d88 0x0e02c 0x9226c RW  0x1000
  
  Section to Segment mapping:
    Segment Sections...
     00     .riscv.attributes
     01     .text .rodata .srodata.mainargs
     02     .data .data.code .sdata.first_trap .sdata.heap .data.lut .sdata.next .bss
  ```
  
  - 第一个`LOAD`的程序段从`.text`段开始，以及后面的`.rodata`和`.srodata.mainargs`
  
- 符号表`.symtab`中

  - `_start`和`.text`地址为`80000000`
  - `.rodata`、`_etext`和`etext`地址为`80001f70`，恰好是`.text`的结束地址
  - `.data`地址为`80002d88`，`edata`和`_data`地址为`80010b94`，也是`.data`的结束地址
  - `_bss_start`地址为`80010db4`，是`.bss`段的开始地址
  - `end`和`_end`的地址为`8009d000`

至此，`linker.d`的行为就分析完了。

## 11.18

## man手册页数的含义

### 手册页章节解释：

| 数字  | 章节内容                                 | 示例                                |
| ----- | ---------------------------------------- | ----------------------------------- |
| **1** | 用户可执行的命令或程序                   | `man ls` 查找 `ls` 命令的用法       |
| **2** | 系统调用（由内核提供的函数）             | `man open` 查看 `open` 系统调用     |
| **3** | 库函数（由 C 库提供的函数）              | `man printf` 查看 `printf` 函数     |
| **4** | 特殊文件（通常是设备文件）和驱动         | `man tty` 查看设备文件说明          |
| **5** | 配置文件和文件格式                       | `man passwd` 查看 `passwd` 文件格式 |
| **6** | 游戏及娱乐相关的程序                     | `man fortune` 查看 `fortune` 游戏   |
| **7** | 杂项（包括宏包、约定和标准等）           | `man 7 signal` 查看信号相关文档     |
| **8** | 系统管理命令（通常需要超级用户权限执行） | `man ifconfig` 查看网络配置命令     |
| **9** | 内核开发相关的例程                       | `man 9 printk` 查看 `printk` 函数   |

## 11.19

记录下自己debug遇到的问题。

现在情况是，在nanos中执行编译Navy中的程序后，将加载进程的名称改为`/bin/file-test`

```C
naive_uload(NULL, "/bin/file-test");
```

此时程序正确加载，并且成功结束，但是尚未输出`PASS!!!`的信息。以下是执行`file-test`后的输出结果：

```bash
Welcome to riscv32-NEMU!
For help, type "help"
(nemu) c
[/home/crx/study/ics2023/nanos-lite/src/main.c,13,main] 'Hello World!' from Nanos-lite
[/home/crx/study/ics2023/nanos-lite/src/main.c,14,main] Build time: 18:22:04, Nov 14 2024
[/home/crx/study/ics2023/nanos-lite/src/mm.c,26,init_mm] free physical pages starting from 800d4000
[/home/crx/study/ics2023/nanos-lite/src/device.c,34,init_device] Initializing devices...
[/home/crx/study/ics2023/nanos-lite/src/ramdisk.c,24,init_ramdisk] ramdisk info: start = 80002061, end = 800c2261, size = 786944 bytes
[/home/crx/study/ics2023/nanos-lite/src/irq.c,15,init_irq] Initializing interrupt/exception handler...
[/home/crx/study/ics2023/nanos-lite/src/proc.c,25,init_proc] Initializing processes...
[/home/crx/study/ics2023/nanos-lite/src/loader.c,35,naive_uload] Jump to entry = 83007d70
[/home/crx/study/ics2023/nanos-lite/src/syscall.c,5,strace] strace: Syscall num: 9, param(a0, a1, a2) = (0x000001c0, 0x00000000, 0x00000000)
[/home/crx/study/ics2023/nanos-lite/src/syscall.c,5,strace] strace: Syscall num: 9, param(a0, a1, a2) = (0x000003f0, 0x00000000, 0x00000000)
[/home/crx/study/ics2023/nanos-lite/src/syscall.c,5,strace] strace: Syscall num: 0, param(a0, a1, a2) = (0x00000002, 0x00000000, 0x00000000)
[src/cpu/cpu-exec.c:182 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80000ad0
```

首先怀疑：

-  是否现在printf已经调用`write(FD_STDOUT, buf, len)`进行输出了？

  现在是没有的，可以看`strace`的调用记录，其中`write`的系统调用编号为4，但是里面只有两次`sbrk()`的系统调用。
  

但是对于`printf`的调用，确实是依靠`sbrk`和`write`的系统调用进行处理的。我们看看`hello`程序中调用`printf`的时候，两个系统调用的合作。

现在切换进程为`hello`，编译运行

```bash
For help, type "help"
(nemu) c
[/home/crx/study/ics2023/nanos-lite/src/main.c,13,main] 'Hello World!' from Nanos-lite
[/home/crx/study/ics2023/nanos-lite/src/main.c,14,main] Build time: 18:22:04, Nov 14 2024
[/home/crx/study/ics2023/nanos-lite/src/mm.c,26,init_mm] free physical pages starting from 800d4000
[/home/crx/study/ics2023/nanos-lite/src/device.c,34,init_device] Initializing devices...
[/home/crx/study/ics2023/nanos-lite/src/ramdisk.c,24,init_ramdisk] ramdisk info: start = 80002061, end = 800c2261, size = 786944 bytes
[/home/crx/study/ics2023/nanos-lite/src/irq.c,15,init_irq] Initializing interrupt/exception handler...
[/home/crx/study/ics2023/nanos-lite/src/proc.c,25,init_proc] Initializing processes...
[/home/crx/study/ics2023/nanos-lite/src/loader.c,35,naive_uload] Jump to entry = 83004d5c
[/home/crx/study/ics2023/nanos-lite/src/syscall.c,5,strace] strace: Syscall num: 4, param(a0, a1, a2) = (0x00000001, 0x83005640, 0x0000000d)
Hello World!
[/home/crx/study/ics2023/nanos-lite/src/syscall.c,5,strace] strace: Syscall num: 9, param(a0, a1, a2) = (0x00000418, 0x00000000, 0x00000000)
[/home/crx/study/ics2023/nanos-lite/src/syscall.c,5,strace] strace: Syscall num: 9, param(a0, a1, a2) = (0x00000310, 0x00000000, 0x00000000)
[/home/crx/study/ics2023/nanos-lite/src/syscall.c,5,strace] strace: Syscall num: 4, param(a0, a1, a2) = (0x00000001, 0x830068e0, 0x0000002d)
Hello World from Navy-apps for the 2th time!
[/home/crx/study/ics2023/nanos-lite/src/syscall.c,5,strace] strace: Syscall num: 4, param(a0, a1, a2) = (0x00000001, 0x830068e0, 0x0000002d)
Hello World from Navy-apps for the 3th time!
[/home/crx/study/ics2023/nanos-lite/src/syscall.c,5,strace] strace: Syscall num: 4, param(a0, a1, a2) = (0x00000001, 0x830068e0, 0x0000002d)
```

嗯？`printf`第一个输出的为什么是从下标2开始的？下标1去哪里了？看`hello.c`代码

```C
  int i = 2;
  volatile int j = 0;
  while (1) {
    j ++;
    if (j == 10000) {
      printf("Hello World from Navy-apps for the %dth time!\n", i ++);
      j = 0;
    }
  }
```

很明显下标就是从2开始的。

那么问题是，`printf()`进行字符串格式化之后, 最终会通过`write()`系统调用进行输出。那么`printf`的实现流程是什么？为什么在调用`write`输出字符之前，先调用了两次`sbrk()`？

```bash
strace: Syscall num: 9, param(a0, a1, a2) = (0x00000418, 0x00000000, 0x00000000)
strace: Syscall num: 9, param(a0, a1, a2) = (0x00000310, 0x00000000, 0x00000000)
strace: Syscall num: 4, param(a0, a1, a2) = (0x00000001, 0x830068e0, 0x0000002d)
Hello World from Navy-apps for the 2th time!
```

看[文档](https://nju-projectn.github.io/ics-pa-gitbook/ics2023/3.3.html#%E5%A0%86%E5%8C%BA%E7%AE%A1%E7%90%86)寻找答案。

`printf`在输出字符串的时候，会先通过`malloc()`申请一片缓冲区，用来存放格式化内容。如果申请失败，则会逐个字符进行输出。

`malloc()`进行堆区的使用情况管理，而堆区的大小需要库函数`sbrk()`通过系统调用向操作系统提出更改。

而在Navy的Newlib（库函数）中, `sbrk()`最终会调用`_sbrk()`, 它在`navy-apps/libs/libos/src/syscall.c`中定义. 

按照文档，将`sbrk()`的系统调用函数改为

```C
// 声明链接器符号 _end，表示初始堆结束位置
extern char _end;

void *_sbrk(intptr_t increment) {
  // 静态变量记录当前的 program break
  static char *current_break = &_end;

  // 计算新的 program break
  char *new_break = current_break + increment;

  // 调用 SYS_brk，尝试设置新的 program break
  int result = _syscall_(SYS_brk,  (intptr_t)new_break, 0, 0);

  // 检查返回值
  if (result == 0) {
    void *old_break = current_break; // 记录旧的 program break
    current_break = new_break;      // 更新当前的 program break
    return old_break;               // 返回旧的 program break
  }

  // 如果失败，返回 (void *)-1
  return (void *)-1;
}
```

但是依然没有输出结果。这时候怀疑代码已经`assert`，但是没有正确的退出标志。修改`nanos-lite/src/syscall.c`的`sys_exit`系统调用

```C
void sys_exit(Context *c) {
  halt(c->GPR2);
}
```

再次编译运行，发现此时确实可以捕捉到异常退出标志了，但是没有输出异常信息。此时查看`assert`的代码实现

```c
# define assert(__e) ((__e) ? (void)0 : __assert_func (__FILE__, __LINE__, \
						       __ASSERT_FUNC, #__e))
```

如果表达式`__e`不成立，则会调用`__assert_func`处理表达式。查看其具体实现：

```C
/* func can be NULL, in which case no function information is given.  */
void
__assert_func (const char *file,
	int line,
	const char *func,
	const char *failedexpr)
{
  fiprintf(stderr,
	   "assertion \"%s\" failed: file \"%s\", line %d%s%s\n",
	   failedexpr, file, line,
	   func ? ", function: " : "", func ? func : "");
  abort();
  /* NOTREACHED */
}
```

首先调用`fiprintf`对异常信息进行处理，然后再执行`abort`。

再看`fiprintf`函数的实现

```c
int
fiprintf (FILE *, const char *, ...)
       _ATTRIBUTE ((__alias__("fprintf")));
```

通过 GCC 的 `__alias__` 属性将函数 `fiprintf` 定义为 `fprintf` 的别名。定义了一个函数 `fiprintf`，其行为与标准库函数 `fprintf` 完全相同。

```C
int
_fprintf_r (struct _reent *ptr,
       FILE *__restrict fp,
       const char *__restrict fmt, ...)
{
  int ret;
  va_list ap;

  va_start (ap, fmt);
  ret = _vfprintf_r (ptr, fp, fmt, ap);
  va_end (ap);
  return ret;
}
```

## 11.21

记录下自己debugAM的`printf`记录。

放下出错`printf`代码实现

```C
int process_format_string(char *out, const char *fmt, va_list args) {
	char *out_ptr = out;
	const char *fmt_ptr = fmt;

	while (*fmt_ptr != '\0') {
		if (*fmt_ptr == '%') {
			fmt_ptr++; // Move to the format specifier

			if (*fmt_ptr == 'd') {
				int i = va_arg(args, int);
				char num_str[20];
				int_to_str(i, num_str);	// Convert integer to string
				strcpy(out_ptr, num_str);	// Copy the number string to buffer
				out_ptr += strlen(num_str);
			}
			else if (*fmt_ptr == 's') {
				char *s = va_arg(args, char *);
				strcpy(out_ptr, s);
				out_ptr += strlen(s);
			}
      else if (*fmt_ptr == 'x' || *fmt_ptr == 'p') {
        // Handle hexadecimal format (%x)
        int i = va_arg(args, int);  
        char hex_str[30];
        int_to_hex(i, hex_str); // Convert integer to hexadecimal string
        strcpy(out_ptr, hex_str); // Copy the hex string to buffer
        out_ptr += strlen(hex_str);
      }
		} else {
			*out_ptr++ = *fmt_ptr; // Copy other characters
		}
		fmt_ptr++;	// Move to the next character in format
	}
	*out_ptr = '\0';	// Null-terminate the buffer
	va_end(args);

	return out_ptr - out;	// Return the length of the string
}

int printf(const char *fmt, ...) {
	char buf[MAX_STRING_LEN];
	va_list args;
	va_start(args, fmt);

  panic_on((strlen(fmt) > MAX_STRING_LEN), "Too lang for printf");//废话，不可能超长的
	int len = process_format_string(buf, fmt, args);

	for (int i = 0; i < len; i++) {
		putch(buf[i]);
	}
	
	return len;
}
```

现在遇到了一个问题：输出字符数量为1400+的`nanos-log`会直接宕机，而最重要的是，我根本不知道哪里出了问题。我只知道，输出完毕logo后，就报错了。

```C
int main() {
  extern const char logo[];
  printf("%s", logo);
  Log("'Hello World!' from Nanos-lite");
  Log("Build time: %s, %s", __TIME__, __DATE__);

  init_mm();

  init_device();

  init_ramdisk();
   //...
  }
```

logo定义。

```tex
######################%'``|######################$
###################$` ..`.  '&###################$
#################$` .`::::'`  '&#################$
###############$` .`::;!;::::`. '&###############$
#############$` .`:::::|$%;::::`  '&#############$
###########$` .'::::::!%$$$%;::::`. '&###########$
#########$` .'::::::!%$$$$$%;::::::`  '&#########$
#######$` .'::::::!%$%|$$$$%;::::::::`. '&#######$
#####$` .'::::::!%$%;:|$$$$|;::::::::::`  '&#####$
###$` .';;;;;;!%$%;;;;|$$$$|;::::;|%!::::`. '&###$
#&' .';;;%%!!%$%;;;;;;%$$$$|;;;;;;;|$%!;:::`. '@#$
%.  ';;;;;|$$%!;;;;;;!%$$$$!;;;;;!%$%%$%!;;:`  '&$
|    `;;;;;;|$%!;;;;;!$$$$%!;;;!%$%!;;;;;;:`   .%$
@:  ;!``;;;;;;;;;;;;;|$$$$%!;!%$%!;;;;;;:`'!'  :@$
;   '%$!``;;;;;;;;;;;|$$$$%!%$%!;;;;;;:`'|$|`   |$
|    .:%$!`';;;;;;;;!%$$$$$$%!;;;;;;:`'|$|'    .%$
#$`    .:%$|`';;;;;;!%$$$$%!;;;;;;:`'|$|'     ;##$
###$`    .:%$|`';;;;;!%$%|!;;;;;;`'%$|'     ;####$
#####$`    .:%$|`';!!!!!!!!!!!;`'%$%'     ;######$
#######$`    .:$$|`';!!!!!!!;`'%$%'     ;########$
#########$`    .:$$|`';!!!;`'%$%'     ;##########$
###########$`    .:$&|`.`.'%&%'     ;@###########$
#############$`    .:$&$$&&%'     ;##############$
###############$`    .:$&%'     ;@###############$
#################$`           ;##################$

                  **Project-N**
 Nanjing Universi	ty Computer System Project Series
       Build a computer system from scratch!
```

痛定思痛，决定从汇编代码的角度去分析，当调用`printf`的时候，到底哪里出了问题。现在放下反汇编代码.

首先是main.c部分的汇编代码

```assembly
80000e28 <main>:
80000e28:	ff010113          	addi	sp,sp,-16
80000e2c:	00002597          	auipc	a1,0x2
80000e30:	ac858593          	addi	a1,a1,-1336 # 800028f4 <logo>
80000e34:	00002517          	auipc	a0,0x2
80000e38:	04050513          	addi	a0,a0,64 # 80002e74 <logo+0x580>
80000e3c:	00112623          	sw	ra,12(sp)
80000e40:	00812423          	sw	s0,8(sp)
80000e44:	07d000ef          	jal	ra,800016c0 <printf>
#下面的代码没有执行到就报错了
```

经过断点调试，断点到调用第一个`printf`输出logo的时候就报错了。这样缩小了找错范围，仅需要看`[80000e28, 80000e44]`部分的代码即可。

说来惭愧，riscv32的汇编指令到现在还是不熟悉。整理下用到的汇编指令：

- `auipc rd, immediate `：x[rd] = pc + sext(immediate[31:12] << 12)。将当前PC加高位立即数

- `sw rs2, offset(rs1)`  ：存字（store word）

  ```bash
  M[x[rs1] + sext(offset) ]= x[rs2](31:0)
  ```

- `jal rd, offset` ：将下一条指令的地址（PC+4）存储在目的寄存器`rd`，然后把PC设置为当前值加上符号位拓展的`offset`

  ```C
  x[rd] = pc+4; pc += sext(offset)
  ```

- ``addi rd, rs1, immediate` ： x[rd] = x[rs1] + sext(immediate)。加立即数

- `mv rd,rs1` ：将 x[rs1] 复制到 x[rd] 中。x[rd]=x[rs1] <==> `addi rd, rs1, 0` 

- `li rd, immediate`：装入立即数。x[rd] = immediate

- `jalr rd, offset(rs1)`：将 pc 设为 x[rs1] + sign-extend(offset),将跳转地址的最低位清零,并将原 pc+4 写入 x[rd]。(Jump and Link Register)
  
  ```c
  t=pc+4; pc=(x[rs1]+sext(offset))&∼1; x[rd]=t
  ```
  
- `lbu rd, offset(rs1)`：从地址 x[rs1] + sign-extend(offset) 读取 1 字节,零扩展后写入 x[rd]。(Load Byte, Unsigned)

  ```bash
  x[rd] = M[x[rs1] + sext(offset)][7:0]
  ```

这样结合`main.c`的c代码和汇编代码分析：

```assembly
80000e28: addi	sp,sp,-16   # 为sp开辟16字节栈空间
          
80000e2c: auipc	a1,0x2      # a1 = 0x80002e2c = 0x80000e2c + 0x2000(0x2 << 12)
          
80000e30: addi	a1,a1,-1336 # 800028f4 <logo>   a1 = 0x80002e2c -1336 = 800028f4
                             # 赋值a1为存放logo的起始地址800028f4
                             
80000e34: auipc	a0,0x2      # a0 = 80002e34
80000e38: addi	a0,a0,64    # a0存储存放 `%s` 的地址80002e74 <logo+0x580> (80002e34 + 0x40)-
80000e3c: sw	ra,12(sp)     # 将ra的值保存到sp+12地址处
80000e40: sw	s0,8(sp)      # 将s0的值保存到sp+ 8地址处
80000e44: jal	ra,800016c0 <printf>  #ra保存80000e48，PC跳转到printf函数处
```

在调用`printf`函数输出logo之前，`a1`寄存器保存了logo的起始地址，`a0`存放了格式化字符串`%s`。随后视角到`printf`函数内部

```assembly
800016c0 <printf>:            
# 输出logo：
# a1:logo存放地址， 
# a0:`%s`的存放地址
# 初始ra = 0x80000e48

800016c0:	addi	sp,sp,-1088
800016c4:	sw	a5,1076(sp)
800016c8:	addi	a5,sp,1060
800016cc:	sw	s0,1048(sp)
800016d0:	sw	a5,12(sp)
800016d4:	sw	ra,1052(sp)		# 将0x80000e48存储在1052(sp)--800A7FBC	
800016d8:	sw	s1,1044(sp)
800016dc:	sw	s2,1040(sp)
800016e0:	mv	s0,a0
800016e4:	sw	a1,1060(sp)
800016e8:	sw	a2,1064(sp)
800016ec:	sw	a3,1068(sp)
800016f0:	sw	a4,1072(sp)
800016f4:	sw	a6,1080(sp)
800016f8:	sw	a7,1084(sp)
800016fc:	jal	ra,80001c48 <strlen>	# 并未修改800A7FBC处的ra数据
80001700:	li	a5,1024
80001704:	bltu	a5,a0,80001754 <printf+0x94>
80001708:	lw	a2,12(sp)
8000170c:	mv	a1,s0
80001710:	addi	a0,sp,16
80001714:	jal	ra,80001588 <process_format_string>	# 可能修改了 1052(sp)的数据
80001718:	mv	s2,a0
8000171c:	blez	a0,80001738 <printf+0x78>
80001720:	addi	s0,sp,16
80001724:	add	s1,s0,a0
80001728:	lbu	a0,0(s0)
8000172c:	addi	s0,s0,1
80001730:	jal	ra,80000ef4 <putch>
80001734:	bne	s1,s0,80001728 <printf+0x68>
80001738:	lw	ra,1052(sp)	# 从1052(sp)	取出0x80000e48
8000173c:	lw	s0,1048(sp)
80001740:	lw	s1,1044(sp)
80001744:	mv	a0,s2
80001748:	lw	s2,1040(sp)
8000174c:	addi	sp,sp,1088
80001750:	ret
```

代码过长了，我们继续断点到`process_format_string`的下一条指令地址`80001718`，看看是否在执行`process_format_string`的时候报错了。

很可惜，执行`process_format_string`的时候并没有报错。最有趣的是，当我把断点设置在`80001750`的时候，sdb输出

```bash
(nemu) w $pc==0x80001750
watchpoint 3: $pc==0x80001750
(nemu) c
##################%'``|######################$
###################$` ..`.  '&###################$
#################$` .`::::'`  '&#################$
###############$` .`::;!;::::`. '&###############$
#############$` .`:::::|$%;::::`  '&#############$
###########$` .'::::::!%$$$%;::::`. '&###########$
#########$` .'::::::!%$$$$$%;::::::`  '&#########$
#######$` .'::::::!%$%|$$$$%;::::::::`. '&#######$
#####$` .'::::::!%$%;:|$$$$|;::::::::::`  '&#####$
###$` .';;;;;;!%$%;;;;|$$$$|;::::;|%!::::`. '&###$
#&' .';;;%%!!%$%;;;;;;%$$$$|;;;;;;;|$%!;:::`. '@#$
%.  ';;;;;|$$%!;;;;;;!%$$$$!;;;;;!%$%%$%!;;:`  '&$
|    `;;;;;;|$%!;;;;;!$$$$%!;;;!%$%!;;;;;;:`   .%$
@:  ;!``;;;;;;;;;;;;;|$$$$%!;!%$%!;;;;;;:`'!'  :@$
;   '%$!``;;;;;;;;;;;|$$$$%!%$%!;;;;;;:`'|$|`   |$
|    .:%$!`';;;;;;;;!%$$$$$$%!;;;;;;:`'|$|'    .%$
#$`    .:%$|`';;;;;;!%$$$$%!;;;;;;:`'|$|'     ;##$
###$`    .:%$|`';;;;;!%$%|!;;;;;;`'%$|'     ;####$
#####$`    .:%$|`';!!!!!!!!!!!;`'%$%'     ;######$
#######$`    .:$$|`';!!!!!!!;`'%$%'     ;########$
#########$`    .:$$|`';!!!;`'%$%'     ;##########$
###########$`    .:$&|`.`.'%&%'     ;@###########$
#############$`    .:$&$$&&%'     ;##############$
###############$`    .:$&%'     ;@###############$
#################$`           ;##################$

                  **Project-N**
 Nanjing University Computer System Project Series
       Build a computer system from scratch!
watchpoint 3: $pc==0x80001750

Old value = 0x00000000
New value = 0x00000001
0x8000174c: 44 01 01 13 addi    sp, sp, 1088

```

这代表数据已经完整被输出出来了，但是为什么还是报错了呢？

此时继续单步执行

```assembly
80001750: ret #jalr    zero, 0(ra) pc = x[ra]
```

但是奇怪的是，这时候`ra`的值为`0x7c24243a`，已经不是之前调用`printf`的那个`ra`值`80000e48`了。

那我们断点看看`ra`在调用`printf`开始，到`printf`调用`process_format_string`之前，`ra`有无变化。首先是`0x800016fc`地址处，调用`strlen`的时候更改了`ra`为返回地址`0x80001700`

```assembly
0x800016fc: jal	ra,80001c48 <strlen>
```

这次正常执行，我们继续的时候，此时就会输出logo信息并报错了。那么`ra`的值怎么被修改的呢？

调用任何函数之前，都会使用到`ra`寄存器。因为`ra`寄存器，是riscv32钦定的返回地址保存寄存器。

我们看下在`printf`函数中，对于`ra`的操作。

所以在`0x800016d4`处，`printf`为了保护返回地址`ra`的值，将其保存到了`1052(sp)`栈空间处

```assembly
800016d4:	sw	ra,1052(sp)		# 将0x80000e48存储在1052(sp)--0x800a7fbc	
```

随后调用`strlen`和`process_format_string`，最终调用完毕`putch`后，又从`1052(sp)`处将`ra`的值从栈中取出来，保存到`ra`中

```assembly
80001738:	lw	ra,1052(sp)	# 从1052(sp)	取出0x80000e48
```

很明显，经过内部函数的处理后，栈空间应该是被损坏了。那么在哪里被损坏的呢？

> Q这时候遇到很奇怪的问题：
>
> 在`printf`保存`ra`的时候打上断点，查看此时`sp`的值为`0x800a7ba0`，加上`1052(0x41c)`，存储`ra`的栈地址为`0x800A7FBC`。然后就在查看地址`800A7FBC`处的数据时候，乱码了：
>
> ```
> (nemu) si
> 0x800016d4: 40 11 2e 23 sw      ra, 1052(sp)
> watchpoint 0: $pc==0x800016d4
> 
> Old value = 0x00000001
> New value = 0x00000000
> 0x800016d4: 40 11 2e 23 sw      ra, 1052(sp)
> (nemu) x 10 800A7FBC
> 0x800a7fbc: 48 (H) 0e () ▮▮ () 8▮ ()
> ▮│8▮▮▒7°␌▮: ▮▮ () ▮▮ () ▮▮ () ▮▮ ()
> ▮│8▮▮▒7°␌4: ▮▮ () ▮▮ () ▮▮ () ▮▮ ()
> ▮│8▮▮▒7°␌8: ▮▮ () ▮▮ () ▮▮ () ▮▮ ()
> ▮│8▮▮▒7°␌␌: ▮▮ () ▮▮ () ▮▮ () ▮▮ ()
> ▮│8▮▮▒7°␍▮: ▮▮ () ▮▮ () ▮▮ () ▮▮ ()
> ▮│8▮▮▒7°␍4: ▮▮ () ▮▮ () ▮▮ () ▮▮ ()
> ▮│8▮▮▒7°␍8: ▮▮ () ▮▮ () ▮▮ () ▮▮ ()
> ▮│8▮▮▒7°␍␌: ▮▮ () ▮▮ () ▮▮ () ▮▮ ()
> ▮│8▮▮▒7°␊▮: ▮▮ () ▮▮ () ▮▮ () ▮▮ ()
> (┼␊└┤) A7FBC
> U┼┐┼⎺┬┼ ␌⎺└└▒┼␍ 'A7FBC'
> (┼␊└┤)
> (┼␊└┤)
> (┼␊└┤)
> (┼␊└┤)
> (┼␊└┤)
> (┼␊└┤)
> (┼␊└┤) ─
> └▒┐␊[1]: L␊▒┴␋┼± ␍␋⎼␊␌├⎺⎼≤ '/
> ⎺└␊/␌⎼│/⎽├┤␍≤/␋␌⎽2▮23/┼␊└┤'
> ␌⎼│@┤␉┤┼├┤:┼▒┼⎺⎽↑┌␋├␊$
> ␌⎼│@┤␉┤┼├┤:┼▒┼⎺⎽↑┌␋├␊$
> ␌⎼│@┤␉┤┼├┤:┼▒┼⎺⎽↑┌␋├␊$
> ␌⎼│@┤␉┤┼├┤:┼▒┼⎺⎽↑┌␋├␊$ ─
> C⎺└└▒┼␍ '─' ┼⎺├ °⎺┤┼␍← ␉┤├ ␌▒┼ ␉␊ ␋┼⎽├▒┌┌␊␍ ┬␋├
> :
> ⎽┤␍⎺ ⎽┼▒⎻ ␋┼⎽├▒┌┌ ─                       # ┴␊⎼⎽␋⎺┼ 1↓6↓3↑1← ⎺⎼
> ⎽┤␍⎺ ▒⎻├  ␋┼⎽├▒┌┌ ⎻≤├
> ⎺┼3↑─↑├␊│├↑▒⎽↑␍▒├▒  # ┴␊⎼⎽␋⎺┼ 3↓1↓6↑1
> S␊␊ '⎽┼▒⎻ ␋┼°⎺ ─' °⎺⎼ ▒␍␍␋├␋⎺┼▒┌ ┴␊⎼⎽␋⎺┼⎽↓
> ␌⎼│@┤␉┤┼├┤:┼▒┼⎺⎽↑┌␋├␊$
> ␌⎼│@┤␉┤┼├┤:┼▒┼⎺⎽↑┌␋├␊$ ─
> C⎺└└▒┼␍ '─' ┼⎺├ °⎺┤┼␍← ␉┤├ ␌▒┼ ␉␊ ␋┼⎽├▒┌┌␊␍ ┬␋├
> :
> ⎽┤␍⎺ ⎽┼▒⎻ ␋┼⎽├▒┌┌ ─                       # ┴␊⎼⎽␋⎺┼ 1↓6↓3↑1← ⎺⎼
> ⎽┤␍⎺ ▒⎻├  ␋┼⎽├▒┌┌ ⎻≤├
> ⎺┼3↑─↑├␊│├↑▒⎽↑␍▒├▒  # ┴␊⎼⎽␋⎺┼ 3↓1↓6↑1
> S␊␊ '⎽┼▒⎻ ␋┼°⎺ ─' °⎺⎼ ▒␍␍␋├␋⎺┼▒┌ ┴␊⎼⎽␋⎺┼⎽↓
> ␌⎼│@┤␉┤┼├┤:┼▒┼⎺⎽↑┌␋├␊$
> ␌⎼│@┤␉┤┼├┤:┼▒┼⎺⎽↑┌␋├␊$
> ```
>
> 比较遗憾的是，重新debug的时候，又没有这个乱码的问题了
>

```bash
(nemu) x 10 800A7FBC
0x800a7fbc: 48 (H) 0e () 00 () 80 ()
```

可以看到在地址`0x800a7fbc`的数据为`0x80000e48`。我们需要找到破坏栈的元凶。

首先看下调用完毕`strlen`的时候，栈空间是否破坏

```bash
watchpoint 0: $pc==0x80001700

Old value = 0x00000000
New value = 0x00000001
0x80001c68: 00 00 80 67 jalr    zero, 0(ra)
(nemu) x 1 800A7FBC
0x800a7fbc: 48 (H) 0e () 00 () 80 ()
```

可以看出`strlen`并没有损坏栈空间。

断点在调用完毕`process_format_string`的时候(`0x80001718`)，查看栈空间是否被破坏

```bash
(nemu) w $pc==0x80001718
watchpoint 0: $pc==0x80001718
(nemu) c
watchpoint 0: $pc==0x80001718

Old value = 0x00000000
New value = 0x00000001
0x80001678: 00 00 80 67 jalr    zero, 0(ra)
(nemu) p $pc
result = 2147489560(0x80001718)
(nemu) x 10 800A7FBC
0x800a7fbc: 3a (:) 24 ($) 24 ($) 7c (|)
```

很明显，就是调用函数`process_format_string`的时候，将栈空间破坏了。那么下面分析为什么`process_format_string`破坏掉栈呢？

函数`process_format_string`中，处理`%s`的逻辑为

```C
else if (*fmt_ptr == 's') {
	char *s = va_arg(args, char *);
	strcpy(out_ptr, s);
	out_ptr += strlen(s);
  }
```

我们看下`strcpy`的汇编代码

```assembly
80001c70 <strcpy>:
#	a1为存放logo的起始地址800028f4
#   a0 = 0x800a7bb0，
#   sp = 0x800a7b50
#   此时存放ra的栈地址为 0x800a7fbc


# 从a5 = logo[0]开始遍历
80001c70: 	lbu	a5,0(a1) # ffff0000 <_end+0x7ff48000>

# 如果a5等于‘\0’，则跳转到ret
80001c74: 	beqz	a5,80001c94 <strcpy+0x24>

# 将0x800a7bb0的值存储在a4
80001c78: 	mv	a4,a0

# a1 = logo+1
80001c7c: 	addi	a1,a1,1

# 将logo[1]存储到0x800a7bb0
80001c80: 	sb	a5,0(a4)

# a5 = logo[1]
80001c84: 	lbu	a5,0(a1)

# a4 = 0x800a7bb1
    80001c88: 	addi	a4,a4,1

# a1 = logo+2
80001c8c: 	addi	a1,a1,1

# if a5 != '\0' 继续下一波存储
80001c90: 	bnez	a5,80001c80 <strcpy+0x10>
80001c94: 	ret
```

可以发现，在`strcpy`中，我们将`0x800a7bb0`作为字符保存的开始地址。随着要保存的字符越来越多，这个地址会向着堆开始的区域不断生长，最终会写出`_heap_start`所限制的`0x800a8000`.

随着复制logo，在栈中存放字符的`0x800a7bb0`地址会不断增加。而此时栈顶`sp`位置为`0x800a7b50`。随着字符长度的不断加长，最终会覆盖掉`0x800a7fbc`存放`ra`跳转的地址。

看AM如何分配堆空间的：

```C
extern char _pmem_start;	// _pmem_start=0x80000000
#define PMEM_SIZE (128 * 1024 * 1024)	// 0x8000000
#define PMEM_END  ((uintptr_t)&_pmem_start + PMEM_SIZE) // 0x88000000
#define RANGE(st, ed)       (Area) { .start = (void *)(st), .end = (void *)(ed) }

// start = 0x800a8000, end = 0x88000000
Area heap = RANGE(&_heap_start, PMEM_END);
```

# 栈空间

 P calls Q

![image-20241121184612002](E:\backup\software\typora_image\image-20241121184612002.png)



这里补充下，对于栈的操作。常见的栈空间分布如上。

**栈的空间是从高地址向低地址增长的**。也就是说，栈顶（`SP` 指针）最初被初始化为高地址，随着函数调用和局部变量分配，栈空间会逐渐向低地址方向扩展。

```C
+------------------------+  <- 高地址
|       栈 (Stack)       |
|------------------------|
|       空闲空间         |
|------------------------|
|       堆 (Heap)        |
|------------------------|
| 全局/静态变量 (.data/.bss) |
|------------------------|
|       代码 (.text)     |
+------------------------+  <- 低地址

```

- 堆从低地址向高地址增长。

- 栈从高地址向低地址增长。

上面的分析中，`ra`寄存器的值存放在地址`0x800a7fbc`处，是内存的高地址。

而`strcpy`将临时数据存放在`0x800a7bb1`处，是内存的低地址处，且向高地址增长。

所以当临时数据过多时，就会将高地址处的数据覆盖掉。

我们可以考虑扩展AM的栈空间：

```C
extern char _pmem_start;	// _pmem_start=0x8000 0000
#define PMEM_SIZE (128 * 1024 * 1024)	// 0x8000000
#define PMEM_END  ((uintptr_t)&_pmem_start + PMEM_SIZE) // 0x88000000
#define RANGE(st, ed)       (Area) { .start = (void *)(st), .end = (void *)(ed) }

// start = &_heap_start = 0x800a8000, end = 0x88000000
Area heap = RANGE(&_heap_start, PMEM_END);
```

## 11.22

阅读《程序员的自我修养-链接、装载与库》的第十章：内存

- 栈保存了一个函数调用所需要维护的信息，这个维护信息也被称为stack frame和activite record。
- 函数调用维护的信息有：
  - 函数的返回地址和参数
  - 临时变量
  - 保存的上下文：包括在函数调用前后需要保持不变的寄存器
- 调用惯例：
  - 函数参数的传递顺序和方式
  - 栈的维护方式
- `_attribute_()`
- C语言默认调用惯例
  - 从右到左顺序参数入栈
  - 出栈方：函数调用方
  - 名字修饰：直接在函数名称前加一个下划线（foo被修饰后变为_foo）
- 栈上的数据在函数返回的时候就会被释放，所以无法将数据传递至函数外部

# AM程序的栈空间

上面的“`printf`输出超长（不到2000个字节）的字符串会导致栈溢出”的问题已经解决了，解决方案如下：

- 将链接脚本的栈指针位置设置为`. = _stack_top + 0xb000;`
- 将`printf`的最大字符串容量`MAX_STRING_LEN`改为10240

虽然解决了问题，但是有个问题想不明白：

- 当我只设置`MAX_STRING_LEN`的值能容纳超长字符串的数量的时候，这时候栈指针位置不变化的话`0x8000`，仍会导致栈溢
- 同理，只修改栈指针位置的话，也会溢出

所以今天就想弄明白，`printf`是怎么分配栈空间和堆空间来处理字符的？链接脚本`link.ld`和初始的`start.S`是否影响了栈的分配？怎么影响的栈空间分配呢？

## 11.25

早晨开始做文件系统的时候，关于堆的一些新发现

AM程序的堆空间是通过`abstract-machine/am/src/platform/nemu/trm.c`定义的

```C
Area heap = RANGE(&_heap_start, PMEM_END);
```

- `_heap_start`：映射到内存字段的末尾

- `PMEM_END`：物理内存的末尾。

  ```C
  #define PMEM_SIZE (128 * 1024 * 1024)
  #define PMEM_END  ((uintptr_t)&_pmem_start + PMEM_SIZE)
  ```

现在查看下nanos-lite的目标文件，`_heap_start`的值为`800ab000`，而`_pmem_start`的值为`80000000`，所以综上`heap`的空间为

```C
RANGE(0x800a,b000, 0x8800,0000)
```

啊？这么大的空间，怎么在`strcpy`的时候，还是用到了很小部分的堆空间呢？疑问

今日尝试：

- 提炼PA3中，如何让`navy-apps/tests/bmp-test`在屏幕上显示Project-N的logo？
- `am-tests`中的`display test`是如何输出相应的动画效果的？
- 休闲小说《人鼠之间》

如何让`navy-apps/tests/bmp-test`在屏幕上显示Project-N的logo？

## VGA文件

程序绘图时候的坐标都是针对画布设定的。画布的相关操作为

```c
// 打开一张(*w) X (*h)的画布
// 如果*w和*h均为0, 则将系统全屏幕作为画布, 并将*w和*h分别设为系统屏幕的大小
void NDL_OpenCanvas(int *w, int *h);
```

不过要想打开画布，首先需要读出屏幕大小的信息，这个信息由操作系统的`/proc/dispinfo`文件来获取，需要支持读操作。内容格式为` [key] : [value]`, 冒号左右可以有任意多(0个或多个)的空白字符(whitespace)

一个合法的 `/proc/dispinfo`文件例子如下:

```tex
WIDTH : 640
HEIGHT:480
```

这样程序通过调用函数`NDL_OpenCanvas`可以申请一块画布，接下来的绘图就可以在上面进行。我们再梳理下这个打开画布的需求：

在操作系统层面：

- 将`/proc/dispinfo`加入到文件记录表
- 实现`dispinfo_read(void *buf, size_t offset, size_t len)`，此函数获取VGA中关于屏幕的信息：宽度和高度。并将此信息转换为key-value的形式，包含的keys: `WIDTH`表示宽度, `HEIGHT`表示高度。最终写入到`buf`中。

在运行库NDL层面：

- 在NDL中新增函数`NDL_GetDisplayInfo()`，此函数会读出`/proc/dispinfo`中保存的屏幕信息，正确地将key-value形式的值解析出来
- 实现`NDL_OpenCanvas()`函数，要求画布大小不能超过屏幕大小

实现需求后，Nanos-lite运行`navy-apps/tests/bmp-test`, 由于目前还没有实现绘图功能, 因此无法输出图像内容, 但你可以先通过`printf()`输出解析出的屏幕大小

下面就是实现绘图功能的步骤：

程序为了更新屏幕, 只需要将像素信息写入VGA的显存即可。操作系统将VGA的显存抽象为文件`/dev/fb`。

这样程序只需要将像素信息写入到`/dev/fb`中，就相当于输出画面了。理解文件`/dev/fb`的关键：

- 行优先存储像素
- 支持写操作和`lseek`

它是只写的设备, 看起来是一个W * H * 4字节的数组, 按行优先存储所有像素的颜色值(32位). 每个像素是`00rrggbb`的形式, 8位颜色. 该设备支持lseek. 屏幕大小从`/proc/dispinfo`文件中获得.

为了实现绘图的功能的需求，我们需要做：

操作系统层面：

- 将VGA的显存抽象为`/dev/fb`文件，加入文件记录表

  ```C
  [FD_FB]     =       {"/dev/fb", 0, 0, 0, invalid_read, fb_write},
  ```

- 在`nanos-lite/src/fs.c`中通过`init_fs()`来初始化显存文件`/dev/fb`的大小

  ```C
  static size_t vmemsz; // 显存大小
  void init_fs() {
    // TODO: initialize the size of /dev/fb
    vmemsz = io_read(AM_GPU_CONFIG).vmemsz;
    assert(vmemsz == 0);
    file_table[FD_FB].size = vmemsz;
  }
  ```

- 在`nanos-lite/src/device.c`中，实现`fb_write()`。此函数用于把`buf`中的`len`字节写到屏幕上`offset`处. 
  - 通过`offset`计算出屏幕的坐标
  - 调用IOE绘图
  - 约定程序每次将图片信息写入显存文件`dev/fb`后，立刻将其中的内容同步到屏幕上

运行库NDL层面：

- 梳理`fb`，画布和绘制区域之间的位置关系。在NDL中实现`NDL_DrawRect()`, 通过往`/dev/fb`中的正确位置写入像素信息来绘制图像. 

其中`fb`、画布以及绘制区域之间的关系为：

- frame buffer是整个VGA的显存空间，包含了所有的显示像素
- 一个画布是frame buffer的子区域，占有`fb`的一个对应区域，用于存储和处理图像的信息
- 绘制区域则是由画布内的位置信息`(x,y)`和大小信息`w * h`确定的

而画布是一个行优先的序列，绘制的二维数据被一维序列化。一个画布中`(w1, h1)`位置的像素，会被存放到一维画布`buf[h1 * W + w1]`的位置。`W`就是二维画布中每一行的像素量。

效果:

让Nanos-lite运行`navy-apps/tests/bmp-test`, 如果实现正确, 你将会看到屏幕上显示Project-N的logo.

# display test

我们将在三个层面来分析：`am-tests`中的`display test`是如何输出相应的动画效果的

## 应用程序

首先在文件`am-kernels/tests/am-tests/src/tests/video.c`中，定义了画布canvas的大小为`32*32`。

```C
static uint32_t canvas[N][N];
```

调用函数`update()`来更新画布的内容，这样就会产生一张新的图片。

更新完画布内容后，就需要将画布的内容，加载到屏幕上。

这里函数`redraw()`的作用就是将画布的像素数据存储到显存中，并且刷新屏幕展示画布内容。![image-20241126095209051](E:\backup\software\typora_image\image-20241126095209051.png)

```C
static uint32_t color_buf[32 * 32];
```

```C
/**
 * @brief 将画布 canvas 中的像素数据按行优先的顺序存储到显存中，并通过 io_write 将其绘制到屏幕上
 * 参数：
 * - canvas[y][x]：表示画布canvas中(y , x)坐标的像素块。y 是行索引，x 是列索引
 * - color_buf：一个缓冲区，它的大小是固定的 32 * 32，用来存储单个块的像素数据
 * 
 * 步骤：
 * 1. 获取屏幕的宽度和高度，并计算每个块的尺寸
 * 2. 遍历 canvas 中的每个像素点，将像素数据填充到 color_buf 中
 * 3. 通过 io_write 将 color_buf 中的像素数据传输到显存，绘制每个块
 * 4. 最后调用同步操作，刷新屏幕。
 * 
 * @date 2024-11-25
 */
void redraw() {
  // 将屏幕分割为 32x32 个小块
  int w = io_read(AM_GPU_CONFIG).width / N;   // 每个小块的宽度为 w
  int h = io_read(AM_GPU_CONFIG).height / N;  // 每个小块的高度为 h
  int block_size = w * h;   // 小块的面积
  assert((uint32_t)block_size <= LENGTH(color_buf));

  int x, y, k;
  // 将画布canvas[32][32] 的像素点，映射到屏幕分割的每个块
  for (y = 0; y < N; y ++) {
    for (x = 0; x < N; x ++) {
      for (k = 0; k < block_size; k ++) {
        color_buf[k] = canvas[y][x];  // 将 canvas[y][x] 的颜色值重复填充到 color_buf 中
      }
      // color_buf保存的是每个屏幕块的像素集合
      io_write(AM_GPU_FBDRAW, x * w, y * h, color_buf, w, h, false);
    }
  }
  // 同步操作，通常用来通知显存操作完成并刷新屏幕
  io_write(AM_GPU_FBDRAW, 0, 0, NULL, 0, 0, true);
}
```

## 运行库IOE

我们可以看到，程序用到了IOE提供的相关接口来实现了以下操作：

- 读取屏幕宽和高的数据

  ```C
  io_read(AM_GPU_CONFIG)
  ```

- 将像素块填充到显存的操作

  ```C
  io_write(AM_GPU_FBDRAW, x * w, y * h, color_buf, w, h, false)
  ```

- 通知显存操作刷新屏幕的操作

  ```c
  io_write(AM_GPU_FBDRAW, 0, 0, NULL, 0, 0, true);
  ```

这里将用到的定义放在这：

```C
#define io_read(reg) ({ reg ## _T __io_param; ioe_read(reg, &__io_param); __io_param; })

enum { AM_GPU_FBDRAW = (11) }; 
typedef struct { int x, y; void *pixels; int w, h; bool sync; } AM_GPU_FBDRAW_T;

enum { AM_GPU_CONFIG = (9) }; 
typedef struct { bool present, has_accel; int width, height, vmemsz; } AM_GPU_CONFIG_T;

#define SYNC_ADDR (VGACTL_ADDR + 4)
```

首先读取屏幕信息的操作展开为：

```C
// io_read
(
  { 
    AM_GPU_CONFIG_T __io_param; 
	ioe_read(AM_GPU_CONFIG, &__io_param); 
	__io_param; 
  }
)
```

而`ioe_read(AM_GPU_CONFIG, &__io_param)`则是

```C
void __am_gpu_config(AM_GPU_CONFIG_T *cfg) {
  *cfg = (AM_GPU_CONFIG_T) {
    .present = true, .has_accel = false,
    .width  = BITS(inl(VGACTL_ADDR), 31, 16), 
    .height = BITS(inl(VGACTL_ADDR), 15, 0),
    .vmemsz = inl(FB_ADDR)
  };
}
```

此代码从vga控制寄存器所在的内存中，读取对应的高2字节作为宽度，低2字节作为高度。

然后就是将像素块填充到显存的操作展开为：

```C
// io_write(AM_GPU_FBDRAW, x * w, y * h, color_buf, w, h, false);
(
  { 
    AM_GPU_FBDRAW_T __io_param = (AM_GPU_FBDRAW_T) { x * w, y * h, color_buf, w, h, false }; 
	ioe_write(AM_GPU_FBDRAW, &__io_param); 
  }
)
```

即首先声明一个`AM_GPU_FBDRAW_T`类型的变量`__io_param`，其内部成员为：

```C
int x = x * w;
int y = y * h;
void *pixels = color_buf; 
int w = w;
int h = h; 
bool sync = false;
```

而向显存写操作`ioe_write(AM_GPU_FBDRAW, &__io_param)`对应调用

```C
/**
 * @brief 从AM帧缓冲控制器中读取图像信息，写入到显存中
 * AM_GPU_FBDRAW_T参数：int x, y; void *pixels; int w, h; bool sync; 
 * @param AM_GPU_FBDRAW_T *ctl 
 * @date 2024-11-25
 */
void __am_gpu_fbdraw(AM_GPU_FBDRAW_T *ctl) {

  // 获取图像在屏幕的位置信息(x, y) 和图像大小信息(w, h)
  int x = ctl->x, y = ctl->y, w = ctl->w, h = ctl->h;

  // 如果同步寄存器为false 并且 要没有要输出的图像（宽高任意为0），则不做任何操作
  if (!ctl->sync && (w == 0 || h == 0)) return;

  uint32_t *pixels = ctl->pixels;

  // 将图像的像素信息 pixels，写到显存中
  uint32_t *fb = (uint32_t *)(uintptr_t)FB_ADDR;
  uint32_t screen_w = BITS(inl(VGACTL_ADDR), 31, 16);

  for (int j = y; j < y+h; j++) { // 固定行的高度为j
    for (int i = x; i < x+w; i++) { // 按列遍历此行的每一个像素点
      fb[i + j*screen_w] = pixels[(i-x) + (j - y)*w];
    }
  }
  
  // 若`sync`为`true`, 则马上将帧缓冲中的内容同步到屏幕上
  if (ctl->sync) {
    outl(SYNC_ADDR, 1);
  }
}
```

这个函数还蕴含着同步寄存器就在控制寄存器的高4位字节上。

## 11.26

我在不断变强！

- 今天实现将键值对转换为结构体，来解决`NDL_GetDisplayInfo`获取键值对的问题。
- 学习设计模式第一章概念

问题：

- sprintf没加入结束符吗

  ```c
  sprintf(buf, "WIDTH:%d, HEIGHT:%d\n", width, height);
  ```

- 如何设计代码才能让debug压力更小一点？

## 11.27

- 提炼PA的清单 1h
- 理解关于文件的读取和写，改写NDL中的键值对读取错误问题 1h
- 读书2h

PA要做的事情

- 在实现miniSDL的上运行各种GUI程序。

  - NSlider：展示自定义的PDF文件
  - MENU：展示一个菜单, 用户可以选择运行哪一个程序
  - NTerm：模拟终端
  - Flappy Bird：熟悉游戏的规则，了解如何用代码实现游戏效果
  - PAL：运行仙剑奇侠传
  - am-kernels：实现libam，并在在Navy上运行各种AM程序（包括FCEUX,oslab0）

- 实现定点算术

- 实现自由开关DiffTst，加速硬件debug的速度

- 快照系统：将NEMU的状态保存到文件中，以后就可以直接从文件中恢复到这个状态继续执行了

- 在Nanos中添加开机菜单MENU，来执行其他程序

- 在Nanos中添加NTerm，通过命令行来执行其他程序

Navy的native作用：绕开操作系统耦合的代码（libos、libc），直接用linux提供的运行环境运行代码，方便测试

用一张图来表示前面的主要实现API：

![image-20241127170606014](E:\backup\software\typora_image\image-20241127170606014.png)

这节是典型的STFM和STFSC。	

## 11.28

## 定点运算

**定点乘法**

```C
/* Multiplies a fixedpt number with an integer, returns the result. */
static inline fixedpt fixedpt_muli(fixedpt A, int B) {
  fixedpt FB = fixedpt_rconst(B);
	return A * FB / FIXEDPT_ONE;
}

/* Multiplies two fixedpt numbers, returns the result. */
static inline fixedpt fixedpt_mul(fixedpt A, fixedpt B) {
  //  A * B = a * 2^8 * b * 2^8 = (a * b) * 2^16 != (a * b) * 2^8
  return A * B / FIXEDPT_ONE;
}
```

**定点除法**

```c
/* Divides a fixedpt number with an integer, returns the result. */
static inline fixedpt fixedpt_divi(fixedpt A, int B) {
  fixedpt FB = fixedpt_rconst(B);
	return A * FIXEDPT_ONE / FB;
}

/* Divides two fixedpt numbers, returns the result. */
static inline fixedpt fixedpt_div(fixedpt A, fixedpt B) {
  // A/B = A * 2^8 / B
  // 这样会导致损失精度太高：小数部分（低8位不会被保存 -- 已经舍弃）
  // return A / B * FIXEDPT_ONE;
  return A * FIXEDPT_ONE / B;
}
```

这里需要先乘以`FIXEDPT_ONE`的原因是：先将小数部分提升到高位，是为了保留和恢复定点数的小数精度，避免丢失精度。如果直接除`B`，则定点数除法步骤为：

```tex
A / B * 2^8 = a * 2^8 / (b * 2^8) * 2^8 = a * 2^8 / 2^8 / b * 2^8
```

而观察其中` a * 2^8 / 2^8`的这一步，会让定点数A的小数部分直接清空，从而损失了精度。

为了避免损失精度，需要在`A`除以`B`之前，先乘`2^8`即`FIXEDPT_ONE`来保护定点数`A`的精度。

**其他操作**

```C
static inline fixedpt fixedpt_abs(fixedpt A) {
  // 1.2-->0X133, -1.2-->0Xffff,fecd
  // 提取符号位
  int is_negative = (A >> (FIXEDPT_BITS - 1)) & 1;
  if(is_negative) {
    A = -A;
  }
	return A;
}

static inline fixedpt fixedpt_floor(fixedpt A) {
  return A >> FIXEDPT_FBITS << FIXEDPT_FBITS;
}

/**
 * @brief 定点数的向上取整
 * 实数带小数  ：实数的整数部分+1，小数部分清空
 * 实数不带小数：不做任何操作即可
 * 
 * 判断条件：如果实数带小数，则定点数后8位不为0
 * @param A 
 * @return fixedpt 
 * @date 2024-11-28
 */
static inline fixedpt fixedpt_ceil(fixedpt A) {
  // 实数带小数  ：实数的整数部分+1，小数部分清空
  if (fixedpt_fracpart(A) != 0) {
    A = A - fixedpt_fracpart(A) + FIXEDPT_ONE;
  }
	return A;
}
```

[测试案例](https://github.com/CharlieCRX/pa/blob/pa3/navy-apps/libs/libfixedptc/test.c)

