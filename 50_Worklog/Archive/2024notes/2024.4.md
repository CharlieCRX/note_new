# 4æœˆä»½æ—¥æŠ¥

## 4.1

æ„šäººèŠ‚å¿«ä¹ã€‚

é€’å½’ä»æ—§æ˜¯æˆ‘çš„éš¾é¢˜ï¼ŒæœŸå¾…æœ‰æœä¸€æ—¥å®ƒèƒ½æˆä¸ºæˆ‘çš„å¼ºé¡¹ã€‚

## 4.2

ä»Šæ—¥todo

- [x] ä¸‹è½½bomblabä¸Šä¼ gitï¼ˆ15minsï¼‰
- [x] é˜…è¯»bomblabå®éªŒè¦æ±‚å’Œé¢˜ç›®è®¾ç½®ï¼ˆ30minsï¼‰
- [ ] ç»§ç»­é˜…è¯»[ã€è¯»è–„ CSAPPã€‘è´° æœºå™¨æŒ‡ä»¤ä¸ç¨‹åºä¼˜åŒ–](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/)ï¼ˆ2hï¼‰
- [x] cs61aï¼šé˜…è¯»[4.2æ¶‰åŠçš„ä»£ç å’ŒåŸºæœ¬æ¦‚å¿µ](https://composingprograms.netlify.app/4/2)ï¼ˆ25minsï¼‰
- [x] é˜…è¯»[Lab 05: Iterators, Mutability](https://cs61a.org/lab/lab05/)é¢˜ç›®ï¼ˆ30minsï¼‰
- [x] é˜…è¯»[Disc 06: Iterators, Generators](https://cs61a.org/disc/disc06/)é¢˜ç›®ï¼ˆ30minsï¼‰
- [x] è§£å†³[HW 04: Sequences, Trees](https://cs61a.org/hw/hw04/)é—®é¢˜ï¼Œæ¸…ç†2.23ä¹‹å‰çš„é—®é¢˜ï¼ˆ1hï¼‰
- [ ] é˜…è¯»datalabçš„åå››ä¸ªé—®é¢˜ï¼ˆ1hï¼‰
- [x] [äº†è§£gdbçš„åŸºæœ¬ç”¨æ³•](https://www.cs.cmu.edu/~213/recitations/rec02_handout.pdf)ï¼ˆ30minsï¼‰
- [ ] [æ™®äº¬çš„æœ€é«˜ç†æƒ³ï¼è®©æ¬§æ´²æˆ˜æ —çš„å¥³å¸ï¼ã€Šå¶å¡æ·ç³å¨œå¤§å¸ã€‹P1](https://www.bilibili.com/video/BV1xY4y1d7uk/?spm_id_from=333.337.search-card.all.click&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [ ] [ä¸“é¢˜ï¼šå›é¡¾å®«å´éªä¸ä¹…çŸ³è®©40å¹´åˆ›ä½œå†ç¨‹](https://www.bilibili.com/video/BV1Wx421D7r8/?spm_id_from=333.999.0.0&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [x] [whynotè§†é¢‘](https://www.bilibili.com/video/BV1hc411f75N/?spm_id_from=333.999.0.0&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [ ] å—äº¬ä¸€æ—¥æ¸¸æ¨èè·¯çº¿

bomblabè¦å­¦å“ªäº›å‰ç½®çŸ¥è¯†ï¼ˆé‡ç‚¹å­¦ä¹ ï¼‰

1. æ±‡ç¼–æŒ‡ä»¤åŠå…¶ç”¨æ³•
2. gdbè°ƒè¯•çš„å°æŠ€å·§ï¼ï¼ï¼ï¼ˆåˆ©ç”¨ä¸Šé¢çš„[äº†è§£gdbçš„åŸºæœ¬ç”¨æ³•](https://www.cs.cmu.edu/~213/recitations/rec02_handout.pdf)ï¼‰
3. é˜…è¯»[writeup](E:\code_life\1_project\csapp\03machine_prog\bomblab.pdf)
4. [slides](https://docs.google.com/presentation/d/1OjLAjPxhEXsElWsvmNnMGD-fzNCeGXip/edit#slide=id.p9)ï¼ˆè¶…çº§é‡è¦ï¼ï¼ï¼Œç›¸å½“äºåšé¡¹ç›®ä¹‹å‰çš„çŸ¥è¯†å‚¨å¤‡ï¼‰
5. ç”¨è€…ä¿å­˜å¯„å­˜å™¨å’Œè¢«è°ƒç”¨è€…ä¿å­˜å¯„å­˜å™¨çš„åˆ’åˆ†æ˜¯ä¸ºäº†åœ¨å‡½æ•°è°ƒç”¨è¿‡ç¨‹ä¸­ç®¡ç†å¯„å­˜å™¨çš„çŠ¶æ€ï¼Œç¡®ä¿åœ¨å‡½æ•°è°ƒç”¨ç»“æŸåï¼Œå¯„å­˜å™¨çš„å€¼èƒ½å¤Ÿæ­£ç¡®åœ°æ¢å¤ï¼Œä¸ä¼šå½±å“åˆ°è°ƒç”¨è€…æˆ–è¢«è°ƒç”¨è€…çš„ä»£ç ï¼Œä»è€Œç¡®ä¿ç¨‹åºçš„æ­£ç¡®æ€§å’Œå¯é æ€§ã€‚
6. %rax,%rsp,%rbpä½œç”¨
7. Objdump
8. sscanf

è¿­ä»£å™¨æ˜¯ä¸€ç§å¯¹è±¡ï¼Œæä¾›å¯¹å€¼é€ä¸€é¡ºåºè®¿é—®çš„åŠŸèƒ½ã€‚

```py
>>> iterator = iter(primes)
>>> next(iterator)
>>> try:
        next(iterator)
    except StopIteration:#æ²¡æœ‰æ›´å¤šå¯ç”¨å€¼
        print('No more values')
```

Python ä¸­çš„ `for` è¯­å¥æ˜¯å¯¹è¿­ä»£å™¨è¿›è¡Œæ“ä½œã€‚ å¦‚æœå¯¹è±¡å…·æœ‰è¿”å›è¿­ä»£å™¨çš„ `__iter__` æ–¹æ³•ï¼ˆmethodï¼‰ï¼Œåˆ™è¡¨ç¤ºå¯¹è±¡æ˜¯å¯è¿­ä»£çš„ã€‚

å°†å‡½æ•°æ¯”ä½œå¨å¸ˆï¼š

> We're lazy (like an iterator) and used ChatGPT to generate a generator joke...
>
> why did the Python function become a chef?
>
> Because it was skilled at knowing when to "return" to the recipe and when to "yield" to improvisation!

# Homework 4: Sequences, ADT Trees

### Q1: Deep Map

Write a function `deep_map` that takes a list `s` and a one-argument function `f`. `s` may be a nested list, one that contain other lists. `deep_map` modifies `s` by replacing each element within `s` or any of the lists it contains with the result of calling `f` on that element.

`deep_map` returns `None` and should not create any new lists.

> **Hint:** `type(a) == list` will evaluate to `True` if `a` is a list.

```py
def deep_map(f, s):
    """Replace all non-list elements x with f(x) in the nested list s.

```

å®ç°æ€è·¯ï¼š

1. åˆ©ç”¨é€’å½’ï¼Œå°†å¤§çš„åµŒå¥—åˆ—è¡¨å…ƒç´ ï¼Œåˆ†è§£ä¸ºä¸€ä¸ªä¸ªå°çš„å…ƒç´ `elem`ï¼Œå¹¶å°†æ‰€æœ‰å…ƒç´ `elem`æŒ‰ç…§`f`è§„åˆ™å¤„ç†
2. base caseï¼š
   1. ä¸€ä¸ªåˆ—è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ éå†å®Œæ¯•åï¼Œè¿”å›`None`
   2. éå†æ¯ä¸ªå…ƒç´ çš„æ—¶å€™ï¼Œå¦‚æœç±»å‹æ˜¯`list`ï¼Œåˆ™ç»§ç»­é€’æ¨`deep_map(f, s)`å¤„ç†æ­¤`list`ç±»å‹çš„æ•°æ®ï¼›å¦‚æœä¸æ˜¯åˆ™æŒ‰ç…§one-argument function `f`å¤„ç†

ç¿»è¯‘æˆä»£ç ï¼š

```py
def deep_map(f, s):
    """Replace all non-list elements x with f(x) in the nested list s.

    >>> six = [1, 2, [3, [4], 5], 6]
    >>> deep_map(lambda x: x * x, six)
    >>> six
    [1, 4, [9, [16], 25], 36]
    >>> # Check that you're not making new lists
    >>> s = [3, [1, [4, [1]]]]
    >>> s1 = s[1]
    >>> s2 = s1[1]
    >>> s3 = s2[1]
    >>> deep_map(lambda x: x + 1, s)
    >>> s
    [4, [2, [5, [2]]]]
    >>> s1 is s[1]
    True
    >>> s2 is s1[1]
    True
    >>> s3 is s2[1]
    True
    """
    "*** YOUR CODE HERE ***"


    # base case1: Processing of traversing element "elem"
    # If it is not a list element, then for f(elem);
    # If it is a list element, call deep_map(f, elem) on the list element elem
    i = 0
    while i < len(s):
        if type(s[i]) == list:
            deep_map(f, s[i])
        else:
            s[i] = f(s[i])
        i += 1
    # base case: end of traversal
    # After traversing the last element, return None
    return None
```

### Q3: Balanced

Implement the `balanced` function, which returns whether `m` is a balanced mobile. A mobile is balanced if both of the following conditions are met:

1. The torque applied by its left arm is equal to the torque applied by its right arm. The torque of the left arm is the length of the left rod multiplied by the total mass hanging from that rod. Likewise for the right. For example, if the left arm has a length of `5`, and there is a `mobile` hanging at the end of the left arm of total mass `10`, the torque on the left side of our mobile is `50`.
2. Each of the mobiles hanging at the end of its arms is itself balanced.

Planets themselves are balanced, as there is nothing hanging off of them.

> **Reminder:** You may use the `total_mass` function above. Don't violate abstraction barriers. Instead, use the selector functions that have been defined.

é€’å½’åˆ¤æ–­ä¸€ä¸ª`planet`æ˜¯å¦å¹³è¡¡ï¼š

1. åŠ›çŸ©ç›¸åŒ
2. æ¯ä¸ªå°çš„`planet`ä¹Ÿæ˜¯å¹³è¡¡çš„

é‚£ä¹ˆå®ç°æ€è·¯ï¼š

1. base caseå¦‚æœ`mobile`å·¦å³ä¸¤è¾¹`end`å‡æ˜¯æ˜Ÿçƒï¼Œé‚£ä¹ˆè®¡ç®—æ˜ŸçƒåŠ›çŸ©æ˜¯å¦ç›¸åŒï¼š
   1. åŠ›çŸ©ç›¸åŒï¼Œè¿”å›`True`ï¼›
   2. åŠ›çŸ©ä¸ç›¸åŒï¼Œè¿”å›`false`
2. å¦‚æœ`mobile`å·¦å³ä¸¤è¾¹åŠ›çŸ©ç›¸åŒï¼Œåˆ¤æ–­æ­¤`mobile`çš„å·¦å³éƒ¨åˆ†æ˜¯å¦å¹³è¡¡
3. ä¸¤ä¸ªæ¡ä»¶ä¸æ»¡è¶³ï¼Œåˆ™è¿”å›`false`

æœ€ç»ˆå®ç°äº†è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯æŒ‰ç…§è¿™ä¸ªæ€è·¯æ¥çš„ï¼ˆæ„Ÿè§‰é€’å½’å¾ˆå¥‡å¦™ï¼ï¼‰

## 4.3

todlistï¼š

- [x] datalabå›é¡¾å€’æ•°å4é¢˜ç›®å›é¡¾è§£å†³å…³é”®ç‚¹
- [x] [æ™®äº¬çš„æœ€é«˜ç†æƒ³ï¼è®©æ¬§æ´²æˆ˜æ —çš„å¥³å¸ï¼ã€Šå¶å¡æ·ç³å¨œå¤§å¸ã€‹P1](https://www.bilibili.com/video/BV1xY4y1d7uk/?spm_id_from=333.337.search-card.all.click&vd_source=842936ebeedd7cce8bb2e1922b41edf1)
- [x] è¯»å®Œ[ã€è¯»è–„ CSAPPã€‘è´° æœºå™¨æŒ‡ä»¤ä¸ç¨‹åºä¼˜åŒ–](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/)
- [x] é˜…è¯»[Lab 05: Iterators, Mutability](https://cs61a.org/lab/lab05/)é¢˜ç›®+ç­”æ¡ˆï¼ˆ30minsï¼‰
- [ ] é˜…è¯»[Disc 06: Iterators, Generators](https://cs61a.org/disc/disc06/)é¢˜ç›®+ç­”æ¡ˆï¼ˆ30minsï¼‰

**æ¥å—å¤±è´¥å¹¶å­¦ä¹ **ï¼šæ¥å—æ¯å¤©æ— æ³•å®Œæˆæ‰€æœ‰è®¡åˆ’çš„äº‹å®ï¼Œå¹¶ä»ä¸­å­¦ä¹ ç»éªŒæ•™è®­ã€‚å¤±è´¥å¹¶ä¸æ„å‘³ç€ç»“æŸï¼Œè€Œæ˜¯ä¸ºæ›´å¥½çš„å¼€å§‹ç§¯ç´¯ç»éªŒã€‚

ç°åœ¨æ˜¯4.3å·çš„17:00ï¼Œæ„Ÿè§‰é¢å¯¹è¿™äº›é—®é¢˜å‹åŠ›å¾ˆå¤§ï¼Œæ€»è§‰å¾—â€œå¥½å›°éš¾â€çš„æ ·å­ã€‚ä»è€Œé˜»æ­¢äº†è‡ªå·±æƒ³ç»§ç»­ä¸‹å»çš„è„šæ­¥ã€‚

è¿™ä¸¤å¤©æœ‰ä¸€äº›æŒ«è´¥æƒ…ç»ªè®©æˆ‘æ„Ÿè§‰åˆ°æœ‰å‹åŠ›ï¼š

1. å¦„å›¾ç¬¬ä¸€éå°±è§£å†³é—®é¢˜ã€‚è¿˜æ˜¯è€é—®é¢˜ï¼Œã€Šå­¦ç”Ÿä¸ºä»€ä¹ˆä¸å–œæ¬¢ä¸Šå­¦ã€‹é‡Œé¢è¯´çš„ï¼Œå½“èƒŒæ™¯çŸ¥è¯†ä¸å¤Ÿçš„æ—¶å€™ï¼Œè§£å†³ä¸€ä¸ªé—®é¢˜å°±ä¼šå˜å¾—å¼‚å¸¸å›°éš¾ã€‚é‚£ä¹ˆå°±æ‹¿csappçš„datalabæ¥è¯´æ˜èƒŒæ™¯çŸ¥è¯†å½±å“è‡ªå·±è¿›åº¦å¿ƒæƒ…çš„ä¾‹å­ï¼šfloatéƒ¨åˆ†é¢˜ç›®ï¼Œéœ€è¦å¯¹IEEEçš„ç¼–ç ã€32ä½å•ç²¾åº¦æµ®ç‚¹æ•°çš„å€¼åŸŸã€ç§»ä½æ“ä½œã€é€»è¾‘ä¸æˆ–éæŠ€å·§å¾ˆç†Ÿç»ƒï¼Œæ‰èƒ½åœ¨è§£å†³è¿™äº›é—®é¢˜çš„æ—¶å€™æ›´åŠ æ¸¸åˆƒæœ‰ä½™ã€‚ç›¸åå¦‚æœå…¶ä¸­ä»»ä½•ä¸€ä¸ªç¯èŠ‚æ²¡æŒæ¡æ˜ç™½ï¼Œéƒ½ä¼šé€ æˆè‡ªå·±åšé¢˜å›°éš¾ï¼Œç”¨æ—¶å¾ˆé•¿çš„é—®é¢˜ã€‚
2. ä¸åˆç†çš„ç›®æ ‡è®¾ç½®ã€‚æƒ³åšå‡ºæ¥ï¼Œæœ€èµ·ç ç†è§£é—®é¢˜æ˜¯ä»€ä¹ˆææ¸…æ¥šï¼Œç„¶åå°±æ˜¯å®ç°æ­¥éª¤ï¼Œå†æœ€åè½å®åˆ°è¡ŒåŠ¨ã€‚

è¿™ä¸¤ä¸ªé—®é¢˜çš„å‡ºç°ï¼Œè®©æˆ‘å­¦ä¼šä»ç§¯æçš„è§’åº¦çœ‹å¾…å¤±è´¥å’ŒæŒ«æŠ˜ï¼Œå°†å…¶è§†ä¸ºæˆé•¿çš„æœºä¼šè€Œä¸æ˜¯å¤±è´¥ã€‚åšæŒæ­£å‘çš„æ€ç»´å’Œæ€åº¦ï¼Œæ¿€åŠ±è‡ªå·±ä¸æ–­å‰è¿›ã€‚

ç°åœ¨æœ‰ä¸€ä¸ªæˆé•¿çš„æœºä¼šæ‘†åœ¨æˆ‘çš„çœ¼å‰ï¼šå¦‚ä½•è®©è‡ªå·±å­¦èµ·æ¥æ›´æ„‰æ‚¦ï¼Ÿ

é‚£å°±æ˜¯åˆ«è®¾ç½®å¤ªé«˜æœŸæœ›ï¼Œå…ˆæ··ä¸ªçœ¼ç†Ÿå¤§æ¦‚ï¼Œç„¶åå†ä»”ç»†ç ”ç©¶ã€‚æœ€èµ·ç ï¼Œä½ å¾—å…ˆçœ‹ä¸€çœ¼é—®é¢˜å§ï¼Ÿç„¶åç¨å¾®æ€è€ƒä¸‹è§£å†³æ€è·¯å§ï¼Ÿæ€è€ƒ10åˆ†é’Ÿæ²¡æœ‰ç»“æœå°±èµ¶ç´§çœ‹ç­”æ¡ˆè§£æå‘—ï¼Œå“ªé‡Œä¸ä¼šå­¦å“ªé‡Œå•Šï¼ç­”æ¡ˆåˆ†æå®Œäº†è‡ªå·±è§£å†³ä¸€éï¼Œä¸ä¼šæ²¡äº‹ï¼Œå†çœ‹ä¸€éç­”æ¡ˆåˆ†æï¼ŒæŸ¥ç¼ºè¡¥æ¼å‘—ã€‚

é¡ºç€æƒ…ç»ªæ¥å§ï¼Œè®©è‡ªå·±å¼€å¿ƒä¸€ç‚¹å®è´ã€‚

å¤šè½®é‡å¤æ»šåŠ¨çš„æ™ºæ…§ï¼Œä¸å°±æ˜¯é™ä½èƒŒæ™¯çŸ¥è¯†ç¼ºä¹å¸¦æ¥çš„å­¦ä¹ æŒ«è´¥å—ã€‚

åŠ æ²¹å®è´ï¼

ä»Šæ™šå…ˆå°†cs61aéƒ¨åˆ†çš„é—®é¢˜å…ˆç†è§£ä¸€éï¼Œæè¿°ä¸€ä¸‹ï¼Œæ˜å¤©è¯•ç€è§£å†³ï¼Œ5åˆ†é’Ÿè§£å†³ä¸äº†ç›´æ¥çœ‹ç­”æ¡ˆåˆ†æã€‚

## è¡¥å……çŸ¥è¯†ï¼š

`map` å‡½æ•°å°† `function` åº”ç”¨äºæ¯ä¸ªå¯è¿­ä»£å¯¹è±¡ä¸­ç›¸åŒä½ç½®çš„å…ƒç´ ï¼Œè¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ˆåœ¨ Python 2 ä¸­è¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼‰

å®ä¾‹ï¼š

```py
# ä½¿ç”¨å†…ç½®å‡½æ•°
numbers = [1, 2, 3, 4, 5]
squared_numbers = map(lambda x: x ** 2, numbers)
print(list(squared_numbers))  # è¾“å‡º: [1, 4, 9, 16, 25]
```

`map` å‡½æ•°å°†å‡½æ•°åº”ç”¨äº `numbers` åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œå¹¶è¿”å›æ–°çš„åˆ—è¡¨æˆ–è¿­ä»£å™¨ï¼ŒåŒ…å«äº†åº”ç”¨å‡½æ•°åçš„ç»“æœã€‚

## 4.4

æ··ä¸ªçœ¼ç†Ÿï¼Œå¤§æ¦‚æµè§ˆäº†ä¸€éé¢˜ç›®ï¼Œå¯¹å…¶ä¸­çš„é—®é¢˜å¤§æ¦‚äº†è§£äº†ã€‚

- æµå—çš„ç‰¹äº§å’Œçºªå¿µå“+æµå—æ—…æ¸¸æ”»ç•¥
- å—äº¬ä¸¤å¤©å®‰æ’ï¼ˆé‡è¦ï¼ï¼‰

```py
(lambda t: [next(t) for _ in range(10)])(gen_fib())
```

è°ƒç”¨`gen_fib()`åæ¬¡ã€‚

å¿«é€Ÿæµè§ˆ[ã€è¯»è–„ CSAPPã€‘è´° æœºå™¨æŒ‡ä»¤ä¸ç¨‹åºä¼˜åŒ–](https://wdxtub.com/csapp/thin-csapp-2/2016/04/16/)èƒŒæ™¯çŸ¥è¯†

1. æ“ä½œæ•°æ˜¯å¸¦æ‹¬å·çš„ï¼Œæ‹¬å·çš„æ„æ€å°±æ˜¯å¯»å€ï¼š`movq (%rcx), %rax` ä¹Ÿå°±æ˜¯è¯´ä»¥ %rcx å¯„å­˜å™¨ä¸­å­˜å‚¨çš„åœ°å€å»å†…å­˜é‡Œæ‰¾å¯¹åº”çš„æ•°æ®ï¼Œå­˜åˆ°å¯„å­˜å™¨ %rax ä¸­-- `temp = *p;`
2. å¯¹äºå¯»å€æ¥è¯´ï¼Œæ¯”è¾ƒé€šç”¨çš„æ ¼å¼æ˜¯ `D(Rb, Ri, S)` -> `Mem[Reg[Rb]+S*Reg[Ri]+D]`

## 4.5

ä»Šå¤©è§£å†³

- [x] [Lab 05: Iterators, Mutability](https://cs61a.org/lab/lab05/)é¢˜ç›®ï¼ˆ30minsï¼‰
- [x] [Disc 06: Iterators, Generators](https://cs61a.org/disc/disc06/)é¢˜ç›®ï¼ˆ30minsï¼‰
- [x] [ HW 05: Generators](https://cs61a.org/hw/hw05/)é¢˜ç›®ï¼ˆ1hï¼‰
- [x] å›é¡¾csapp datalab floatéƒ¨åˆ†ï¼ˆ1hï¼‰

`a, b = s, s[:]`

è¿™æ˜¯ä¸€ä¸ªå¤šé‡èµ‹å€¼è¯­å¥ï¼Œå®ƒå°†åˆ—è¡¨ `s` èµ‹å€¼ç»™å˜é‡ `a`ï¼ŒåŒæ—¶å°†åˆ—è¡¨ `s` çš„å‰¯æœ¬ï¼ˆé€šè¿‡åˆ‡ç‰‡ `s[:]` æ¥å®ç°ï¼‰èµ‹å€¼ç»™å˜é‡ `b`ã€‚

è¿™æ ·çš„èµ‹å€¼æ–¹å¼æœ‰ä¸€äº›ç»†å¾®ä½†é‡è¦çš„åŒºåˆ«ï¼š

- `a = s`ï¼šè¿™ç§èµ‹å€¼æ–¹å¼åªæ˜¯å°†å˜é‡ `a` æŒ‡å‘äº†åˆ—è¡¨ `s`ï¼Œå³ `a` å’Œ `s` å…±äº«åŒä¸€ä¸ªå¯¹è±¡ï¼Œä¿®æ”¹å…¶ä¸­ä¸€ä¸ªå˜é‡çš„å€¼ä¼šå½±å“å¦ä¸€ä¸ªå˜é‡ã€‚

- `b = s[:]`ï¼šè¿™ç§èµ‹å€¼æ–¹å¼æ˜¯åˆ›å»ºäº†åˆ—è¡¨ `s` çš„ä¸€ä¸ªå‰¯æœ¬ï¼Œå¹¶å°†è¿™ä¸ªå‰¯æœ¬èµ‹å€¼ç»™å˜é‡ `b`ï¼Œå³ `b` æŒ‡å‘äº†ä¸€ä¸ªæ–°çš„åˆ—è¡¨å¯¹è±¡ï¼Œä¿®æ”¹ `b` çš„å€¼ä¸ä¼šå½±å“ `s`ã€‚

60åˆ†è¦æ¯”100åˆ†é‡è¦ï¼

`yield from`ï¼šç”Ÿæˆå™¨å‡½æ•°ä¸­å§”æ‰˜ç”Ÿæˆå™¨ã€‚è¿™ç§è¯­æ³•ä½¿å¾—ç”Ÿæˆå™¨å¯ä»¥ç›´æ¥è°ƒç”¨å¦ä¸€ä¸ªç”Ÿæˆå™¨ï¼Œå¹¶å°†å…¶äº§ç”Ÿçš„å€¼é€ä¸ªè¿”å›ï¼Œè€Œä¸éœ€è¦åœ¨å¤–å±‚ç”Ÿæˆå™¨ä¸­æ˜¾å¼åœ°éå†å¹¶ yield ç”Ÿæˆå™¨å†…éƒ¨çš„å€¼ã€‚

```py
def partition_gen(n, m):
    """Yield the partitions of n using parts up to size m.

    >>> for partition in sorted(partition_gen(6, 4)):
    ...     print(partition)
    1 + 1 + 1 + 1 + 1 + 1
    1 + 1 + 1 + 1 + 2
    1 + 1 + 1 + 3
    1 + 1 + 2 + 2
    1 + 1 + 4
    1 + 2 + 3
    2 + 2 + 2
    2 + 4
    3 + 3
    """
    assert n > 0 and m > 0
    if n == m:
        yield str(n)
    if n - m > 0:
        for p in partition_gen(n - m, m):
            yield p + ' + ' + str(m)
    if m > 1:
        yield from partition_gen(n, m-1)
```

`yield from partition_gen(n, m - 1)` å®é™…ä¸Šç›¸å½“äºéå†è°ƒç”¨ `partition_gen(n, m - 1)` ç”Ÿæˆå™¨æ‰€äº§ç”Ÿçš„æ‰€æœ‰å€¼ï¼Œå¹¶å°†è¿™äº›å€¼é€ä¸ª yield å‡ºæ¥ã€‚

å…·ä½“æ¥è¯´ï¼Œ`yield from` è¯­å¥ä¼šå°†è°ƒç”¨çš„ç”Ÿæˆå™¨äº§ç”Ÿçš„å€¼é€ä¸ªè¿”å›ç»™å¤–å±‚çš„ç”Ÿæˆå™¨ï¼Œå°±å¥½åƒåœ¨å¤–å±‚ç”Ÿæˆå™¨ä¸­æ‰‹åŠ¨éå†å¹¶ yield è¿™äº›å€¼ä¸€æ ·ã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯å¯ä»¥ç®€åŒ–ä»£ç ï¼Œä½¿å¾—ç”Ÿæˆå™¨çš„ä½¿ç”¨æ›´åŠ æ¸…æ™°å’Œç®€æ´ã€‚

## 4.8

è®°å½•æ—¶é•¿å’Œå…·ä½“é—®é¢˜ã€‚

10:00-10:30ï¼šè®°å¿†3.2ä¸­çš„å¯„å­˜å™¨åŠå…¶å¤§ä½“åŠŸèƒ½ï¼›è®°å¿†æ“ä½œæ•°ä¸‰ä¸ªæ¥æºï¼ˆç«‹å³æ•°ã€å¯„å­˜å™¨å’Œå†…å­˜ï¼‰åŠå…¶å½¢å¼ã€‚

10:30-11:00ï¼šå¦‚å›¾ã€‚æ•°æ®è½¬ç§»æŒ‡ä»¤çš„æ ¼å¼åŠå…¶åç¼€æ„ä¹‰ã€‚

![image-20240408104834004](E:\backup\crx\cs\cs61a\2024notes\image\image-20240408104834004.png)

14:00-15:00ï¼šåœ¨x86ä¸­ï¼Œæ ˆæ˜¯æœç€ä½åœ°å€ç”Ÿé•¿çš„ã€‚With x86-64, stacks grow toward lower addresses, so pushing involves decrementing the stack pointer (register %rsp) and storing to memory,while popping involves reading from memory and incrementing the stack pointer.

`pushq %rbp` is equivalent to that of the pair of instructions:

```assembly
subq $8,%rsp 		#Decrement stack pointer
movq %rbp,(%rsp) 	#Store %rbp on stack
```

the instruction `popq %rax` is equivalent to the following pair of instructions:

```assembly
movq (%rsp),%rax 	#Read %rax from stack
addq $8,%rsp 		#Increment stack pointer
```

csappæ€»å…±ç”¨æ—¶3hï¼ŒæŒæ¡äº†å¯„å­˜å™¨ï¼ŒmovæŒ‡ä»¤å’Œstackéƒ¨åˆ†çš„çŸ¥è¯†ï¼Œå› ä¸ºå­¦ä¹ çš„å†…å®¹éƒ½åå‘è®°å¿†ï¼Œæ‰€ä»¥å­¦ä¹ è¾ƒä¸ºè½»æ¾ã€‚

15:40å¼€å§‹ï¼Œå­¦ä¹ cs61açš„2.5èŠ‚ã€‚

```py
>>> class Account:
   		def __init__(self, account_holder):
            self.balance = 0
            self.holder = account_holder
```

- æ„é€ å‡½æ•°åŠå…¶å‚æ•°ã€‚ç¬¬ä¸€ä¸ª `self` ç»‘å®šåˆ°æ–°åˆ›å»ºçš„ `Account` å¯¹è±¡ã€‚ç¬¬äºŒä¸ªå‚æ•° `account_holder` æ˜¯ç±»è¿›è¡Œå®ä¾‹åŒ–æ—¶çš„å‚æ•°ã€‚

- å†…ç½®å‡½æ•° `getattr` å¯ä»¥æŒ‰åç§°è¿”å›å¯¹è±¡çš„å±æ€§`getattr(spock_account, 'balance')`

- è°ƒç”¨æ–¹æ³•ï¼š

  ```py
  >>> Account.deposit(spock_account, 1001)	# å‡½æ•° deposit æ¥å—ä¸¤ä¸ªå‚æ•°
  1011
  >>> spock_account.deposit(1000) 			# æ–¹æ³• deposit æ¥å—ä¸€ä¸ªå‚æ•°
  2011
  ```

- åœ¨å­ç±»ä¸­æœªæŒ‡å®šçš„ä»»ä½•å†…å®¹éƒ½ä¼šè¢«è‡ªåŠ¨å‡å®šä¸ºä¸çˆ¶ç±»çš„è¡Œä¸ºä¸€æ ·

15:40-16:12ï¼šå®Œæˆé˜…è¯»2.5èŠ‚å†…å®¹ï¼Œå‡†å¤‡é˜…è¯»2.7èŠ‚å†…å®¹ã€‚

16:12-18:30ï¼šæ™šé¥­ï¼Œå¤„ç†é¸¡è‚‰ï¼Œæ¨èæ‰‹æœº+ä¼‘æ¯25mins

é€šè¿‡ `@property` è£…é¥°å™¨ï¼Œå¯ä»¥å°†ä¸€ä¸ªæ–¹æ³•è½¬å˜ä¸ºç±»çš„ä¸€ä¸ªå±æ€§ï¼Œè€Œä¸éœ€è¦ä½¿ç”¨æ–¹æ³•è°ƒç”¨çš„æ‹¬å·ã€‚è¿™ç§æ–¹å¼å¯ä»¥ä½¿å¾—ä»£ç æ›´åŠ æ¸…æ™°å’Œç®€æ´ï¼Œå¹¶ä¸”ç¬¦åˆ Python çš„é¢å‘å¯¹è±¡ç¼–ç¨‹é£æ ¼

18:30-17:30ï¼šé˜…è¯»2.7å’Œ2.8å†…å®¹ã€‚

17:30-20:16ï¼šæœé›†sicpå­¦ä¹ æ–¹é¢çš„èµ„æ–™ï¼š

[Why Structure and Interpretation of Computer Programs matters](https://people.eecs.berkeley.edu/~bh/sicp.html)ï¼š

- In my SICP-based course at Berkeley, we spend the first hour on notation and that's all we need; for the rest of the semester we're learning ideas, not syntax. 
- Once you learned the big ideas, they thought, and this is my experience also, learning another programming language isn't a big deal; it's a chore for a weekend.
- The idea that computer science should be about ideas, not entirely about programming practice, has since widened to include non-technical ideas about the context and social implications of computing

å­¦å¥½é‡Œé¢çš„æ€æƒ³çš„å‰æï¼Œå°±æ˜¯éœ€è¦ç»ƒä¹ å·©å›ºæ¦‚å¿µå§ï¼Ÿ

å­¦ä¹ äº†ä¸‹è€¶å…‹æ–¯å¤šå¾·æ£®å®šå¾‹ï¼Œä¸€ä¸ªå…³äºåŠ¨æœºå’Œæ•ˆç‡ä¹‹é—´çš„å…³ç³»å›¾è¡¨ã€‚æ€»ç»“å°±æ˜¯ä¸¤å¥è¯ï¼š

1. åŠ¨æœºå’Œæ•ˆç‡å¹¶ä¸æˆæ­£æ¯”ï¼Œå¾€å¾€æˆä¸€ä¸ªå€’Uå‹æ›²çº¿ã€‚è¦åŠæ—¶è§‚å¯Ÿè‡ªå·±çš„å¿ƒæ€æ„Ÿå—ï¼Œæ¬²é€Ÿåˆ™ä¸è¾¾ï¼Œæ±‚è€Œä¸å¾—ã€‚

2. å›°éš¾çš„é—®é¢˜éœ€è¦è¾ƒå°‘çš„åŠ¨æœºï¼Œæ‰ä¼šæœ‰æ›´å¥½åœ°ä½“éªŒã€‚

ä¹Ÿå¯ä»¥è¯´å°†å¤§é—®é¢˜åˆ†è§£ä¸ºå®¹æ˜“åšçš„å°é—®é¢˜ã€‚è¿™ä¸ªå°é—®é¢˜çš„åº¦å°±æ˜¯ç®€å•æ— è„‘ï¼ˆç±»ä¼¼é“ºå«èƒŒæ™¯çŸ¥è¯†ï¼‰ï¼Œç­‰ä½ è§£å†³è¿™äº›å°é—®é¢˜å¤šäº†ï¼Œæ‰å‘ç°è¿™ä¸ªé—®é¢˜å·²ç»è§£å†³çš„å·®ä¸å¤šäº†ã€‚è¦å¤šæ³¨æ„è‡ªå·±çš„çœŸå®æ„Ÿå—ï¼Œå°Šé‡è‡ªå·±å¹¶çˆ±æŠ¤è‡ªå·±çš„å¥½å¥‡å¿ƒå’Œè¿›å–å¿ƒã€‚

å› ä¸ºå®ƒä»¬æ˜¯å¾ˆè„†å¼±çš„ã€‚

## 4.9

cs61a

1.7é€’å½’å­¦ä¹ ï¼š

1. `sum_digits(738)`åšäº†ä»€ä¹ˆ

```py
>>> def sum_digits(n):
        """Return the sum of the digits of positive integer n."""
        if n < 10:
            return n
        else:
            all_but_last, last = n // 10, n % 10
            return sum_digits(all_but_last) + last
>>> sum_digits(738)
```

2. sum_digitsçš„base caseæ˜¯ä»€ä¹ˆï¼Ÿ
3.  whyï¼ŸThat is, we should not care about how `fact(n-1)` is implemented in the body of `fact`; we should simply trust that it computes the factorial of `n-1`.*recursive leap of faith*ï¼Œç›¸ä¿¡`fact(n-1)`çš„æ­£ç¡®æ€§ï¼Œè€Œä¸æ˜¯å…³æ³¨`fact(n-1)`çš„å…·ä½“å®ç°ã€‚
4. tree recursion, in which a function calls itself more than once.but why called they are tree recurision?å› ä¸ºé—®é¢˜ä¼šè¢«åˆ†è§£çš„æ›´å°ä½†æ˜¯æ•°é‡ä¼šå˜å¤šã€‚

1.7è®²äº†é€’å‡½æ•°æŠ½è±¡çš„å…·ä½“åŒ–ï¼šå°†å¤§é—®é¢˜åŒ–è§£ä¸ºå°é—®é¢˜çš„é€’å½’ï¼Œè¿™æ ·å°±å¯ä»¥çœå»æ¯ä¸€æ­¥çš„å…·ä½“å®ç°ã€‚åªéœ€è¦è€ƒè™‘ï¼Œå¦‚ä½•å°†è¿™ä¸ªå¤§é—®é¢˜åŒ–è§£ä¸ºåŒæ ·çš„å‡ ä¸ªè¾ƒå°çš„é—®é¢˜ï¼Œè€Œä¸éœ€è¦è€ƒè™‘è¿™å‡ ä¸ªè¾ƒå°çš„é—®é¢˜å…·ä½“å¦‚ä½•å®ç°ã€‚æ‰€è°“â€œé€’å½’çš„ä¿¡ä»°ä¹‹è·ƒâ€å°±æ˜¯è¿™æ ·ã€‚

å¼€å§‹å­¦ä¹ ç¬¬äºŒç« ï¼Œè¿™ä¸€ç« è®²äº†å¦‚ä½•å°†æ•°æ®åšæˆæŠ½è±¡çš„ã€‚

2.1Introduction

-  å›é¡¾Chapter 1ï¼šcreate functional abstractions by giving names to processes
- è¿™ç« è¦å¹²å˜›ï¼šThe type for most values must be defined by programmers using the means of combination and abstraction that we will develop in this chapter
- The following sections introduce more of Python's native data types, **focusing on the role they play in creating useful data abstractions**.

Listï¼šthe difference between `append()` and `extend()`

- `append()`ï¼šadds a single item to the end of the listï¼ˆå°†å‚æ•°ä¸­çš„åˆ—è¡¨å…ƒç´ çœ‹åšä¸€ä¸ªæ•´ä½“ï¼Œä½œä¸ºä¸€ä¸ªå…ƒç´ æ’å…¥åˆ—è¡¨ä¸­ï¼‰
-  `extend()` ï¼šmethod takes one argument, a list, and appends each of the items of the argument to the original list.ï¼ˆå°†å‚æ•°ä¸­çš„åˆ—è¡¨å…ƒç´ å±•å¼€ï¼Œåˆ†åˆ«æ’å…¥æºåˆ—è¡¨ä¸­ï¼‰

## 4.10

2.2æ•°æ®æŠ½è±¡ğŸ˜‰ï¼ˆå…¶å®æ²¡å¿…è¦è®°å½•è¿™äº›è¯ï¼Œå› ä¸ºå¾ˆå¤šéƒ½æ˜¯åºŸè¯äº†ï¼Œä¸»è¦æ˜¯é€šè¿‡æ¡ˆä¾‹ç†è§£æ€æƒ³ï¼‰

- shield parts of our program that compute using positions from the details of how those positions are represented.
- isolating the parts of a program that deal with how data are represented from the parts that deal with how data are manipulatedï¼ˆå°†æ•°æ®çš„è¡¨ç¤ºå’Œæ•°æ®çš„è¿ç®—å¤„ç†éš”ç¦»-ä½ åªæ˜¯æƒ³è¦è¿™ä¸ªæ•°æ®æ€ä¹ˆç”¨ï¼Œè€Œä¸è€ƒè™‘è¿™ä¸ªæ•°æ®æ˜¯æ€ä¹ˆæ¥çš„ï¼‰
- å›é¡¾chapter1ï¼šWhen we create a functional abstraction, the details of how a function is implemented can be suppressed, and the particular function itself can be replaced by any other function with the same overall behaviorï¼ˆå‡½æ•°æŠ½è±¡ï¼šåªéœ€è¦çŸ¥é“æ€ä¹ˆç”¨å‡½æ•°ï¼Œä¸éœ€è¦è€ƒè™‘å…·ä½“å®ç°ï¼Œåªè¦å®ç°ç›¸åŒçš„è¡Œä¸ºï¼Œå…¶ä»–å‡½æ•°ä¹Ÿå¯ä»¥ï¼‰
- ç‚¹æ˜chapter2ï¼šAnalogously, data abstraction isolates how a compound data value is used from the details of how it is constructed
- In addition, the appropriate relationship must hold among the constructor and selectors
- listå¹¶ä¸æ˜¯å”¯ä¸€è¡¨ç¤ºæœ‰ç†æ•°çš„åˆ†å­åˆ†æ¯çš„å¿…è¦ç»“æ„ï¼Œè‡³äºè¦æœ‰ä¸€å¯¹å€¼çš„ç»“æ„å°±å¯ä»¥ã€‚åé¢å°±ç”¨é«˜é˜¶å‡½æ•°è¯æ˜äº†è¿™ä¸ªã€‚The point of exhibiting the functional representation of a pair is not that Python actually works this way (lists are implemented more directly, for efficiency reasons) but that it could work this way. 

2.2æ€»ç»“ï¼š

æ•°æ®æŠ½è±¡çš„æ„ä¹‰åœ¨äºï¼Œå¯ä»¥å°†ç‰¹å®šçš„æ•°æ®æ“ä½œå’Œè¿™ä¸ªæ•°æ®æ€ä¹ˆå®ç°çš„éš”ç¦»å¼€ï¼Œè¿™æ ·çš„æ•°æ®æŠ½è±¡ä¿è¯äº†ç¨‹åºçš„æ¨¡å—åŒ–å¼€å‘ã€‚

csappï¼š

- registers are used to store integer data as well as pointers.
- effective addressï¼ša computed address
- movæŒ‡ä»¤ï¼šThe **source operand** designates a value that is immediate, stored in a register,
  or stored in memory. The **destination operand** designates a location that is either a
  register or a memory address
- pushing involves decrementing the stack pointer (register %rsp) and storing to memory
- popping involves reading from memory and incrementing the stack pointer.
- leaq:the instruction copies the effective address to the destination.This instruction can be used to generate pointers for later memory references
- leaqå’Œmovqçš„åŒºåˆ«ï¼šmovq s,dçš„ç¬¬ä¸€ä¸ªå‚æ•°å¦‚æœä¸æ˜¯ç«‹å³æ•°æˆ–è€…å¯„å­˜å™¨ï¼Œé‚£ä¹ˆå°†ä¼šä»å¯¹åº”çš„åœ°å€ä¸­æ‰¾åˆ°æ•°æ®ã€‚è€Œleaqåˆ™åªæ˜¯å°†ç¬¬ä¸€ä¸ªå‚æ•°ä½œä¸ºåœ°å€ä¼ é€’ç»™destination operandã€‚

## 4.11

ä»Šå¤©æ—©æ™¨é¦–å…ˆå›é¡¾äº†ä¸‹æœ€è¿‘å‡ å¤©çš„æ—¥æŠ¥ï¼Œå‘ç°è®°å½•å­¦ä¹ çš„è¿›åº¦è›®å¥½çš„ã€‚

å¯¹æ‰€å­¦çŸ¥è¯†è¿›è¡Œç®€å•æ€»ç»“ï¼Œå°±èƒ½åœ¨æ—¥åç¿»é˜…çš„æ—¶å€™å¾ˆå¿«æ£€ç´¢åˆ°å¯¹åº”çš„ä¿¡æ¯ï¼Œçœå»äº†é‡æ–°æ•´ç†çš„æ—¶é—´ã€‚

ä»Šå¤©ä¸»è¦æ˜¯å°†2.3å’Œ2.4èŠ‚ä¸ä¼šçš„å•è¯æŸ¥å‡ºæ¥è€Œå·²ï¼Œæ”¾è½»æ¾ã€‚

å­¦ä¹ 2.3åºåˆ—ä¸€èŠ‚ï¼Œåœ¨å­¦ä¹ ä¹‹å‰ï¼Œå…ˆçœ‹çœ‹è‡ªå·±å¤§æ¦‚è¦å­¦ä»€ä¹ˆï¼Œåšåˆ°å¿ƒä¸­æœ‰æ•°ï¼š[CS61Aé˜…è¯»æŒ‡å—](https://www.cnblogs.com/shangshankandashu/articles/18046806)

2.3Sequences

- A sequence is an ordered collection of values
- many kinds of sequences all share common behavior:length and element selection

10:04-11:30ï¼ˆéå¸¸ç‰›é€¼ï¼ï¼‰

```py
for <name> in <expression>:
    <suite>
```

- `for` loop introduces yet another way in which the environment can be updated by a statement.

```py
>>> pairs = [[1, 2], [2, 2], [2, 3], [4, 4]]
>>> same_count = 0
>>> for x, y in pairs:
        if x == y:
            same_count = same_count + 1
```

A `for` statement may include multiple names in its header to "unpack" each element sequence into its respective elements.

The following `for` statement with two names in its header will bind each name `x` and `y` to the first and second elements in each pair, respectively.

***sequence unpacking***:This pattern of binding multiple names to multiple values in a fixed-length sequence is called *sequence unpacking*

**ranges**:

```py
>>> range(1, 10)  # Includes 1, but not 10
range(1, 10)

>>> for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!
```

Ranges commonly appear as the expression in a `for` header to specify the number of times that the suite should be executed(rangeç”¨æ¥æŒ‡ç¤ºå¾ªç¯çš„æ¬¡æ•°)

```py
>>> odds = [1, 3, 5, 7, 9]
>>> [x+1 for x in odds]
[2, 4, 6, 8, 10]
```

The sub-expression `x+1` is evaluated with `x` bound to each element of `odds` in turn, and the resulting values are collected into a list

```py
>>> apply_to_all = lambda map_fn, s: list(map(map_fn, s))
>>> keep_if = lambda filter_fn, s: list(filter(filter_fn, s))
```

The definitions above are equivalent to applying the `list` constructor to the result of built-in `map` and `filter` calls.

è¿™é‡Œå»ºè®®ç»“åˆä»£ç å°†treeçš„æ¦‚å¿µå¤šæ¥å‡ éï¼š

Closure is the key to power in any means of combination because it permits us to create hierarchical structures â€” structures made up of parts, which themselves are made up of parts, and so on.ï¼ˆlistçš„å…ƒç´ ä¹Ÿç”¨listï¼Œè¿™æ ·çš„ç‰¹æ€§è®©æˆ‘ä»¬æ‹¥æœ‰äº†åˆ›å»ºä½“ç³»ç»“æ„çš„èƒ½åŠ›ï¼‰

A tree has a root label and a sequence of branches. 

Each branch of a tree is a tree. A tree with no branches is called a *leaf*. 

Any tree contained within a tree is called a *sub-tree* of that tree (such as a branch of a branch). The root of each sub-tree of a tree is called a node in that tree.

```py
>>> def tree(root_label, branches=[]):
        for branch in branches:
            assert is_tree(branch), 'branches must be trees'
        return [root_label] + list(branches)
>>> def label(tree):
        return tree[0]
>>> def branches(tree):
        return tree[1:]
    
# åˆ¤æ–­   

>>> def is_tree(tree):
        if type(tree) != list or len(tree) < 1:
            return False
        for branch in branches(tree):
            if not is_tree(branch):
                return False
        return True

>>> def is_leaf(tree):
        return not branches(tree)
```

Tree-recursive functions are also used to process trees. For example, the `count_leaves` function counts the leaves of a tree.

```py
>>> def count_leaves(tree):
      if is_leaf(tree):
          return 1
      else:
          branch_counts = [count_leaves(b) for b in branches(tree)]
          return sum(branch_counts)
>>> count_leaves(fib_tree(5))
8
```

 In a non-leaf partition tree:

- the left (index 0) branch contains all ways of partitioning `n` using at least one `m`,
- the right (index 1) branch contains partitions using parts up to `m-1`, and 
- the root label is `m`.

```py
>>> def partition_tree(n, m):
        """Return a partition tree of n using parts of up to m."""
        if n == 0:
            return tree(True)
        elif n < 0 or m == 0:
            return tree(False)
        else:
            left = partition_tree(n-m, m)
            right = partition_tree(n, m-1)
            return tree(m, [left, right])
>>> partition_tree(2, 2)
[2, [True], [1, [1, [True], [False]], [False]]]
```

ç­‰å›å¤´å†æ¥ç†è§£è¿™ä¸ªé—®é¢˜ï¼Œç°åœ¨æœ‰ç‚¹æ¶å¿ƒçš„ã€‚

csappçš„ç§»ä½æ“ä½œé—®é¢˜:

è‡ªå·±é˜…è¯»ç»†èŠ‚æ²¡åˆ°ä½ã€‚

> With x86-64, a shift instruction operating on data values that are w bits long **determines** the shift amount from the low-order m bits of register `%cl`, where `2^m = w`. The higher-order bits are ignored.
>
> So, for example, when register %cl has hexadecimal value 0xFF, then instruction salb would shift by 7, while salw would shift by 15, sall would shift by 31, and salq would shift by 63.

instructionï¼šsab -- w = 8bits -->m = 3ã€‚

controlï¼š20:00 - 21:40

*traight-line code*ï¼šwhere instructions follow one another in sequence 

Machine code provides two basic low-level mechanisms for implementing conditional behavior: it tests data values and then alters either the control flow or the data flow based on the results of these tests.

`cmp`:ä¸subç±»ä¼¼

`test`ï¼šAND ç±»ä¼¼

## 4.12

ä»Šå¤©ç®€å•æµè§ˆcs61aä»£ç ã€‚

## 4.15

æ–°çš„ä¸€å‘¨åœ¨å»ºé‚ºåŒºå¼€å§‹äº†ã€‚

> ### Q4: Recursive Hailstone
>
> Recall the `hailstone` function from [Homework 1](https://cs61a.org/hw/hw01/). First, pick a positive integer `n` as the start. If `n` is even, divide it by 2. If `n` is odd, multiply it by 3 and add 1. Repeat this process until `n` is 1. Complete this recursive version of `hailstone` that prints out the values of the sequence and returns the number of steps.

```py
def hailstone(n):
    """Print out the hailstone sequence starting at n, 
    and return the number of elements in the sequence.
    >>> a = hailstone(10)
    10
    5
    16
    8
    4
    2
    1
    >>> a
    7
    >>> b = hailstone(1)
    1
    >>> b
    1
    """
    print(n)
    if n % 2 == 0:
        return even(n)
    else:
        return odd(n)

def even(n):
    return 1 + hailstone(n // 2)

def odd(n):
    if n == 1:
        return 1
    else:
        return 1 + hailstone(3 * n + 1)
```

å­¦ä¹ ç‚¹ï¼šæ­¥æ•°è®°å½•

## 4.16

> ### Q2: Digit Distance
>
> For a given integer, the *digit distance* is the sum of the absolute differences between consecutive digits. For example:
>
> - The digit distance of `6` is `0`.
> - The digit distance of `61` is `5`, as the absolute value of `6 - 1` is `5`.
> - The digit distance of `71253` is `12` (`6 + 1 + 3 + 2`).
>
> Write a function that determines the digit distance of a given positive integer. You must use recursion or the tests will fail.

```py
def digit_distance(n):
    """Determines the digit distance of n.

    >>> digit_distance(3)
    0
    >>> digit_distance(777)
    0
    >>> digit_distance(314)
    5
    >>> digit_distance(31415926535)
    32
    >>> digit_distance(3464660003)
    16
    >>> from construct_check import check
    >>> # ban all loops
    >>> check(HW_SOURCE_FILE, 'digit_distance',
    ...       ['For', 'While'])
    True
    """
    if n < 10:
        return 0
    return abs(n % 10 - (n // 10) % 10) + digit_distance(n // 10)
```

å¾…è§£å†³çš„é—®é¢˜ï¼š

- [x] å‡½æ•°è°ƒç”¨æ—¶ï¼ŒæŸ¥çœ‹å…¥å‚åœ¨å“ªå‡ ä¸ªå¯„å­˜å™¨ä¸­ï¼ši ræŸ¥çœ‹å¯„å­˜å™¨
- [x] å‡½æ•°è¿”å›çš„æ—¶å€™ï¼Œè¿”å›å‚æ•°åœ¨å“ªï¼šè°ƒç”¨å®Œæ¯•åï¼ŒæŸ¥çœ‹å“ªä¸ªå¯„å­˜å™¨å­˜æ”¾è¿”å›å€¼

## 4.17

é‡çœ‹2.2èŠ‚

- The general technique of isolating the parts of a program that deal with how data are represented from the parts that deal with how data are manipulated is a powerful design methodology called data abstraction.
- In general, the underlying idea of data abstraction is to identify a basic set of operations in terms of which all manipulations of values of some kind will be expressed, and then to use only those operations in manipulating the data. 
- Abstraction barriers make programs easier to maintain and to modify. The fewer functions that depend on a particular representation, the fewer changes are required when one wants to change that representation.

csappï¼š17ï¼š04å¼€å§‹çœ‹controlä¸€èŠ‚

- two basic low-level mechanisms for implementing conditional
  behavior: it tests data values and then alters either the control flow or the
  data flow based on the results of these tests.
- é¦–å…ˆè®²è§£å®è¡Œæ¡ä»¶åˆ¤æ–­æŒ‡ä»¤çš„ä¸¤ä¸ªæ–¹æ³•ï¼Œç„¶åè®²è§£loopå’Œswitchè¯­å¥
- é¦–å…ˆé™å¿ƒé˜…è¯»å°åœŸåˆ€çš„åšå®¢ï¼Œåšåˆ°å¿ƒä¸­æœ‰æ•°ã€‚
- è¿™å°±å‘ç°äº†ï¼Œå…¶å®è¿™å››ä¸ªæ¡ä»¶ä»£ç ï¼Œæ˜¯ç”¨æ¥æ ‡è®°ä¸Šä¸€æ¡å‘½ä»¤çš„ç»“æœçš„å„ç§å¯èƒ½çš„ï¼Œæ˜¯è‡ªåŠ¨ä¼šè¿›è¡Œè®¾ç½®çš„ã€‚
- rspå¯„å­˜å™¨å­˜æ”¾çš„æ˜¯æ ˆé¡¶çš„åœ°å€ã€‚

3.7èŠ‚

- ç¨‹åºæ˜¯ä¸€ç§æŠ½è±¡
- æœºå™¨çº§ä»£ç ä¸ºäº†æ”¯æŒç¨‹åºè¿è½¬ï¼Œå…·æœ‰control passingã€passing dataå’Œallocating and deallocating memoryçš„åŠŸèƒ½ã€‚
- é€šè¿‡å‡stack pointeråˆé€‚çš„å€¼ï¼Œå°±å¯ç”¨æ¥å­˜æ”¾æ•°æ®
- pè°ƒç”¨qçš„æ—¶å€™ï¼Œä¼šå°†æ‰§è¡Œå®Œæ¯•å‡½æ•°qåçš„ç¨‹åºé‡æ–°å¼€å§‹çš„åœ°å€ä¿å­˜èµ·æ¥ã€‚

## 4.18

> ### Q2: Max Product
>
> Implement `max_product`, which takes a list of numbers and returns the maximum product that can be formed by multiplying together non-consecutive elements of the list. Assume that all numbers in the input list are greater than or equal to 1.

```py
def max_product(s):
    """Return the maximum product of non-consecutive elements of s.

    >>> max_product([10, 3, 1, 9, 2])   # 10 * 9
    90
    >>> max_product([5, 10, 5, 10, 5])  # 5 * 5 * 5
    125
    >>> max_product([])                 # The product of no numbers is 1
    1
    """
    if s == []:
        return 1
    if len(s) == 1:
        return s[0]
    else:
        return max(s[0] * max_product(s[2:]), max_product(s[1:]))
        # OR
        return max(s[0] * max_product(s[2:]), s[1] * max_product(s[3:]))
```

åˆ†æï¼š

- In every case, `max_product` is called on a list of numbers and its return value is treated as a number.
- ç¬¬äºŒä¸ªbase caseçš„ç•™å­˜ï¼šSince this expression never refers to s[1], and s[2:] evaluates to the empty list even for a one-element list `s`, the second base case `(len(s) == 1)` can be omitted if this recursive case is used.

å‘ç°ä¸¤ä¸ªé¢˜ç›®éƒ½æœ‰å¾ˆå¤§çš„æå‡ç©ºé—´ã€‚

æˆ–è®¸åº”è¯¥æ¬£èµä¸‹è¿™ä¸¤ä¸ªé¢˜ç›®ï¼Œå†™ä¸€ä¸ªblogè®°å½•ä¸‹è§£å†³ä¸¤ä¸ªé—®é¢˜çš„å¿ƒè·¯å†ç¨‹ã€‚

å…¶å®ä»Šå¤©ä¸‹åˆæœ‰ç‚¹å¿ƒæ€¥äº†ï¼Œåšå¥½å½“ä¸‹çš„äº‹æƒ…å°±å¥½äº†å®è´ã€‚

> ### Q3: Sum Fun
>
> Implement `sums(n, m)`, which takes a total `n` and maximum `m`. It returns a list of all lists:
>
> 1. that sum to `n`,
> 2. that contain only positive numbers up to `m`, and
> 3. in which no two adjacent numbers are the same.
>
> Two lists with the same numbers in a different order should both be returned.
>
> Here's a recursive approach that matches the template below: build up the `result` list by building all lists that sum to `n` and start with `k`, for each `k` from 1 to `m`. For example, the result of `sums(5, 3)` is made up of three lists:
>
> - `[[1, 3, 1]]` starts with 1,
> - `[[2, 1, 2], [2, 3]]` start with 2, and
> - `[[3, 2]]` starts with 3.
>
> **Hint:** Use `[k] + s` for a number `k` and list `s` to build a list that starts with `k` and then has all the elements of `s`.
>
> ```py
> >>> k = 2
> >>> s = [4, 3, 1]
> >>> [k] + s
> [2, 4, 3, 1]
> ```

```py
def sums(n, m):
    """Return lists that sum to n containing positive numbers up to m that
    have no adjacent repeats.

    >>> sums(5, 1)
    []
    >>> sums(5, 2)
    [[2, 1, 2]]
    >>> sums(5, 3)
    [[1, 3, 1], [2, 1, 2], [2, 3], [3, 2]]
    >>> sums(5, 5)
    [[1, 3, 1], [1, 4], [2, 1, 2], [2, 3], [3, 2], [4, 1], [5]]
    >>> sums(6, 3)
    [[1, 2, 1, 2], [1, 2, 3], [1, 3, 2], [2, 1, 2, 1], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
    """
    if n < 0:
        return []
    if n == 0:
        sums_to_zero = []     # The only way to sum to zero using positives
        return [sums_to_zero] # Return a list of all the ways to sum to zero
    result = []
    # æ¯æ¬¡ç»“æœä»¥kå¼€å¤´
    for k in range(1, m + 1):
        result = result + [ ___ for rest in ___ if rest == [] or ___ ]
    return result
```

é¢˜ç›®åˆ†æï¼š

- ä¸åˆ†å‰²æ•°ç±»ä¼¼ï¼Œä½†æ˜¯åŠ äº†ä¸€ä¸ªé™åˆ¶æ¡ä»¶ï¼Œå³ä¸¤ä¸ªç›¸é‚»çš„æ•°å­—ä¸èƒ½æ˜¯ç›¸åŒçš„ã€‚

- å°†é—®é¢˜é€’æ¨åˆ°æ›´å°çš„é—®é¢˜ï¼š

  åˆ›å»ºä¸€ä¸ªä»`k`å¼€å§‹çš„æ–°åˆ—è¡¨ï¼Œè€Œå‰©ä½™çš„åˆ—è¡¨å…ƒç´ åˆ™æ˜¯æ±‚å’Œä¸º`n-k`çš„åºåˆ—ï¼Œå¹¶ä¸”å‰©ä½™å…ƒç´ çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä¸èƒ½æ˜¯`k`ã€‚

  å‰©ä½™åˆ—è¡¨å…ƒç´ å¯ä»¥è®°å½•ä¸º`rest`ï¼ˆä¾‹å¦‚[1,2,3]ï¼Œå°±å¯ä»¥åˆ†ä¸º[1] + [2,3]ï¼Œå…¶ä¸­`k`ä¸º1ï¼Œ`rest`ä¸º[2,3]ï¼‰ã€‚

  `rest`æ˜¯ä»`sums(n-k, m)`ä¸­è·å–çš„ï¼Œä½†æ˜¯é™åˆ¶æ¡ä»¶ä¸º`rest[0] != k`ï¼Œå³ç¡®ä¿`[k] + rest`åäº§ç”Ÿçš„æ–°åºåˆ—ä¸­ï¼Œç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªç´¢å¼•æ•°æ®ä¸èƒ½å‡ä¸ºä¸º`k`ã€‚

è§£å†³ï¼š

- ç¬¬ä¸€ä¸ªç©ºï¼Œæ‹¼è£…ç»“æœï¼š`[k] + rest`
- ç¬¬äºŒä¸ªç©ºï¼Œ`rest`åˆ—è¡¨çš„æ•°æ®ï¼Œæ˜¯å°†`n`å‡å»`k`åçš„å€¼ï¼Œå†å¯¹`m`è¿›è¡Œ`sum`å¤„ç†åäº§ç”Ÿçš„åˆ—è¡¨ï¼š`sum(n-k,m)`
- ç¬¬ä¸‰ä¸ªç©ºï¼Œé™åˆ¶æ¡ä»¶â€œç›¸é‚»å…ƒç´ ä¸èƒ½ç›¸åŒâ€ï¼š`rest[0] != k`ã€‚

è¦ç›¸ä¿¡é€’å½’çš„ä¿¡ä»°ä¹‹è·ƒã€‚

å¦‚æœä¸çŸ¥é“æ€ä¹ˆå®ç°çš„ï¼Œé‚£å°±ç›¸ä¿¡å®ƒèƒ½å®ç°å°±å¥½äº†ã€‚ğŸ˜ğŸŠ

## 4.19

ä»Šå¤©ç®€å•ä»‹ç»ä¸‹ç¨‹åºçš„æ‰§è¡Œæµç¨‹å§ã€‚

è¿™é‡Œç¡®å®šä¸€ä¸ªç¨‹åºï¼Œè¿›è¡Œå•æ­¥è°ƒè¯•ã€‚

æ˜ç¡®è¦è§£å†³ä»€ä¹ˆé—®é¢˜ï¼š

é¦–å…ˆå°±æ˜¯æ§åˆ¶è½¬ç§»ï¼š

1. ä¸€ä¸ªå‡½æ•°è°ƒç”¨å¦ä¸€ä¸ªå‡½æ•°çš„æ—¶å€™ï¼Œrspå’Œripå‘ç”Ÿäº†ä»€ä¹ˆï¼Œä¸ºä»€ä¹ˆè¿™ä¹ˆåšï¼Ÿ
2. å‡½æ•°è°ƒç”¨è¿”å›çš„æ—¶å€™ï¼Œrspå’Œripå‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ
3. ç”¨æ ˆä¿å­˜è¿”å›åœ°å€ï¼Œé‚£ä¹ˆå‡½æ•°è¿”å›çš„æ—¶å€™æ€ä¹ˆè·å–åˆ°çš„è¿™ä¸ªè¿”å›åœ°å€å‘¢ï¼Ÿ

æ•°æ®è½¬ç§»ï¼š

1. å‚æ•°ä¸€èˆ¬ä¼šæ”¾åœ¨é‚£äº›å¯„å­˜å™¨ä¸­ï¼Ÿ

2. å½“å¤šäºå‚æ•°å¯„å­˜å™¨çš„æ•°é‡çš„å…¥å‚ï¼Œæ€ä¹ˆä¿å­˜å¤šä½™çš„å…¥å‚ï¼Ÿ

3. `char a4, char *a4p`çš„å®é™…å­˜æ”¾åœ°å€ï¼š

   ```assembly
   a4 at %rsp+8 ( 8 bits)
   a4p at %rsp+16 (64 bits)
   ```

   é—®é¢˜ï¼šä¸ºä»€ä¹ˆa4å‚æ•°åœ¨å‰ï¼Œä½†æ˜¯æ”¾åœ¨æ ˆä¸­å°±æ˜¯ä½åœ°å€çš„æ•°æ®ï¼ˆæ›´å®¹æ˜“å­˜å–ï¼‰ï¼Œa4på‚æ•°åœ¨åé¢ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆä¼šè¢«å­˜æ”¾åœ¨æ ˆçš„é«˜åœ°å€å¤„ï¼Ÿ

- `rip` å¯„å­˜å™¨ç”¨äºå­˜å‚¨ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ï¼Œæ§åˆ¶ç¨‹åºçš„æ‰§è¡Œæµç¨‹ï¼›è€Œ `rsp` å¯„å­˜å™¨ç”¨äºç®¡ç†æ ˆç©ºé—´ï¼ŒæŒ‡å‘å½“å‰çº¿ç¨‹çš„æ ˆé¡¶ï¼Œç”¨äºå­˜å‚¨å‡½æ•°è°ƒç”¨ä¿¡æ¯å’Œå±€éƒ¨å˜é‡ç­‰

## 4.21

å­å‡½æ•°è¢«è°ƒç”¨æ—¶å€™åšäº†ä»€ä¹ˆï¼Ÿ

- ä¿å­˜è¿”å›åœ°å€ï¼šä¸ºäº†åœ¨å­å‡½æ•°æ‰§è¡Œå®Œæ¯•åå¯ä»¥ç»§ç»­åŸæ¥çš„è¿›ç¨‹ï¼Œå½“å‰æŒ‡ä»¤çš„ä¸‹ä¸€è¡ŒæŒ‡ä»¤åœ°å€ï¼ˆå³ ip å¯„å­˜å™¨çš„å€¼ï¼‰éœ€è¦å­˜å…¥æ ˆå†…å­˜ã€‚
- æ”¹å˜ç¨‹åºè®¡æ•°å™¨ï¼šå­å‡½æ•°çš„å†…å­˜åœ°å€æ”¾å…¥ipä¸­ï¼Œä»¥ä¾¿äºæ‰§è¡Œå‘½ä»¤ã€‚

## 4.22

> ### Q3: Buying Fruit
>
> Implement `buy`, which takes a list of `required_fruits` (strings), a dictionary `prices` (strings for key, positive integers for value), and a `total_amount` (integer). It prints all the ways to buy some of each required fruit so that the total price equals `total_amount`. You must include at least one of every fruit in `required_fruit` and cannot include any other fruits that are not in `required_fruit`.

> The `display` function will be helpful. You can call `display` on a `fruit` and its `count` to create a string containing both.
>
> What does `fruits` and `amount` represent? How are they used in the recursive?

```py
def buy(required_fruits, prices, total_amount):
    """Print ways to buy some of each fruit so that the sum of prices is amount.

    >>> prices = {'oranges': 4, 'apples': 3, 'bananas': 2, 'kiwis': 9}
    >>> buy(['apples', 'oranges', 'bananas'], prices, 12)
    [2 apples][1 orange][1 banana]
    >>> buy(['apples', 'oranges', 'bananas'], prices, 16)
    [2 apples][1 orange][3 bananas]
    [2 apples][2 oranges][1 banana]
    >>> buy(['apples', 'kiwis'], prices, 36)
    [3 apples][3 kiwis]
    [6 apples][2 kiwis]
    [9 apples][1 kiwi]
    """
    def add(fruits, amount, cart):
        if fruits == [] and amount == 0:
            print(cart)
        elif fruits and amount > 0:
            fruit = fruits[0]
            price = ____
            for k in ____:
                add(____, ____, ____)
    add(required_fruits, total_amount, '')

def display(fruit, count):
    """Display a count of a fruit in square brackets.

    >>> display('apples', 3)
    '[3 apples]'
    >>> display('apples', 1)
    '[1 apple]'
    """
    assert count >= 1 and fruit[-1] == 's'
    if count == 1:
        fruit = fruit[:-1]  # get rid of the plural s
    return '[' + str(count) + ' ' + fruit + ']'
```

æ€è·¯ï¼šåªè¦é’±å¤Ÿç”¨ï¼Œå°±å¯ä»¥ä¹°è¦æ±‚çš„æ°´æœï¼Œæ•°é‡ä¸é™ã€‚

è¿™æ ·çš„é—®é¢˜å°±åˆ†è§£ä¸ºæŒ‘å®Œç¬¬ä¸€ç§æ°´æœä»»æ„æ•°é‡çš„åï¼Œè½¬è€Œç”¨å‰©ä¸‹çš„é’±æŒ‘é€‰ç¬¬äºŒç§æ°´æœä»»æ„æ•°é‡ï¼Œä»¥æ­¤ç±»æ¨ã€‚

disc5ï¼š

> ### Q2: Has Path
>
> Implement `has_path`, which takes a tree `t` and a list `p`. It returns whether there is a path from the root of `t` with labels `p`. For example, `t1` has a path from its root with labels `[3, 5, 6]` but not `[3, 4, 6]` or `[5, 6]`.
>
> **Important**: Before trying to implement this function, discuss these questions from lecture about the recursive call of a tree processing function:
>
> - What recursive calls will you make?
> - What type of values do they return?
> - What do the possible return values mean?
> - How can you use those return values to complete your implementation?

```py
def has_path(t, p):
    """Return whether tree t has a path from the root with labels p.

    >>> t2 = tree(5, [tree(6), tree(7)])
    >>> t1 = tree(3, [tree(4), t2])
    >>> has_path(t1, [5, 6])        # This path is not from the root of t1
    False
    >>> has_path(t2, [5, 6])        # This path is from the root of t2
    True
    >>> has_path(t1, [3, 5])        # This path does not go to a leaf, but that's ok
    True
    >>> has_path(t1, [3, 5, 6])     # This path goes to a leaf
    True
    >>> has_path(t1, [3, 4, 5, 6])  # There is no path with these labels
    False
    """
    if p == [label(t)]:  # when len(p) is 1
        return True
    elif label(t) != p[0]:
        return False
    else:
        "*** YOUR CODE HERE ***"
        return any(has_path(b, p[1:]) for b in branches(t))
```

- **What recursive calls will you make?**

  å¯¹æ¯”å½“å‰æ ‘`t`çš„labelå’Œè·¯å¾„ç¬¬ä¸€ä¸ªå€¼æ˜¯å¦ç›¸åŒï¼Œå¦‚æœç›¸åŒï¼Œå¯¹æ¯”`t`å‰©ä½™åˆ†æ”¯çš„labelæ˜¯å¦ä¸è·¯å¾„å‰©ä½™å…ƒç´ çš„ç¬¬ä¸€ä¸ªå€¼ç›¸åŒã€‚è½¬æ¢ä¸º

  As you usual, you will call `has_path` on each branch `b`. You'll make this call after comparing `p[0]` to `label(t)`, and so the second argument to `has_path` will be the rest of `p`: `has_path(b, p[1:])`.

- **What type of values do they return?**

  bool

csappï¼š

åœ¨ä¸¾ä¾‹`æ‰€ä»¥ call æŒ‡ä»¤å®é™…ä¸Šç­‰åŒäºä¸‹é¢æ“ä½œ:`æ—¶ï¼Œå¯ä»¥è¡¥å……ä¸‹`push %rip`çš„å¯¹åº”æŒ‡ä»¤é›†ï¼š

```assembly
subq $8,%rsp 	#Decrement stack pointer
movq %rip,(%rsp) #Store %rip on stack
```

è¿™é‡Œä½œè€…åº”è¯¥æ˜¯ä¸ºäº†å…·ä½“è®²è§£`call`è€Œæ•…æ„å±è”½æ‰äº†`push`å‘½ä»¤çš„å¤æ‚åº¦ã€‚

`int argc`å’Œ `char *argv[]`ï¼š

`int main(int argc, char *argv[])` æ˜¯ C/C++ ç¨‹åºä¸­ `main` å‡½æ•°çš„æ ‡å‡†ç­¾åï¼Œç”¨äºæ¥æ”¶å‘½ä»¤è¡Œå‚æ•°ã€‚è®©æˆ‘ä»¬åˆ†è§£è¿™ä¸ªå‡½æ•°ç­¾åçš„æ¯ä¸ªéƒ¨åˆ†ï¼ˆ`int argc`å’Œ `char *argv[]`ï¼‰ï¼š

- `int argc`ï¼šæ˜¯è¡¨ç¤ºå‘½ä»¤è¡Œå‚æ•°ä¸ªæ•°çš„æ•´æ•°ç±»å‹å‚æ•°ï¼Œå³ argument countã€‚`argc` çš„å€¼è‡³å°‘ä¸º `1`ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç¨‹åºæœ¬èº«çš„åç§°ï¼Œåé¢å¯ä»¥è·Ÿéšé›¶ä¸ªæˆ–å¤šä¸ªå‘½ä»¤è¡Œå‚æ•°ã€‚
- `char *argv[]`ï¼šæ˜¯ä¸€ä¸ªæŒ‡å‘å­—ç¬¦æŒ‡é’ˆæ•°ç»„çš„å‚æ•°ï¼Œå³ argument vectorã€‚`argv` ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªæŒ‡å‘ä»¥ç©ºå­—ç¬¦ `\0` ç»“å°¾çš„å­—ç¬¦ä¸²çš„æŒ‡é’ˆï¼Œè¡¨ç¤ºä¸€ä¸ªå‘½ä»¤è¡Œå‚æ•°ã€‚

ç»¼åˆèµ·æ¥ï¼Œ`int main(int argc, char *argv[])` çš„æ„æ€æ˜¯å®šä¹‰ä¸€ä¸ª `main` å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸¤ä¸ªå‚æ•°ï¼š`argc` è¡¨ç¤ºå‘½ä»¤è¡Œå‚æ•°ä¸ªæ•°ï¼Œ`argv` æ˜¯ä¸€ä¸ªæŒ‡é’ˆæ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸€ä¸ªå‘½ä»¤è¡Œå‚æ•°ã€‚

ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾ä½ åœ¨å‘½ä»¤è¡Œä¸­è¾“å…¥ `./program arg1 arg2`ï¼Œé‚£ä¹ˆåœ¨ç¨‹åºä¸­ `argc` çš„å€¼ä¸º `3`ï¼Œ`argv[0]` æ˜¯ç¨‹åºåç§° `"./program"`ï¼Œ`argv[1]` æ˜¯å‚æ•° `"arg1"`ï¼Œ`argv[2]` æ˜¯å‚æ•° `"arg2"`ã€‚

## 4.23

- [ ] æœç´¢é¬¼ç‰‡

ä¸ºä»€ä¹ˆæˆ‘çš„ç›²æ‰“è¿˜æ˜¯å¾ˆæ…¢ï¼Ÿè®­ç»ƒäº†è¿™ä¹ˆä¹…ï¼Œå¥½åƒæ²¡æœ‰è¾¾åˆ°ç›¸åº”çš„é¢„æœŸã€‚

ç­”ï¼šç°åœ¨åŠ å…¥æ–°çš„ç»ƒä¹ ç½‘ç«™[typingclub](https://www.typingclub.com/sportal/)ï¼Œé‡Œé¢çš„ä¸­æ–‡ç‰¹æ®Šè®­ç»ƒè¯¾ç¨‹å·²ç»åŠ å…¥äº†è®­ç»ƒè®¡åˆ’ä¸­ã€‚

hw04ä¸­ï¼Œå¯¹äºbalancedçš„ä»£ç ï¼Œæˆ‘è§‰å¾—å†™å¾—è›®ä¸é”™çš„ï¼Œè´´ä¸€ä¸‹ï¼Œç­‰ä¼šå‘å¸–å­ã€‚

> Q3: Balanced
> Implement the balanced function, which returns whether m is a balanced mobile. A mobile is balanced if both of the following conditions are met:
>
> The torque applied by its left arm is equal to the torque applied by its right arm. The torque of the left arm is the length of the left rod multiplied by the total mass hanging from that rod. Likewise for the right. For example, if the left arm has a length of 5, and there is a mobile hanging at the end of the left arm of total mass 10, the torque on the left side of our mobile is 50.
> Each of the mobiles hanging at the end of its arms is itself balanced.
> Planets themselves are balanced, as there is nothing hanging off of them.

```py
def torque(len, mass):
    return len * mass

def torque_of_arm(arm):
    len = length(arm)
    mass = total_mass(end(arm))
    return torque(len, mass)

def balanced(m):
    """Return whether m is balanced.

    >>> t, u, v = examples()
    >>> balanced(t)
    True
    >>> balanced(v)
    True
    >>> p = mobile(arm(3, t), arm(2, u))
    >>> balanced(p)
    False
    >>> balanced(mobile(arm(1, v), arm(1, p)))
    False
    >>> balanced(mobile(arm(1, p), arm(1, v)))
    False
    >>> from construct_check import check
    >>> # checking for abstraction barrier violations by banning indexing
    >>> check(HW_SOURCE_FILE, 'balanced', ['Index'])
    True
    """
    "*** YOUR CODE HERE ***"
    def is_torque_balanced(mobile):
        left_torque = torque_of_arm(left(mobile))
        right_torque = torque_of_arm(right(mobile))
        return left_torque == right_torque

    if is_planet(m):
        return True
   
    if is_torque_balanced(m):
        return balanced(end(left(m))) and balanced(end(right(m)))
    else:
        return False
```

åˆ†ææˆ‘è§‰å¾—ç‰›é€¼åœ¨å“ªé‡Œã€‚ğŸ˜

ç‰›é€¼åœ¨å°†åŠ›çŸ©çš„å…·ä½“å®ç°å’Œåˆ¤æ–­æ¨¡å‹çš„åŠ›çŸ©æ˜¯å¦å¹³è¡¡åˆ†å¼€äº†ã€‚è¿™æ ·çš„å¥½å¤„æ˜¯åˆ¤æ–­åŠ›çŸ©æ˜¯å¦å¹³è¡¡çš„å‡½æ•°`is_torque_balanced(mobile)`åªéœ€è¦å…³æ³¨`mobile`çš„å…·ä½“å®ç°ï¼Œè€Œä¸éœ€è¦å…³å¿ƒåŠ›çŸ©çš„å…·ä½“å®ç°ã€‚ï¼ˆå‡½æ•°æŠ½è±¡çš„ä½œç”¨ï¼‰

csappå•æ­¥è°ƒè¯•ï¼š

```bash
(gdb) bt
#1  0x0000000000401347 in strings_not_equal ()
#2  0x0000000000400eee in phase_1 ()
#3  0x0000000000400e3f in main (argc=<optimized out>, argv=<optimized out>) at bomb.c:74
```

è¿™é‡Œçš„æ‰§è¡Œæµç¨‹ä¸ºï¼š

```c
    /* Hmm...  Six phases must be more secure than one phase! */
    input = read_line();             /* Get input                   */
    phase_1(input);                  /* Run the phase               */
    phase_defused();                 /* Drat!  They figured it out!
				      * Let me know how they did it. */
    printf("Phase 1 defused. How about the next one?\n");
```

å¯ä»¥å‘ç°åªæœ‰`phase_1`æ­£å¸¸è¿”å›çš„æ—¶å€™ï¼Œæ‰ä¼šæ‰§è¡Œä¸‹é¢çš„`phase_defused()`å‡½æ•°å°†é˜¶æ®µ1çš„ç‚¸å¼¹æ‹†é™¤ã€‚ç°åœ¨å°±æƒ³è®©`phase_1`æ­£å¸¸æ‰§è¡Œå®Œï¼Œé‚£å°±éœ€è¦è®©æ­¤å‡½æ•°ä¸­æ‰€æœ‰ä¸æ­£å¸¸çš„è·³è½¬éƒ½ä¸æ‰§è¡Œã€‚

é¦–å…ˆæŸ¥çœ‹`phase_1`å‡½æ•°çš„æ±‡ç¼–ä»£ç ï¼š

```assembly
(gdb) disassemble phase_1
Dump of assembler code for function phase_1:
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi               #0x402400 --> %esi
   0x0000000000400ee9 <+9>:     call   0x401338 <strings_not_equal> #è°ƒç”¨strings_not_equalå‡½æ•°
   0x0000000000400eee <+14>:    test   %eax,%eax                    
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>		#å¦‚æœ%eaxå€¼ä¸º0ï¼Œåˆ™æ­£å¸¸è¿”å›
   0x0000000000400ef2 <+18>:    call   0x40143a <explode_bomb>		#å¦‚æœ%eaxå€¼ä¸ä¸º0ï¼Œåˆ™è§¦å‘ç‚¸å¼¹
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    ret
```

`test` æŒ‡ä»¤å°† `%eax` å¯„å­˜å™¨çš„å€¼ä¸è‡ªèº«è¿›è¡Œé€»è¾‘ä¸æ“ä½œï¼Œå¹¶è®¾ç½®æ ‡å¿—ä½ï¼Œä½†ä¸ä¿®æ”¹ `%eax` çš„å€¼ã€‚å¦‚æœ `%eax` çš„å€¼ä¸ºé›¶ï¼Œåˆ™æ ‡å¿—ä½ä¼šè¢«ç½®ä¸ºé›¶ï¼›å¦‚æœ `%eax` çš„å€¼ä¸ä¸ºé›¶ï¼Œåˆ™æ ‡å¿—ä½ä¼šè¢«ç½®ä¸ºéé›¶ã€‚

å¦‚æœæƒ³è®©ç¨‹åºæ­£å¸¸æ‰§è¡Œï¼Œé‚£ä¹ˆå°±éœ€è¦è®©è·å¾—`%esi`å¯„å­˜å™¨å€¼çš„å‡½æ•°`strings_not_equal`è¿”å›å€¼ä¸º0ã€‚

ä¸‹é¢æŸ¥çœ‹å‡½æ•°`strings_not_equal`çš„ä»£ç ï¼Œå¹¶ä¸”åˆ†æä¸‹ä¸»è¦çš„æ§åˆ¶ä»£ç ï¼Œçœ‹çœ‹å¦‚ä½•è®©è¿”å›å€¼ä¸º0ï¼š

## 4.24

```assembly
(gdb) disassemble strings_not_equal 
Dump of assembler code for function strings_not_equal:
   0x0000000000401338 <+0>:     push   %r12
   0x000000000040133a <+2>:     push   %rbp
   0x000000000040133b <+3>:     push   %rbx
   0x000000000040133c <+4>:     mov    %rdi,%rbx						
   0x000000000040133f <+7>:     mov    %rsi,%rbp
   0x0000000000401342 <+10>:    call   0x40131b <string_length>			# å°†%rbxå’Œ %rbpä¼ å…¥å‡½æ•°string_length
   0x0000000000401347 <+15>:    mov    %eax,%r12d						# ç¬¬ä¸€æ¬¡è¿”å›å€¼%eaxèµ‹ç»™ %r12d
   0x000000000040134a <+18>:    mov    %rbp,%rdi						# %rbp â€”> %rdi
   0x000000000040134d <+21>:    call   0x40131b <string_length>			# %rdiçš„å€¼ä½œä¸ºå…¥å‚	
   0x0000000000401352 <+26>:    mov    $0x1,%edx
   0x0000000000401357 <+31>:    cmp    %eax,%r12d 						# å¯¹æ¯”ä¸¤æ¬¡å‡½æ•°é•¿åº¦è°ƒç”¨çš„ç»“æœ
   0x000000000040135a <+34>:    jne    0x40139b <strings_not_equal+99>  # è‹¥é•¿åº¦ä¸åŒï¼Œè¿”å›1
   
   # ä»¥ä¸Šä»£ç å‡ä¸ºåˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦æ˜¯å¦ç›¸åŒï¼Œç°åœ¨çš„%r12dã€%eaxåˆ†åˆ«ä¿å­˜äº†ç¬¬ä¸€æ¬¡å’Œç¬¬äºŒæ¬¡çš„å‡½æ•°è°ƒç”¨ç»“æœï¼Œå³ä¸¤ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦
   # å¯„å­˜å™¨rbx å’Œ rbp åˆ†åˆ«ä¿å­˜ç€å‡½æ•°çš„ä¸¤ä¸ªå‚æ•°
   
   # 35c-41:è‹¥å‡½æ•°ç¬¬ä¸€ä¸ªå‚æ•°ä½8ä½ä¸º0ï¼Œåˆ™è¿”å›0
   0x000000000040135c <+36>:    movzbl (%rbx),%eax						# å‚æ•°1çš„ä½1ä½å­—èŠ‚èµ‹å€¼ç»™eax
   0x000000000040135f <+39>:    test   %al,%al							# %al & %al
   0x0000000000401361 <+41>:    je     0x401388 <strings_not_equal+80>  # Jump condition:ZF---(Equal / zero)
   # 35c-37f:å¯¹æ¯”å‚æ•°1å’Œå‚æ•°2çš„æ¯ä¸ªå­—èŠ‚ï¼Œç›´åˆ°å‘ç°ä¸ç›¸ç­‰çš„å­—ç¬¦æˆ–è€…åˆ°è¾¾å­—ç¬¦ä¸²ç»“å°¾
   0x0000000000401363 <+43>:    cmp    0x0(%rbp),%al					# å‚æ•°2çš„ä½1ä½å­—èŠ‚ä¸æ•°1çš„ä½1ä½å­—èŠ‚å¯¹æ¯”
   0x0000000000401366 <+46>:    je     0x401372 <strings_not_equal+58>	# å¦‚æœç›¸ç­‰ï¼Œåˆ™å¯¹æ¯”æ›´é«˜1ä½çš„å­—èŠ‚
   0x0000000000401368 <+48>:    jmp    0x40138f <strings_not_equal+87>  # ä¸ç›¸ç­‰ï¼Œè¿”å›é”™è¯¯1
   0x000000000040136a <+50>:    cmp    0x0(%rbp),%al					
   0x000000000040136d <+53>:    nopl   (%rax)
   0x0000000000401370 <+56>:    jne    0x401396 <strings_not_equal+94> #è‹¥å‚æ•°1ã€2çš„ç¬¬2ä¸ªå­—èŠ‚ä¸åŒï¼Œåˆ™è¿”å›é”™è¯¯1
   0x0000000000401372 <+58>:    add    $0x1,%rbx
   0x0000000000401376 <+62>:    add    $0x1,%rbp
   0x000000000040137a <+66>:    movzbl (%rbx),%eax
   0x000000000040137d <+69>:    test   %al,%al
   0x000000000040137f <+71>:    jne    0x40136a <strings_not_equal+50>
   
   
   0x0000000000401381 <+73>:    mov    $0x0,%edx
   0x0000000000401386 <+78>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401388 <+80>:    mov    $0x0,%edx
   0x000000000040138d <+85>:    jmp    0x40139b <strings_not_equal+99>
   0x000000000040138f <+87>:    mov    $0x1,%edx
   0x0000000000401394 <+92>:    jmp    0x40139b <strings_not_equal+99>
   0x0000000000401396 <+94>:    mov    $0x1,%edx
   0x000000000040139b <+99>:    mov    %edx,%eax
   0x000000000040139d <+101>:   pop    %rbx
   0x000000000040139e <+102>:   pop    %rbp
   0x000000000040139f <+103>:   pop    %r12
   0x00000000004013a1 <+105>:   ret    
End of assembler dump.
```

è¿™é‡Œçš„å‡ ä¸ªæ¯”è¾ƒé‡è¦çš„è·³è½¬ä»£ç ï¼š

`0x40139b <strings_not_equal+99>`ï¼šå‡½æ•°å°†ä»¥`%edx`ä½œä¸ºè¿”å›å€¼è¿”å›ã€‚ 

`0x401388 <strings_not_equal+80>`ï¼šè¿”å›0ã€‚

`0x40136a <strings_not_equal+50>`ï¼šæ¯”è¾ƒ `%al` å¯„å­˜å™¨ä¸­çš„å€¼ä¸ `%rbp` å¯„å­˜å™¨åç§» 0 çš„å†…å­˜åœ°å€å¤„çš„å€¼ï¼Œå¦‚æœä¸ç›¸ç­‰ï¼Œåˆ™è·³è½¬åˆ°åœ°å€ `0x401396` å¤„æ‰§è¡Œç›¸åº”çš„ä»£ç ï¼ˆå‡½æ•°ä¼šè¿”å›1ï¼‰ï¼Œå¦åˆ™ç»§ç»­æ‰§è¡Œåç»­æŒ‡ä»¤ã€‚

é‡ç‚¹ç†è§£çš„æŒ‡ä»¤æœ‰ï¼š

- `test S1, S2`ï¼šç›¸å½“äº`S1&S2`ï¼Œè‹¥ç»“æœä¸º0ï¼Œåˆ™è®¾ç½®ZFä¸º1
- `jmp`çš„æ‰€æœ‰æŒ‡ä»¤ã€‚é‡ç‚¹æœ‰`je`ï¼Œjump conditionä¸º`ZF = 1`
- `movzbl`ï¼š0æ‹“å±•æ•°æ®ã€‚Move zero-extended **byte** to **double** wordï¼ˆ`movz S,R`ï¼š R â† ZeroExtend(S)ï¼‰

ç»¼ä¸Šï¼Œå¯ä»¥å¾—çŸ¥å¦‚æœæƒ³æ‹†é™¤é˜¶æ®µ1çš„ç‚¸å¼¹ï¼Œåˆ™éœ€è¦è¾“å…¥åˆç†çš„å­—ç¬¦ä¸²ï¼Œè€Œè¿™ä¸ªå­—ç¬¦ä¸²å¯ä»¥é€šè¿‡ä»¥ä¸‹åˆ†æå¾—å‡ºï¼š

1. æŸ¥çœ‹`phase_1`å‡½æ•°çš„æ±‡ç¼–ä»£ç ï¼Œå‘ç°å…¥å‚`%rdi`éœ€è¦è·Ÿå¦ä¸€ä¸ªå‚æ•°`0x402400 --> %rsi`è¿›å…¥å‡½æ•°`strings_not_equal `è¿›è¡Œè®¡ç®—ï¼Œè‹¥ç»“æœä¸º0ï¼Œåˆ™å¯ä»¥æ‹†é™¤ç‚¸å¼¹ï¼Œå¦åˆ™çˆ†ç‚¸ã€‚
2. æŸ¥çœ‹`strings_not_equal `å‡½æ•°çš„æ±‡ç¼–ä»£ç ï¼Œå¯ä»¥åˆ†æå‡ºæ­¤å‡½æ•°æ˜¯å°†å…¥å‚å¯„å­˜å™¨ï¼ˆ`%rdi`å’Œ`%rsi`ï¼‰æ‰€æŒ‡åœ°å€å¤„çš„å­—ç¬¦ä¸²è¿›è¡Œæ¯”å¯¹ï¼Œå¦‚æœé•¿åº¦ç›¸åŒå¹¶ä¸”æ¯ä¸ªå­—éƒ½ç›¸åŒï¼ˆæŒ‰ç…§å­—èŠ‚å¯¹æ¯”ï¼‰ï¼Œåˆ™è¿”å›0

é€šè¿‡ä¸Šé¢ä¸¤ä¸ªå‡½æ•°çš„åˆ†æï¼Œå°±å¯ä»¥å¾—çŸ¥æˆ‘ä»¬æ‰€è¾“å…¥çš„å­—ç¬¦ä¸²ï¼Œéœ€è¦è·Ÿåœ°å€ä¸º`0x402400`å¤„çš„å­—ç¬¦ä¸²è¿›è¡Œæ¯”å¯¹ï¼Œæ¯”å¯¹æˆåŠŸåˆ™ç‚¸å¼¹æ‹†é™¤ã€‚

é‚£è¿™æ ·ï¼Œé€šè¿‡gdbçš„å‘½ä»¤`x/s 0x402400`ï¼ŒGDB ä¼šè¯»å–å†…å­˜åœ°å€ `0x402400` å¤„å¼€å§‹çš„è¿ç»­å­—èŠ‚ï¼Œç›´åˆ°é‡åˆ°å­—ç¬¦ä¸²ç»“æŸç¬¦ï¼ˆ`\0`ï¼Œç©ºå­—ç¬¦ï¼‰ï¼Œç„¶åå°†è¿™äº›å­—èŠ‚è§£é‡Šä¸ºå­—ç¬¦ä¸²å¹¶æ‰“å°å‡ºæ¥ã€‚

`Border relations with Canada have never been better.`

```py
(gdb) x/s 0x402400                                                                                                                                           
0x402400:       "Border relations with Canada have never been better."
				#translationï¼šè¾¹å¢ƒä¸åŠ æ‹¿å¤§çš„å…³ç³»ä»æœªå¦‚æ­¤è‰¯å¥½ã€‚
```

## 4.25

æ—©æ™¨å‘ç°è‡ªå·±çš„gitåˆæ²¡æ³•æäº¤äº†ã€‚

è§£å†³åŠæ³•æ˜¯åˆ é™¤å·¥ä½œç›®å½•ï¼Œ[è®¾ç½®sshå¯†é’¥é…å¯¹](https://www.cnblogs.com/shangshankandashu/p/18099444)ï¼Œç„¶å`git clone`å¯¹åº”çš„ä»£ç ã€‚

ç„¶è€Œgdbåœ¨è¿è¡Œ`bomb`æ–‡ä»¶çš„æ—¶å€™ï¼Œæç¤ºæ²¡æœ‰æƒé™ï¼š

```bash
(gdb) r                                                                               
Starting program: /home/crx/study/csapp/03machine_prog/bomb/bomb                      
/bin/bash: line 1: /home/crx/study/csapp/03machine_prog/bomb/bomb: Permission denied  
/bin/bash: line 1: exec: /home/crx/study/csapp/03machine_prog/bomb/bomb: cannot execute: Permission denied
During startup program exited with code 126.        
```

å¯ä»¥çœ‹å‡ºåœ¨è¿è¡Œ`bomb`æ–‡ä»¶çš„æ—¶å€™ï¼Œæç¤ºæˆ‘æ²¡æœ‰æ‰§è¡Œæ­¤æ–‡ä»¶çš„æƒé™ã€‚è§£å†³æ–¹æ³•å°±æ˜¯ä¿®æ”¹è¿™ä¸ªæ–‡ä»¶çš„æƒé™ï¼Œä½†æ˜¯æˆ‘å¸Œæœ›`/home/crx/study`è¿™ä¸ªç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶éƒ½å¯ä»¥ç”¨æ™®é€šç”¨æˆ·çš„æƒé™å»æ‰§è¡Œä½¿ç”¨ï¼Œè¿™æ ·å°±å°†ç›®æ ‡æ–‡ä»¶å¤¹`/home/crx/study`ä¸‹çš„æ‰€æœ‰æ–‡ä»¶å’Œå­ç›®å½•çš„æ‰€æœ‰è€…æ”¹ä¸ºç›®æ ‡ç”¨æˆ·ã€‚

**æ”¹å˜æ‰€æœ‰è€…ï¼š** ä½¿ç”¨ `chown` å‘½ä»¤å°†ç›®æ ‡æ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰æ–‡ä»¶å’Œå­ç›®å½•çš„æ‰€æœ‰è€…æ”¹ä¸ºç›®æ ‡ç”¨æˆ·ã€‚å‡è®¾ç›®æ ‡ç”¨æˆ·ä¸º `username`ï¼Œç›®æ ‡æ–‡ä»¶å¤¹è·¯å¾„ä¸º `/path/to/directory`ï¼Œåˆ™å‘½ä»¤å¦‚ä¸‹ï¼š

```bash
sudo chown -R username:username /path/to/directory
```

ç„¶åå°±æ˜¯**ä¿®æ”¹æƒé™ï¼š** ä½¿ç”¨ `chmod` å‘½ä»¤ä¿®æ”¹ç›®æ ‡æ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰æ–‡ä»¶å’Œå­ç›®å½•çš„æƒé™ï¼Œç¡®ä¿ç›®æ ‡ç”¨æˆ·å…·æœ‰è¯»å†™æ‰§è¡Œæƒé™ã€‚å‡è®¾ä½ å¸Œæœ›ç›®æ ‡ç”¨æˆ·æœ‰æ‰€æœ‰æƒé™ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š

```bash
sudo chmod -R u+rwx /path/to/directory
```

è¿™é‡Œçš„ `-R` å‚æ•°åŒæ ·è¡¨ç¤ºé€’å½’æ“ä½œã€‚

æ‰§è¡Œä»¥ä¸Šæ­¥éª¤åï¼Œç›®æ ‡ç”¨æˆ·å°±å¯ä»¥ä½¿ç”¨è¯¥æ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰æ–‡ä»¶äº†ï¼Œå¹¶ä¸”å…·æœ‰è¯»ã€å†™å’Œæ‰§è¡Œçš„æƒé™ã€‚

boom lab-phase2ï¼š

gdbç”¨æ³•ï¼š

- gdbå¦‚ä½•ç»™ç‰¹å®šåœ°å€æ‰“æ–­ç‚¹ï¼š`break *0x12345678`
- è¾“å‡ºå•ç‹¬å¯„å­˜å™¨çš„å€¼ï¼š `print $eax`

åæ±‡ç¼–å’Œåç¼–è¯‘ï¼š

**åæ±‡ç¼–ï¼ˆDisassemblyï¼‰ï¼š** åæ±‡ç¼–æ˜¯å°†æœºå™¨ä»£ç è½¬æ¢ä¸ºæ±‡ç¼–è¯­è¨€çš„è¿‡ç¨‹ã€‚

**åç¼–è¯‘ï¼ˆDiscompilationï¼‰**:åç¼–è¯‘æ˜¯å°†æœºå™¨ä»£ç è½¬æ¢ä¸ºé«˜çº§è¯­è¨€ï¼ˆä¾‹å¦‚ Cã€C++ã€Python ç­‰ï¼‰çš„è¿‡ç¨‹ã€‚

å¼€å§‹ä¸‹æ–­ç‚¹`b phase_2`ï¼Œå•æ­¥æ‰§è¡Œï¼Œåæ±‡ç¼–å½“å‰å‡½æ•°ï¼Œæ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼š

```assembly
(gdb) disassemble 
Dump of assembler code for function phase_2:
=> 0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi		#å°†æ ˆæŒ‡é’ˆä¿å­˜åˆ°%rsiä¸­
   0x0000000000400f05 <+9>:     call   0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    call   0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    ret    
End of assembler dump.
```

åˆ†æè¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½ï¼š

è¿™é‡Œ<+6>è¡Œçš„`mov    %rsp,%rsi`çš„ç›®çš„æ˜¯ä¿å­˜`caller`ä¸­æ ˆé¡¶çš„ä½ç½®ï¼Œæ–¹ä¾¿åœ¨`read_six_numbers`ä¸­è¿›è¡Œæ”¹å€¼ã€‚

å‡½æ•°åªæœ‰åœ¨å¯„å­˜å™¨%rspæ‰€æŒ‡çš„å†…å­˜æ•°æ®ä¸º0x1çš„æ—¶å€™ï¼Œæ‰ä¸ä¼šå¼•çˆ†ç‚¸å¼¹ï¼Œè€Œæ ˆæŒ‡é’ˆ `%rsp` å°±æ˜¯ç”¨æ¥æŒ‡ç¤ºå½“å‰æ ˆé¡¶ä½ç½®çš„å¯„å­˜å™¨ã€‚ç­‰æ•ˆäºæ ˆé¡¶æ•°æ®æ˜¯å¦ä¸º1ã€‚

å‡è®¾ç°åœ¨æ ˆé¡¶æ•°æ®ä¸º1ï¼ˆ`(%rsp) == 0x1`ï¼‰ï¼Œåˆ™ä¸ä¼šå¼•çˆ†ç‚¸å¼¹ï¼Œè€Œæ˜¯ä¼šè°ƒç”¨`+52`è¡Œçš„ä»£ç ï¼Œå³ï¼š

> `lea    0x4(%rsp),%rbx`ï¼šå°†%rspçš„å€¼åŠ 4ï¼ˆdecï¼‰ï¼Œç„¶åèµ‹å€¼ç»™å¯„å­˜å™¨%rbxã€‚
>
> `lea    0x18(%rsp),%rbp`ï¼šå°†%rspçš„å€¼åŠ 24ï¼ˆdecï¼‰ï¼Œç„¶åèµ‹å€¼ç»™å¯„å­˜å™¨%rbpã€‚

ç»™%rbxå’Œ%rbpé‡æ–°èµ‹å€¼ï¼Œæ­¤æ—¶%rbx = %rsp + 4ï¼Œ %rbp =  %rsp + 18ã€‚

è¿™é‡Œå¯ä»¥é€šè¿‡å‡½æ•°`read_six_numbers`æ¨æµ‹å‡ºï¼Œæ ˆé¡¶ä¿å­˜çš„æ•°æ®æ˜¯ç¬¬ä¸€ä¸ªintç±»å‹æ•°æ®ï¼Œæ‰€å ç©ºé—´ä¸º4bytesï¼Œç„¶åä»æ ˆé¡¶å¼€å§‹å‘é«˜ä½åœ°å€å¤„è¿ç»­6ä¸ªintæ•°æ®ï¼Œå°±æ˜¯æ­¤å‡½æ•°çš„6ä¸ªè¿”å›å€¼ã€‚

éšåè·³è½¬è°ƒç”¨`<phase_2+27>`å¤„çš„ä»£ç ï¼š

```assembly
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax		#ï¼ˆ%rsp + 4 - 4ï¼‰-->%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax			#%eax = 2 %eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)			#(%rsp + 4) - %eax
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>	#å¦‚æœç›¸ç­‰ï¼Œåˆ™ä¸çˆ†ç‚¸
   0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb>
```

æ­¤æ—¶ä¸çˆ†ç‚¸çš„æ¡ä»¶æ˜¯ï¼šæ ˆ(%rsp + 4)å¤„çš„æ•°æ®ï¼ˆç¬¬äºŒä¸ªå‚æ•°ï¼‰ç­‰äºä¸¤å€çš„æ ˆé¡¶ï¼ˆ%rspï¼‰çš„æ•°æ®ã€‚

å‡è‹¥æ­¤æ—¶ä¸çˆ†ç‚¸ï¼Œåˆ™ç¨‹åºåˆä¼šè·³è½¬åˆ°`<phase_2+41>`å¤„æ‰§è¡Œï¼š

```assembly
   0x0000000000400f25 <+41>:    add    $0x4,%rbx			# %rbx = %rsp + 8
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx			#todoï¼šä¸ºä»€ä¹ˆè¦å¯¹æ¯”%rbp,%rbxï¼Ÿ
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
```

åˆ†æä¸‹ä¸ºä»€ä¹ˆ`cmp    %rbp,%rbx`ï¼šè¿™é‡Œ`%rbx`çš„ä½œç”¨æ˜¯ä½œä¸º6ä¸ªå‚æ•°çš„æŒ‡é’ˆï¼Œè€Œ`%rbp`ä¿å­˜çš„æ˜¯ç¬¬6ä¸ªå‚æ•°çš„ä½ç½®ã€‚æ¯”è¾ƒä¸¤è€…çš„å¤§å°å°±æ˜¯ç¡®è®¤æ˜¯å¦æŒ‡é’ˆç´¢å¼•åˆ°äº†æœ€åä¸€ä¸ªå‚æ•°ã€‚

æ­¤æ—¶%rbx = %rsp + 8ã€‚å¦‚æœè¿˜æ²¡åˆ°æœ€åä¸€ä¸ªå‚æ•°ï¼Œé‚£ä¹ˆé‡æ–°è·³è½¬åˆ°`<phase_2+27>`å¤„çš„ä»£ç ï¼š

```assembly
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax		#ï¼ˆ%rsp + 4ï¼‰-->%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax			#%eax = 2 * %eax = 2 * (%rsp + 4)
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)			#(%rsp + 8) == 2 * (%rsp + 4)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>	#å¦‚æœç›¸ç­‰ï¼Œåˆ™ä¸çˆ†ç‚¸
   0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb>
```

è¿™é‡Œ` cmp    %eax,(%rbx)			#(%rsp + 8) == 2 * (%rsp + 4)`å¯ä»¥å¾—çŸ¥ï¼šç¬¬ä¸‰ä¸ªå‚æ•°éœ€è¦ä¸ºç¬¬äºŒä¸ªå‚æ•°çš„ä¸¤å€ã€‚

å¦‚æ­¤å¾ªç¯å¾€å¤ï¼Œç›´åˆ°æœ€åä¸€ä¸ªå‚æ•°ã€‚è‹¥æ ˆé¡¶æ•°æ®ä¸ºaï¼Œåˆ™å…¶ä½™æ•°æ®åˆ†åˆ«ä¸º2aï¼Œ4aï¼Œ8aï¼Œ16aï¼Œ32aã€‚è¿™æ—¶å€™ç¨‹åºä¼šæ‰§è¡Œ`jmp    0x400f3c <phase_2+64>`ï¼Œåˆ°`phase_2+64`ä½ç½®ç»§ç»­æ‰§è¡ŒæŒ‡ä»¤ï¼š

```assembly
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    ret   
```

è¿™é‡Œå°±æ˜¯å›æ”¶æ ˆç©ºé—´ï¼Œå‡½æ•°æ­£å¸¸è¿”å›äº†ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨å‡½æ•°` call   0x40145c <read_six_numbers>`å®Œæ¯•åçš„æ¯”è¾ƒè¯­å¥ï¼Œä»¥åŠä¸Šè¿°åˆ†æçš„åç»­è¯­å¥æ¨æµ‹å‡½æ•°`read_six_numbers`çš„åŠŸèƒ½å°±æ˜¯è¿”å›ä¸€ä¸ªä»1å¼€å§‹çš„ç­‰æ¯”åºåˆ—ã€‚

## 4.26

çœ‹ä¸‹è¿™ä¸ªå‡½æ•°`read_six_numbers`çš„å…·ä½“æ‰§è¡Œï¼š

```assembly
(gdb) disassemble 
Dump of assembler code for function read_six_numbers:
=> 0x000000000040145c <+0>:     sub    $0x18,%rsp
   0x0000000000401460 <+4>:     mov    %rsi,%rdx
   0x0000000000401463 <+7>:     lea    0x4(%rsi),%rcx
   0x0000000000401467 <+11>:    lea    0x14(%rsi),%rax
   0x000000000040146b <+15>:    mov    %rax,0x8(%rsp)
   0x0000000000401470 <+20>:    lea    0x10(%rsi),%rax
   0x0000000000401474 <+24>:    mov    %rax,(%rsp)
   0x0000000000401478 <+28>:    lea    0xc(%rsi),%r9
   0x000000000040147c <+32>:    lea    0x8(%rsi),%r8
   0x0000000000401480 <+36>:    mov    $0x4025c3,%esi
   0x0000000000401485 <+41>:    mov    $0x0,%eax
   0x000000000040148a <+46>:    call   0x400bf0 <__isoc99_sscanf@plt>
   0x000000000040148f <+51>:    cmp    $0x5,%eax
   0x0000000000401492 <+54>:    jg     0x401499 <read_six_numbers+61>
   0x0000000000401494 <+56>:    call   0x40143a <explode_bomb>
   0x0000000000401499 <+61>:    add    $0x18,%rsp
   0x000000000040149d <+65>:    ret    
End of assembler dump.
```

è¿™é‡Œè¡¥å……ä¸‹gdbå¦‚ä½•å°†å†…å­˜æ•°æ®ä»¥intç±»å‹è¾“å‡ºï¼š

```bash
# ä»¥ int ç±»å‹è¾“å‡ºå†…å­˜åœ°å€ä¸º0x12345678å¤„çš„æ•°æ®
x/dw 0x12345678
```

åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œ`x` æ˜¯ GDB çš„æŸ¥çœ‹å†…å­˜å‘½ä»¤ï¼Œ`/dw` æŒ‡å®šäº†æ‰“å°æ ¼å¼ï¼Œå…¶ä¸­ `/d` è¡¨ç¤ºåè¿›åˆ¶ï¼Œ`w` è¡¨ç¤ºä»¥å­—ï¼ˆ4 å­—èŠ‚ï¼‰ä¸ºå•ä½è¿›è¡Œæ‰“å°ã€‚ä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´æ‰“å°çš„æ•°æ®å¤§å°å’Œå†…å­˜åœ°å€ã€‚

é€ä¸€åˆ†ææŒ‡ä»¤ï¼š

- `sub    $0x18,%rsp`ï¼šå¼€è¾Ÿ24bytesçš„æ ˆç©ºé—´ï¼ˆ6ä¸ªdouble wordç±»å‹æ•°æ®ï¼‰
- `mov    %rsi,%rdx`ï¼š           %rdx = %rsiã€‚ï¼ˆé—®ï¼šæ­¤æ—¶%rsiä¿å­˜çš„æ˜¯ä»€ä¹ˆï¼Ÿï¼‰æ­¤æ—¶%rsiä¿å­˜çš„æ˜¯`rsi            0x7fffffffe310`ã€‚
- `lea    0x4(%rsi),%rcx`ï¼š%rcx = %rsi + 4
- `lea    0x14(%rsi),%rax`ï¼š%rax = %rsi + 20
- `mov    %rax,0x8(%rsp)`ï¼šæ ˆé¡¶ä¸‹ç¬¬äºŒä¸ªintæ•°æ®ï¼ˆ0x7fffffffe2f8ï¼‰= 0x7fffffffe324
- `lea    0x10(%rsi),%rax`ï¼š%rax = %rsi + 16ï¼Œ%rax = 0x7fffffffe320
- `mov    %rax,(%rsp)`ï¼šï¼ˆ%rspï¼‰= %rsi + 16

é¢ï¼Œå¥½åƒä¸éœ€è¦åˆ†æäº†ã€‚

é¦–å…ˆé€šè¿‡`phase_2`ä»£ç å¯çŸ¥ï¼š

```assembly
Dump of assembler code for function phase_2:
=> 0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi		#å°†æ ˆæŒ‡é’ˆä¿å­˜åˆ°%rsiä¸­
   0x0000000000400f05 <+9>:     call   0x40145c <read_six_numbers>
```

è¿›å…¥å‡½æ•°`read_six_numbers`ä¹‹å‰ï¼Œæ ˆæŒ‡é’ˆå·²ç»ä¿å­˜åˆ°`%rsi`ä¸­äº†ã€‚è€Œ`phase_2`ä»£ç ä¸­å¯¹äºè¿”å›æ ˆç©ºé—´çš„å€¼ï¼Œéœ€è¦ä»æ ˆé¡¶å¼€å§‹ä¿å­˜æ•°æ®å¤§å°ä¸ºwordï¼ˆ4 bytesï¼‰çš„æ•°æ®ï¼Œæ•°æ®æ ¼å¼æ˜¯ä»1å¼€å§‹çš„æ¯”ä¾‹ä¸º2çš„ç­‰æ¯”åºåˆ—ã€‚

è¿›å…¥å‡½æ•°`read_six_numbers`ä¹‹åï¼Œå‘ç°å¾ˆå¤šæ“ä½œå°±æ˜¯å°†`phase_2`çš„æ ˆç©ºé—´åœ°å€åˆ†é…ç»™å„ä¸ªå¯„å­˜å™¨ï¼Œä¸éš¾æ¨æ–­å‡ºå‡½æ•°`read_six_numbers`å°±æ˜¯å°†è¾“å…¥çš„æ•°æ®åˆ†åˆ«åˆ†é…åˆ°`phase_2`çš„æ ˆç©ºé—´ä¸­ï¼Œé¢„æµ‹ä¸€æ³¢ç­”æ¡ˆ`1 2 4 8 16 32`ï¼Œè¾“å…¥åæœç„¶æ­£ç¡®ã€‚

è¡¥å……sscanfå‡½æ•°ï¼š

`sscanf` æ˜¯ C æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæŒ‰ç…§æŒ‡å®šçš„æ ¼å¼ä»å­—ç¬¦ä¸²ä¸­è¯»å–æ•°æ®å¹¶è¿›è¡Œè§£æã€‚å®ƒçš„å‡½æ•°åŸå‹å¦‚ä¸‹ï¼š

```C
int sscanf(const char *str, const char *format, ...);
```

- `str` æ˜¯è¦è§£æçš„å­—ç¬¦ä¸²ã€‚
- `format` æ˜¯æ ¼å¼æ§åˆ¶å­—ç¬¦ä¸²ï¼ŒæŒ‡å®šäº† `sscanf` å¦‚ä½•è§£æå­—ç¬¦ä¸²ä¸­çš„æ•°æ®ã€‚æ ¼å¼æ§åˆ¶å­—ç¬¦ä¸²ä¸­å¯ä»¥åŒ…å«è½¬æ¢è¯´æ˜ç¬¦ï¼Œç”¨æ¥æŒ‡å®šè¦è§£æçš„æ•°æ®ç±»å‹å’Œæ ¼å¼ã€‚
- `...` æ˜¯å¯å˜å‚æ•°åˆ—è¡¨ï¼Œç”¨æ¥æ¥æ”¶è§£æåçš„æ•°æ®ã€‚

`sscanf` å‡½æ•°çš„ä½œç”¨æ˜¯æ ¹æ®æŒ‡å®šçš„æ ¼å¼ä»å­—ç¬¦ä¸²ä¸­è¯»å–æ•°æ®å¹¶å­˜å‚¨åˆ°æŒ‡å®šçš„å˜é‡ä¸­ã€‚ä¾‹å¦‚:

```c
#include <stdio.h>

int main() {
    char str[] = "Hello 123 456";
    char word[10];
    int num1, num2;

    sscanf(str, "%s %d %d", word, &num1, &num2);
    printf("Word: %s\n", word);
    printf("Number 1: %d\n", num1);
    printf("Number 2: %d\n", num2);

    return 0;
}
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`sscanf(str, "%s %d %d", word, &num1, &num2)` ä»å­—ç¬¦ä¸² `str` ä¸­è§£æå‡ºä¸€ä¸ªå­—ç¬¦ä¸²ã€ä¸€ä¸ªæ•´æ•°å’Œå¦ä¸€ä¸ªæ•´æ•°ï¼Œå¹¶åˆ†åˆ«å­˜å‚¨åˆ°å˜é‡ `word`ã€`num1` å’Œ `num2` ä¸­ã€‚ç„¶åé€šè¿‡ `printf` å‡½æ•°è¾“å‡ºè¿™äº›æ•°æ®ã€‚

`sscanf` çš„è¿”å›å€¼ `result` å°†ä¼šæ˜¯è§£ææˆåŠŸçš„å‚æ•°ä¸ªæ•°ï¼Œå¦‚æœè¿”å›å€¼ç­‰äºæ ¼å¼å­—ç¬¦ä¸²ä¸­çš„å‚æ•°ä¸ªæ•°ï¼Œåˆ™è¡¨ç¤ºè§£ææˆåŠŸã€‚å¦‚æœè§£æå¤±è´¥æˆ–è€…æ²¡æœ‰åŒ¹é…åˆ°ä»»ä½•æ•°æ®ï¼Œ`sscanf` çš„è¿”å›å€¼å°†ä¼šæ˜¯ 0ã€‚

è¿™é‡Œé˜¶æ®µ2é‡ç‚¹æ˜¯å‡½æ•°`sscanf`çš„ä½œç”¨ï¼ŒæŒ–ä¸ªå‘ï¼Œç­‰æ—¥åæ•´ç†ç¬”è®°çš„æ—¶å€™ï¼Œé‡æ–°å›é¡¾ä¸‹è¿™ä¸ªé—®é¢˜ã€‚

ç°åœ¨çœ‹é˜¶æ®µ3ï¼Œphase3ä»£ç ï¼š

```assembly
(gdb) disassemble 
Dump of assembler code for function phase_3:
   0x0000000000400f43 <+0>:     sub    $0x18,%rsp
   0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx			#ç¬¬äºŒä¸ªå‚æ•°çš„æŒ‡é’ˆæ˜¯ 0xc(%rsp)
   0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx			#ç¬¬ä¸€ä¸ªå‚æ•°çš„æŒ‡é’ˆæ˜¯ 0x8(%rsp)
   0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi
   0x0000000000400f56 <+19>:    mov    $0x0,%eax
=> 0x0000000000400f5b <+24>:    call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:    call   0x40143a <explode_bomb>
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)			#ç¬¬ä¸€ä¸ªå‚æ•°è¦å°äº7
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>
   0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax			#ç¬¬ä¸€ä¸ªå‚æ•°çš„æŒ‡é’ˆèµ‹ç»™eax
   0x0000000000400f75 <+50>:    jmp    *0x402470(,%rax,8)
   0x0000000000400f7c <+57>:    mov    $0xcf,%eax
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:    mov    $0x2c3,%eax
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    $0x100,%eax
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    $0x185,%eax
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    $0xce,%eax
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    $0x147,%eax
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:   call   0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:   mov    $0x0,%eax
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    $0x137,%eax
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax	# ç¬¬äºŒä¸ªå‚æ•°éœ€è¦ç¬¦åˆeaxï¼ˆ+57åˆ°+104movä¼ é€’çš„å‚æ•°ï¼‰ä¸Šé¢çš„å–å€¼
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:   call   0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   ret    
End of assembler dump.
```

åœ¨æ‰§è¡Œ`call   0x400bf0 <__isoc99_sscanf@plt>`ä¹‹å‰ï¼Œåˆ†æsscanfå‡½æ•°çš„å…¥å‚ï¼š

- ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²åœ°å€ï¼Œç”±%rdiä¿å­˜ã€‚

- ç¬¬äºŒä¸ªå‚æ•°ï¼ˆ%rsiï¼‰æ˜¯æ ¼å¼æ§åˆ¶å­—ç¬¦ä¸²ï¼ŒæŒ‡å®šäº† `sscanf` å¦‚ä½•è§£æå­—ç¬¦ä¸²ä¸­çš„æ•°æ®ã€‚æ‰“å°%rsiçš„æ•°æ®ä¸º:

  ```assembly
  (gdb) x/s $rsi
  0x4025cf:       "%d %d"
  ```

  è¿™é‡Œå¯ä»¥å¾—çŸ¥sccanfå‡½æ•°ä¼šå°†è¾“å…¥çš„å­—ç¬¦ä¸²åˆ†å‰²ä¸ºä¸¤ä¸ªæ•´æ•°ã€‚

- é‚£ä¹ˆå„è‡ªä¿å­˜ä¸¤ä¸ªæ•´æ•°çš„åœ°å€å°±æ˜¯%rdxå’Œ%rcxäº†ã€‚

è¿™é‡Œçš„é—®é¢˜å°±åœ¨äº`jmp    *0x402470(,%rax,8)`è¿™ä¸ªé—´æ¥è·³è½¬æŒ‡ä»¤ã€‚è¿™ä¸ªè·³è½¬æŒ‡ä»¤çš„æ„æ€å°±æ˜¯ä»å†…å­˜ä¸­è¯»å‡ºä¸€ä¸ªåœ°å€è¿›è¡Œè·³è½¬ã€‚

ç¬¬ä¸€ä¸ªå‚æ•°è¾“å…¥2ï¼Œé‚£ä¹ˆå¯»å€å°±æ˜¯0x402470(hex) + 2*8(dec) = 0x402480ï¼Œæ‰“å°è¿™ä¸ªåœ°å€å¤„çš„æ•°æ®ï¼š

```assembly
(gdb) x/4x 0x402480
0x402480:       0x83    0x0f    0x40    0x00
```

é‚£å°±æ˜¯è·³è½¬åˆ°åœ°å€ä¸º`0x400f83`çš„ä½ç½®ä¸Šå»æ‰§è¡Œä»£ç ï¼š

```assembly
(gdb) x/i 0x400f83
   0x400f83 <phase_3+64>:       mov    $0x2c3,%eax
```

ä»ä¸Šé¢åæ±‡ç¼–çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼Œå°†`0x2c3`èµ‹å€¼ç»™eaxåï¼Œå‡½æ•°å°±ä¼šå°†è¾“å…¥çš„ç¬¬äºŒä¸ªå‚æ•°ä¸eaxåšæ¯”è¾ƒï¼Œå¦‚æœç›¸ç­‰ï¼Œåˆ™ä¸ä¼šå¼•çˆ†ç‚¸å¼¹ã€‚æ‰€ä»¥å¦‚æœç¬¬ä¸€ä¸ªå‚æ•°è¾“å…¥2ï¼Œé‚£ä¹ˆç¬¬äºŒä¸ªå‚æ•°è¾“å…¥å¿…é¡»æ˜¯`0x2c3 == 707`

## 4.29

ä¸‹é¢å¼€å§‹åˆ†æphase_4ï¼š

```assembly
Dump of assembler code for function phase_4:
   0x000000000040100c <+0>:     sub    $0x18,%rsp
   0x0000000000401010 <+4>:     lea    0xc(%rsp),%rcx
   0x0000000000401015 <+9>:     lea    0x8(%rsp),%rdx
   0x000000000040101a <+14>:    mov    $0x4025cf,%esi
   0x000000000040101f <+19>:    mov    $0x0,%eax
=> 0x0000000000401024 <+24>:    call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000401029 <+29>:    cmp    $0x2,%eax
   0x000000000040102c <+32>:    jne    0x401035 <phase_4+41>
   0x000000000040102e <+34>:    cmpl   $0xe,0x8(%rsp)
   0x0000000000401033 <+39>:    jbe    0x40103a <phase_4+46>
   0x0000000000401035 <+41>:    call   0x40143a <explode_bomb>
   0x000000000040103a <+46>:    mov    $0xe,%edx
   0x000000000040103f <+51>:    mov    $0x0,%esi
   0x0000000000401044 <+56>:    mov    0x8(%rsp),%edi
   0x0000000000401048 <+60>:    call   0x400fce <func4>
   0x000000000040104d <+65>:    test   %eax,%eax
   0x000000000040104f <+67>:    jne    0x401058 <phase_4+76>
   0x0000000000401051 <+69>:    cmpl   $0x0,0xc(%rsp)
   0x0000000000401056 <+74>:    je     0x40105d <phase_4+81>
   0x0000000000401058 <+76>:    call   0x40143a <explode_bomb>
   0x000000000040105d <+81>:    add    $0x18,%rsp
   0x0000000000401061 <+85>:    ret
```

ä¾æ—§æ˜¯å‡½æ•°`sscanf`ï¼ŒæŸ¥çœ‹ç¬¬äºŒä¸ªå‚æ•°æŸ¥çœ‹å¦‚ä½•è§£æå­—ç¬¦ä¸²ä¸­çš„æ•°æ®ï¼š

```assembly
(gdb) x/s $esi
0x4025cf:       "%d %d"
```

å¯ä»¥å¾—å‡ºéœ€è¦è¾“å…¥ä¸¤ä¸ªæ•°å­—ï¼Œè€Œç¬¬ä¸€ä¸ªæ•°å­—ä¿å­˜åœ¨`0x8(%rsp)`ï¼Œç¬¬äºŒä¸ªæ•°å­—å­˜æ”¾åœ¨`0xc(%rsp)`ã€‚

ç„¶åä¸‹é¢ä»£ç å°±æ˜¯åˆ¤æ–­ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å¦å°äº14ï¼ˆ`cmpl   $0xe,0x8(%rsp)`ï¼‰ï¼Œä¸æ˜¯çš„è¯ç›´æ¥çˆ†ç‚¸ã€‚

å‡è‹¥ç¬¬ä¸€ä¸ªå…¥å‚å°äº14ï¼Œåˆ™å°†ç¬¬ä¸€ä¸ªå‚æ•°å’Œ0ä¼ ç»™`<func4>`ï¼Œå¹¶ä¸”æ ¡éªŒè¿”å›å€¼æ˜¯å¦ä¸º0ï¼Œå¦‚æœä¸ä¸º0ï¼Œåˆ™çˆ†ç‚¸ã€‚

ä¸‹é¢åˆ†æä¸‹`<func4>`çš„ä»£ç ï¼Œçœ‹çœ‹å¦‚ä½•æ‰èƒ½è®©å‡½æ•°çš„è¿”å›å€¼ä¸º0ï¼š

```assembly
(gdb) disassemble
Dump of assembler code for function func4:
=> 0x0000000000400fce <+0>:     sub    $0x8,%rsp
   0x0000000000400fd2 <+4>:     mov    %edx,%eax
   0x0000000000400fd4 <+6>:     sub    %esi,%eax
   0x0000000000400fd6 <+8>:     mov    %eax,%ecx
   0x0000000000400fd8 <+10>:    shr    $0x1f,%ecx	#shr k,D D â† D>>L k Logical right shift
   0x0000000000400fdb <+13>:    add    %ecx,%eax
   0x0000000000400fdd <+15>:    sar    %eax			#sar k,D D â† D>>A k Arithmetic right shift
   0x0000000000400fdf <+17>:    lea    (%rax,%rsi,1),%ecx
   0x0000000000400fe2 <+20>:    cmp    %edi,%ecx
   0x0000000000400fe4 <+22>:    jle    0x400ff2 <func4+36>
   0x0000000000400fe6 <+24>:    lea    -0x1(%rcx),%edx
   0x0000000000400fe9 <+27>:    call   0x400fce <func4>
   0x0000000000400fee <+32>:    add    %eax,%eax
   0x0000000000400ff0 <+34>:    jmp    0x401007 <func4+57>
   0x0000000000400ff2 <+36>:    mov    $0x0,%eax
   0x0000000000400ff7 <+41>:    cmp    %edi,%ecx
   0x0000000000400ff9 <+43>:    jge    0x401007 <func4+57>
   0x0000000000400ffb <+45>:    lea    0x1(%rcx),%esi 		#Imm(rb) M[Imm + R[rb]] Base + displacement
   0x0000000000400ffe <+48>:    call   0x400fce <func4>
   0x0000000000401003 <+53>:    lea    0x1(%rax,%rax,1),%eax #Imm(rb,ri,s) M[Imm + R[rb]+ R[ri] . s] Scaled indexed
   0x0000000000401007 <+57>:    add    $0x8,%rsp
   0x000000000040100b <+61>:    ret

```

æ­¤æ—¶æŸ¥çœ‹å¯„å­˜å™¨çŠ¶æ€ï¼š

- `mov    %edx,%eax`ï¼š eax = 14

- `sub    %esi,%eax`ï¼šeax = eax - 0 = 14 - 0= e

- `mov    %eax,%ecx`ï¼šecx = eax = e

- `shr    $0x1f,%ecx`ï¼šecx = ecx >>L 31ï¼ˆä¿ç•™ç¬¦å·ä½ï¼‰= 0

- `add    %ecx,%eax`ï¼šeax = eax + sign_bit(eax)(1 or 0) = e

- `sar %eax` ï¼šè¡¨ç¤ºå°† `%eax` å¯„å­˜å™¨ä¸­çš„å€¼å‘å³ç§»åŠ¨ä¸€ä½ï¼Œå¹¶ç”¨æœ€é«˜ä½çš„å€¼å¡«å……å·¦ä¾§ç©ºå‡ºçš„ä½ã€‚è¿™ä¸ªæ“ä½œé€šå¸¸ç”¨äºå®ç°æ•´æ•°çš„é™¤æ³•è¿ç®—ï¼Œå› ä¸ºç®—æœ¯å³ç§»ç›¸å½“äºå°†æ•°å€¼é™¤ä»¥ 2 çš„å¹‚æ¬¡æ–¹ã€‚eax = eax / 2 = 7

- `lea    (%rax,%rsi,1),%ecx`ï¼šecx = rax + rsi = 7 + 0 = 7

- `cmp    %edi,%ecx`ï¼š7 - 2 = 5ï¼Œå› ä¸ºæ­¤æ—¶ç»“æœå¤§äº0ï¼Œåˆ™ä¸ä¼šæ‰§è¡Œ`jle    0x400ff2 <func4+36>`

- `lea    -0x1(%rcx),%edx`:edx = rcx - 1 = 6

-  `call   0x400fce <func4>`(è°ƒç”¨func4)ï¼šè¿™é‡Œæ¶‰åŠåˆ°äº†é€’å½’è°ƒç”¨çš„é€»è¾‘ï¼š

  å¯ä»¥å¾—çŸ¥ï¼Œæˆ‘éœ€è¦ç”¨Cè¯­è¨€å†™ä¸€ä¸‹è¿™ä¸ªä»£ç é€»è¾‘ï¼š

```c
int func4(int rdi, int rsi, int rdx){
	//rdi = param1, rsi =0, rdx = 14,
    //return value = rax

	rax = rdx - rsi;
	rcx = (unsigned) rax >> 31; //sign_bit
	
	rax = (rax + (unsigned) rax >> 31) /2;
	
	rcx = rax + rsi;
	
	if(rcx > rdi){
		
		return 2 * func4(rdi, rsi, rcx - 1);
		
	}else if(rcx < rdi)
		
		return 2 * func4(rdi, rcx + 1, rdx) + 1;
		
	}else{
		
		return 0;
	}
}
```

è¿™ä¸ªé—®é¢˜å¡äº†æˆ‘ä¸€ä¸ªå°æ—¶ï¼Œå…¶å®å¹¶ä¸éœ€è¦å†™ä¸‹æ¯ä¸€ä¸ªæŒ‡ä»¤çš„ä½œç”¨ï¼Œè€Œæ˜¯éœ€è¦ç»„å—èµ·æ¥ï¼Œæ‹¼è£…å‡½æ•°æ•´ä½“é€»è¾‘ã€‚

è¿™é‡Œçš„çŸ¥è¯†å°±æ˜¯é€’å½’å‡½æ•°çš„æ±‡ç¼–æŒ‡ä»¤è¾¨åˆ«ï¼šcall func4åï¼Œè¿”å›å€¼ä¸ºeaxï¼Œç„¶åå¯¹eaxæ“ä½œï¼Œè¿™æ ·å°±éšè—äº†ä¸€ä¸ªé€’å½’è°ƒç”¨æœ¬å‡½æ•°çš„æµç¨‹ã€‚

ç»ˆäºå‘ç°äº†é—®é¢˜æ‰€åœ¨ï¼šå¤ä¹ æ“ä½œæ•°çš„æ¥æºï¼š

```C
Imm(rb) 	 M[Imm + R[rb]] 				Base + displacement
Imm(rb,ri,s) M[Imm + R[rb]+ R[ri] . s] 		Scaled indexed
```

è¿™æ ·åæ±‡ç¼–åˆ°Cè¯­è¨€åï¼Œåˆ†æä¸‹å¦‚ä½•å¾—åˆ°0è¿”å›å€¼ï¼š

å°±æ˜¯è®©rcx == rdiã€‚æ ¹æ®

```assembly
	rax = rdx - rsi;			#rax = 14  
	rcx = (unsigned) rax >> 31; #rcx = 0
	rax = (rax + (unsigned) rax >> 31) /2; //rax = 7
	rcx = rax + rsi;			#rcx = 7
```

å¦‚æœæƒ³ç¬¬ä¸€è½®çš„æ—¶å€™å°±è®©æ¡ä»¶`rcx == rdi`æˆç«‹ï¼Œé‚£ä¹ˆ`parm1`å¿…é¡»æ˜¯7ã€‚ç„¶åç¬¬äºŒä¸ªå‚æ•°æ ¹æ®`phase_4`ä»£ç ï¼š`cmpl   $0x0,0xc(%rsp)`å¯ä»¥åˆ¤æ–­å‡ºæ˜¯0ã€‚

è¾“å…¥`7 0`ï¼Œé˜¶æ®µ4æˆåŠŸé€šè¿‡ã€‚

é˜¶æ®µ4æ€»ç»“ï¼š

- å¦‚æœåˆ†ææ—¶é—´è¾ƒé•¿ï¼Œç›´æ¥çœ‹ç­”æ¡ˆå°±è¡Œäº†ï¼Œå› ä¸ºæœ‰è‡ªå·±æ²¡ç»•è¿‡å»çš„å¼¯æˆ–è€…ä¸å…·å¤‡çš„å‰ç½®çŸ¥è¯†é˜»ç¢äº†è‡ªå·±çš„æ€è€ƒã€‚è¿™é‡Œçš„ä¾‹å­å°±æ˜¯é€’å½’è°ƒç”¨ä¸äº†è§£å’Œæ“ä½œæ•°çš„å–å€¼ä¸ç†Ÿæ‚‰å¯¼è‡´çš„ä»£ç åæ±‡ç¼–å¼‚å¸¸å›°éš¾ã€‚

åˆ†æphase_5ï¼š

```assembly
(gdb) disassemble phase_5
Dump of assembler code for function phase_5:
   0x0000000000401062 <+0>:     push   %rbx
   0x0000000000401063 <+1>:     sub    $0x20,%rsp
   0x0000000000401067 <+5>:     mov    %rdi,%rbx				# char* rbx = rdi
   0x000000000040106a <+8>:     mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:    mov    %rax,0x18(%rsp)
   0x0000000000401078 <+22>:    xor    %eax,%eax
   0x000000000040107a <+24>:    call   0x40131b <string_length>
   0x000000000040107f <+29>:    cmp    $0x6,%eax				# length(input_string) == 6
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:    call   0x40143a <explode_bomb>
   0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx		# ecx = mem(input_string)&0xFF(åˆå§‹) --å°†å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—ç¬¦èµ‹å€¼ç»™ecx
   																# 	 => mem(input_string + rax)&0xFF
   0x000000000040108f <+45>:    mov    %cl,(%rsp)				# *rsp = ecx & 0xFF 	-- ç¬¬ä¸€ä¸ªå­—ç¬¦å€¼å†™å…¥åˆ°æ ˆé¡¶
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx				# rdx = *rsp			
   0x0000000000401096 <+52>:    and    $0xf,%edx				# rdx = rdx & 0xF		-- ç¬¬ä¸€ä¸ªå­—ç¬¦å€¼çš„ä½4ä½èµ‹å€¼ç»™rdx
   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx		# rdx = mem(0x4024b0 + rdx) & 0xFF -- è·å–å†…å­˜æŸå¤„çš„ä¸€ä¸ªå­—èŠ‚æ•°æ®
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)	# mem(0x10 + rsp + rax) = rdx & 0xFï¼ˆåˆå§‹ï¼‰
   0x00000000004010a4 <+66>:    add    $0x1,%rax				# rax = 0 + 1 + 1 + ...
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax				# if rax != 6
   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>
   0x00000000004010ae <+76>:    movb   $0x0,0x16(%rsp)			# mem(rsp + 0x16) = 0		
   0x00000000004010b3 <+81>:    mov    $0x40245e,%esi			# *esi = flyers
   0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi			
   0x00000000004010bd <+91>:    call   0x401338 <strings_not_equal> #if(*(rsp + 0x10) == "flyers")
   0x00000000004010c2 <+96>:    test   %eax,%eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:   call   0x40143a <explode_bomb>
   0x00000000004010cb <+105>:   nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 <+110>:   jmp    0x4010d9 <phase_5+119>
   0x00000000004010d2 <+112>:   mov    $0x0,%eax
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>
   0x00000000004010d9 <+119>:   mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:   xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:   je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:   call   0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:   add    $0x20,%rsp
   0x00000000004010f2 <+144>:   pop    %rbx
   0x00000000004010f3 <+145>:   ret
End of assembler dump.
```

çœ‹ä¸‹å‡½æ•°`string_length`çš„ä»£ç å®ç°ï¼š

```assembly
(gdb) disassemble string_length
Dump of assembler code for function string_length:
   0x000000000040131b <+0>:     cmpb   $0x0,(%rdi)
   0x000000000040131e <+3>:     je     0x401332 <string_length+23>
   0x0000000000401320 <+5>:     mov    %rdi,%rdx	# char* rdx = rdi 
   0x0000000000401323 <+8>:     add    $0x1,%rdx	# rdx = rdx + 1
   0x0000000000401327 <+12>:    mov    %edx,%eax	# char* rax = rdx
   0x0000000000401329 <+14>:    sub    %edi,%eax	# rax = rdi + 1 - rdi = 1
   0x000000000040132b <+16>:    cmpb   $0x0,(%rdx)	# if rdi[1] != Null
   0x000000000040132e <+19>:    jne    0x401323 <string_length+8> # rax + 1
   0x0000000000401330 <+21>:    repz ret
   0x0000000000401332 <+23>:    mov    $0x0,%eax
   0x0000000000401337 <+28>:    ret
End of assembler dump.
```

å…¥å‚åªæœ‰ä¸€ä¸ª%rdiï¼Œä¿å­˜çš„æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²æŒ‡é’ˆã€‚å¦‚æœå…¥å‚ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œåˆ™è¿”å›0ã€‚å¦‚æœä¸ä¸º0ï¼Œåˆ™è®°å½•å­—ç¬¦ä¸²é•¿åº¦ã€‚

å…¶ä¸­rdxç›¸å½“äºå­—ç¬¦ä¸²æŒ‡é’ˆï¼Œæ¯æ¬¡éƒ½æŒ‡å‘å­—ç¬¦ä¸²çš„ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œç›´åˆ°é‡åˆ°ç©ºå­—ç¬¦ï¼ˆasciiä¸ºNULï¼‰æˆªæ­¢ï¼Œæ¯æ¬¡ç§»åŠ¨éƒ½ä¼šä½¿å¾—eax+1ã€‚

æ‰€ä»¥è¿™é‡Œè¾“å…¥çš„å­—ç¬¦ä¸²é•¿åº¦éœ€è¦ä¸º6ã€‚åˆ†æåˆ°æŒ‡ä»¤`movzbl 0x4024b0(%rdx),%edx`çš„æ—¶å€™ï¼Œå‘ç°è¿™ä¸ªåœ°å€çš„æ•°æ®çš„ç¡®ä¸æ¸…æ¥šæ˜¯ä»€ä¹ˆï¼Œå…ˆè¾“å…¥å­—ç¬¦ä¸²`123456`çœ‹çœ‹ç»“æœå§ã€‚

å‡½æ•°+39-- +74çš„ä»£ç åæ±‡ç¼–ä¸ºCè¯­è¨€ä»£ç ä¸ºï¼š

```C
int rax = 0;
char* rbx = rdi;		 // rdi = input_string
while (rax != 6){		 // cmp    $0x6,%rax
    char rcx = rbx[rax]; // movzbl (%rbx,%rax,1),%ecx
    char *rsp = rcx;     // mov    %cl,(%rsp)
    //char rdx = rcx;		// mov    (%rsp),%rdx
    //rdx = rdx & 0xF;	 	// and    $0xf,%edx
    //rdx = mem(0x4024b0 + rdx) & 0xFF 		// movzbl 0x4024b0(%rdx),%edx
    //mem(0x10 + rsp + rax) = rdx & 0xFF;	// mov    %dl,0x10(%rsp,%rax,1)0
    //ç›¸å½“äºå°†rsp + 0x10ã€11ã€12ã€13ã€14ã€15å¤„çš„ç©ºé—´ï¼Œè¢«mem(0x4024b0 + input[i] & 0xF)èµ‹å€¼
    mem(rsp + 0x10 +rax) = mem(0x4024b0 + rbx[rax] & 0xF) & 0xFF //ä¸Šé¢4è¡Œä»£ç çš„æŠ½è±¡
    rax++;				 // add    $0x1,%rax
}
```

æ‰“å°`0x4024b0`å¤„çš„æ•°æ®ï¼š

```bash
(gdb) x/s 0x4024b0
0x4024b0 <array.3449>:  "maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"
```

ç„¶ååˆ†æ+76åçš„ä»£ç ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºCä¼ªä»£ç ï¼š

```C
//+76
/* mem(0x4024b0) :
	(gdb) x/16x 0x4024b0
	0x4024b0 <array.3449>:  		0x6d    0x61    0x64    0x75    0x69    0x65    0x72    0x73
	0x4024b8 <array.3449+8>:        0x6e    0x66    0x6f    0x74    0x76    0x62    0x79    0x6c
*/
if(*(rsp + 0x10) == (char)*esi){
    *(rsp + 0x10) = "flyers";
    *(rsp + 0x10) = 0x66; //if mem(0x4024b0 + rbx[0] & 0xF) == 0x66 -->rbx[0]& 0xF = 9 -->rbx[0] = 0xn9  
    *(rsp + 0x11) = 0x6c; //if mem(0x4024b0 + rbx[1] & 0xF) == 0x6c -->rbx[1]& 0xF = F -->rbx[0] = 0xnF
    *(rsp + 0x12) = 0x79; //if mem(0x4024b0 + rbx[2] & 0xF) == 0x79 -->rbx[1]& 0xF = E -->rbx[0] = 0xnE
    *(rsp + 0x13) = 0x65; //if mem(0x4024b0 + rbx[3] & 0xF) == 0x65 -->rbx[1]& 0xF = 5 -->rbx[0] = 0xn5
    *(rsp + 0x14) = 0x72; //if mem(0x4024b0 + rbx[4] & 0xF) == 0x72 -->rbx[1]& 0xF = 6 -->rbx[0] = 0xn6
    *(rsp + 0x15) = 0x73; //if mem(0x4024b0 + rbx[5] & 0xF) == 0x73 -->rbx[1]& 0xF = 7 -->rbx[0] = 0xn7
}
```

è¦æƒ³è®©`strings_not_equal`å‡½æ•°æ­£å¸¸ï¼Œå°±éœ€è¦è®©rdiæŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦ä¸²å’ŒrsiæŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦ä¸²ç­‰é•¿ä¸”å¯¹åº”ä½ç½®å­—ç¬¦ç›¸åŒã€‚è€Œæ­¤æ—¶rsiæŒ‡å‘çš„å­—ç¬¦ä¸²ä¸ºï¼š

```assembly
(gdb) x/s $rsi
0x40245e:       "flyers"
```

é‚£ä¹ˆå°±éœ€è¦è®©`*(rsp + 0x10)`çš„æ•°æ®ä¹Ÿä¸º`flyers`æ‰å¯ä»¥ã€‚

å°†`flyers`çš„ASCIIç åˆ†åˆ«å¯¹åº”ä»`mem(rsp + 0x10)`å¼€å§‹çš„6ä¸ªå­—èŠ‚ï¼š

```C
	*(rsp + 0x10) = 0x66;// f 
    *(rsp + 0x11) = 0x6c;// l
    *(rsp + 0x12) = 0x79;// y
    *(rsp + 0x13) = 0x65;// e
    *(rsp + 0x14) = 0x72;// r
    *(rsp + 0x15) = 0x73;// s
```

å†å›å¤´åˆ†æ`mem(rsp + 0x10 +rax)`çš„èµ‹å€¼è¯­å¥ï¼š

```C
 mem(rsp + 0x10 +rax) = mem(0x4024b0 + rbx[rax] & 0xF) & 0xFF 
```

ä¸¾ä¾‹ï¼šå½“rax = 0çš„æ—¶å€™ï¼Œéœ€è¦ç»™`mem(rsp + 0x10)`èµ‹å€¼`0x66`ï¼Œè€Œèµ‹çš„å€¼æ˜¯ä»`0x4024b0 + rbx[0] & 0xF`è·å–åˆ°çš„ï¼Œè€Œçºµè§‚`mem(0x4024b0)`çš„æ•°æ®ï¼š

```assembly
	(gdb) x/16x 0x4024b0
	0x4024b0 <array.3449>:  		0x6d    0x61    0x64    0x75    0x69    0x65    0x72    0x73
	0x4024b8 <array.3449+8>:        0x6e    0x66    0x6f    0x74    0x76    0x62    0x79    0x6c
```

å¯ä»¥çœ‹å‡ºåœ¨`0x4024b9`å¤„æ‰èƒ½è·å–åˆ°`0x66`ï¼Œæ‰€ä»¥`rbx[0] & 0xF = 0x9`ï¼Œè¿™æ—¶å€™`rbx[0] = 0xn9`å³å¯ã€‚ï¼ˆè¿™é‡Œçš„nä»£è¡¨0-Fçš„ä»»æ„æ•°æ®éƒ½å¯ï¼Œå› ä¸ºè¿™é‡Œçš„nä¼šè¢«åé¢çš„0XFä¸è¿ç®—æˆªæ‰ï¼Œä¸å‚ä¸è¿ç®—ï¼‰è€Œå­—ç¬¦`9`çš„ASCIIç æ­£å¥½æ˜¯`0x39`ï¼Œç¬¦åˆ`0xn9`çš„æœ€ä½å­—èŠ‚æ˜¯9çš„æ¡ä»¶ã€‚æ‰€ä»¥è¾“å…¥çš„å­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªå¯ä»¥æ˜¯`9`ã€‚

åŒç†å¯ä»¥ç¡®è®¤æ­£ç¡®å­—ç¬¦ä¸²çš„å…¶ä»–ä½çš„ASCIIç ï¼š

```C
if mem(0x4024b0 + rbx[0] & 0xF) == 0x66 -->rbx[0]& 0xF = 9 -->rbx[0] = 0xn9  
if mem(0x4024b0 + rbx[1] & 0xF) == 0x6c -->rbx[1]& 0xF = F -->rbx[0] = 0xnF
if mem(0x4024b0 + rbx[2] & 0xF) == 0x79 -->rbx[1]& 0xF = E -->rbx[0] = 0xnE
if mem(0x4024b0 + rbx[3] & 0xF) == 0x65 -->rbx[1]& 0xF = 5 -->rbx[0] = 0xn5
if mem(0x4024b0 + rbx[4] & 0xF) == 0x72 -->rbx[1]& 0xF = 6 -->rbx[0] = 0xn6
if mem(0x4024b0 + rbx[5] & 0xF) == 0x73 -->rbx[1]& 0xF = 7 -->rbx[0] = 0xn7
```

è¿™æ ·å°±å¯ä»¥è·å–phase_5çš„flagï¼š`9on567`ï¼Œå¹¶ä¸”è¾“å…¥åæˆåŠŸæ‹†è§£`phase_5`ç‚¸å¼¹ã€‚

çˆ½ï¼ğŸ˜

ç°åœ¨æ˜¯å‡Œæ™¨2ç‚¹16åˆ†ï¼Œæœˆæ˜æ˜Ÿç¨€ï¼Œä¸çŸ¥ä¹Œé›€åœ¨å“ªï¼Œç¡è§‰ï¼
