# 7月日报

## 7.13

今日周六，乔迁至新居，今天准备将csapp的缓存终结，然后将学习记录放到博客园。

不过这个32寸的显示器真的很大，现在看的我有点不舒服的。

现在正在纠结买什么装备

## 7.15

How does the cache know whether it contains a copy of the word at address A?

1. 地址A的Set索引，查找对应的cache块

2. 地址A的tag位，查找对应cache块中的行

   当且仅当对应cache行的有效位置为1的时候，可以进行下一步操作

3. 地址A的块偏移B，查找对应的字的块

缓存涉及到的三个参数以后会反复出现，所以需要记忆一下：

- S = 2^s : Number of sets
- E: Number of lines per set
- B = 2b Block size (bytes)

## 7.16

用地址中部的位作为缓存行的索引原因（对比高位作为索引的优劣）

- 用内存地址的高位作为缓存行的索引，会导致连续的数据存储在同一个缓存行中。因此，每次新地址被加载时，都会替换掉之前的地址，导致频繁的缓存替换和冲突。
- 即使访问了数组的几个连续元素，缓存只使用了一个行，其它剩余行未被使用，导致缓存利用率非常低。

优势：

1. **均匀分布**：

- 地址中部的位更频繁地变化，使得访问更均匀地分布在缓存的所有行中，避免特定行的过度使用和其他行的未使用。

2. **减少冲突**：

- 由于访问模式的局部性，连续或邻近的内存地址会映射到不同的缓存行，减少冲突替换，提高缓存命中率。

3. **更高的缓存命中率**：

- 当程序访问连续内存时，中位索引将这些访问分散到多个缓存行，减少不必要的替换，保持更多有用的数据在缓存中。

## 7.17

 An array is cache-aligned：

1. **The size of each array element matches the size of the cache block.**
2. **The starting address of the array is a multiple of the cache block size.**

Let's elaborate on these points:

1. **Array Element Size Matches Cache Block Size**

If each element of the array is exactly the size of a cache block, then each access to an element of the array aligns perfectly with the cache block. This ensures that fetching an element from the array fetches exactly one cache block, optimizing memory access patterns.

2. **Starting Address is a Multiple of the Cache Block Size**

When the starting address of the array is a multiple of the cache block size, it means that the first element of the array is aligned with the beginning of a cache block. This alignment ensures that subsequent elements, which are cache block-sized, also align perfectly with subsequent cache blocks.

## 7.18

今天读完了csapp的存储章节，对于缓存山反映出的步长和数据大小对于局部性的影响问题。

今天在群里划水的时候，偶然发现了大佬学习公开课的方法：一个月1门课，每次都要用项目的ddl来push自己不断前进。而且哥们还找到了很多外国的对应项目，既把知识学了，还把钱赚了，一举两得，实在佩服。

而且大哥做的笔记分门别类，一目了然，甚得我心。

对于自己的启示就是ddl和笔记。

从7.18开始，开始南京大学的pa项目，每周push一个PA大作业，这样5个PA大作业，35天足够。

也就是在8月24号，结束南京大学PA项目，并且要写好每个阶段的实验报告，做了什么，以及对应的思考。

对于为何做PA项目，其中两个原因是最重要的。

一是久闻PA大名，在22年就想系统地做一遍，可惜当时因为自己的三天打鱼两天晒网，给搁置了很久，结果后面面对剩余的部分居然心生恐惧不敢继续了。所以这一次，我一定要赢——赢了当时那个软弱的自己。

另一个就是，我真的想要了解计算机是怎么运行起来的，而这个PA项目就是模拟一个计算机的结构，正合我意。

所以，今天就是这样子，明天开干！

## 7.19

今天两个事情，一个是开新帖：cachelab和pa；另一个就是读书。

已经开始了PA0的新阶段，主要是学到了package distributor是打包和维护软件，并发布到源的“软件提供者”角色；源是存储和分发这些软件包的服务器或镜像站点，类似“软件仓库”；而`apt`工具用于访问这些源，从中下载、安装、更新和管理软件包。

明天应该是清理空调+`git`  + `vimtutor`的一天。

## 7.20

直面linux命令行的恐惧，每天一个小命令。

## 7.22

这两天和宝贝上分，很开心。

今天

- [x]  学习`tail`命令（`-f`实时跟踪文件内容，`-n`输出文件最后几行的内容）
- [x] 完成PA0
- [x] cachelab开始

## 7.23

昨天ns lite到手，折腾了半天，还是默认日服领了金币。

今天准备要做的事情：

- [x] cachelab分析
- [x] 学习命令`find`：发现遇到`man`就会头大，明天开始学习如何看懂`man`命令
- [x] PA1开始

## 7.24

- [x] 解决cachelab疑问-单映射缓存和地址的映射
- [x] 学习getopt的相关用法
- [x] 学习man的使用方法
- [x] 跑步5km

番茄1：回顾缓存的冷丢失、LRU（最近最少使用）策略的本质和链表实现方法

## 7.25

- [x] cache.h文件编写
- [x] 完成`init_cache`方法
- [x] 继续学习man的操作指令
- [x] 干净做饭

## 7.28

- [x] 完成匹配缓存行函数`find_cache_line()`
- [x] 完成获取缓存字节数据函数`access_cache_word()`
- [x] 完成插入缓存行函数`insert_cache_line()q`
- [x] 将修改提交到github

## 7.29

南大我来了~

- [x] 写完`init_cache`的单元测试，并且执行测试

## 7.30

- [x] 获取缓存字节数据函数`access_cache_word()`单元测试
- [x] 插入缓存行函数`insert_cache_line()`的单元测试
- [x] 加入LRU算法修改代码

## 7.31

- [x] 完成cachela内存操作
  - [x] 内存地址地址转换函数
